This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-26T17:05:58.995Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
client/java/ninja/trek/camera/CameraSystem.java
client/java/ninja/trek/CameraController.java
client/java/ninja/trek/CameraMovementManager.java
client/java/ninja/trek/CameraMovementRegistry.java
client/java/ninja/trek/cameramovements/AbstractMovementSettings.java
client/java/ninja/trek/cameramovements/CameraMovementType.java
client/java/ninja/trek/cameramovements/CameraState.java
client/java/ninja/trek/cameramovements/CameraTarget.java
client/java/ninja/trek/cameramovements/ICameraMovement.java
client/java/ninja/trek/cameramovements/movements/BezierMovement.java
client/java/ninja/trek/cameramovements/movements/FreeCamReturnMovement.java
client/java/ninja/trek/cameramovements/movements/LinearMovement.java
client/java/ninja/trek/cameramovements/MovementState.java
client/java/ninja/trek/cameramovements/RaycastType.java
client/java/ninja/trek/cameramovements/RaycastUtil.java
client/java/ninja/trek/config/FreeCamSettings.java
client/java/ninja/trek/config/GeneralMenuSettings.java
client/java/ninja/trek/config/GeneralSettingsIO.java
client/java/ninja/trek/config/MenuOverlayScreen.java
client/java/ninja/trek/config/MovementSetting.java
client/java/ninja/trek/config/MovementSettingType.java
client/java/ninja/trek/config/RenameModal.java
client/java/ninja/trek/config/SettingSlider.java
client/java/ninja/trek/config/SettingWidget.java
client/java/ninja/trek/config/SlotMenuSettings.java
client/java/ninja/trek/config/SlotSettingsIO.java
client/java/ninja/trek/config/WrapSettings.java
client/java/ninja/trek/CraneshotClient.java
client/java/ninja/trek/CraneshotDataGenerator.java
client/java/ninja/trek/CraneShotEventHandler.java
client/java/ninja/trek/IKeyboardInputMixin.java
client/java/ninja/trek/IMouseMixin.java
client/java/ninja/trek/mixin/client/CameraAccessor.java
client/java/ninja/trek/mixin/client/CameraMixin.java
client/java/ninja/trek/mixin/client/CameraSubmersionMixin.java
client/java/ninja/trek/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/mixin/client/FovAccessor.java
client/java/ninja/trek/mixin/client/FrustumMixin.java
client/java/ninja/trek/mixin/client/GameRendererAccessor.java
client/java/ninja/trek/mixin/client/GameRendererMixin.java
client/java/ninja/trek/mixin/client/InputAccessor.java
client/java/ninja/trek/mixin/client/KeyboardInputMixin.java
client/java/ninja/trek/mixin/client/MinecraftClientCameraMixin.java
client/java/ninja/trek/mixin/client/MinecraftClientMixin.java
client/java/ninja/trek/mixin/client/MouseAccessor.java
client/java/ninja/trek/mixin/client/MouseMixin.java
client/java/ninja/trek/mixin/client/OrthographicGameRendererMixin.java
client/java/ninja/trek/mixin/client/WorldRendererChunkMixin.java
client/java/ninja/trek/mixin/client/WorldRendererMixin.java
client/java/ninja/trek/MouseInterceptor.java
client/java/ninja/trek/MovementToastRenderer.java
client/java/ninja/trek/OrthographicCameraManager.java
client/java/ninja/trek/util/CameraEntity.java
client/java/ninja/trek/util/CameraUtils.java
client/resources/craneshot.client.mixins.json
main/java/ninja/trek/Craneshot.java
main/java/ninja/trek/mixin/ExampleMixin.java
main/resources/assets/craneshot/lang/en_us.json
main/resources/craneshot.mixins.json
main/resources/fabric.mod.json
main/resources/orthocam.mixins.json

================================================================
Files
================================================================

================
File: client/java/ninja/trek/camera/CameraSystem.java
================
package ninja.trek.camera;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.Vec3d;
import ninja.trek.CameraController;
import ninja.trek.OrthographicCameraManager;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.mixin.client.CameraAccessor;
import org.jetbrains.annotations.Nullable;

/**
 * Central class that manages all camera behavior.
 * This class coordinates camera position, rotation, rendering, and collision.
 */
public class CameraSystem {
    private static CameraSystem instance;
    
    // Rendering threshold constant - if camera is closer than this, render arms; otherwise render body model
    public static final float PLAYER_RENDER_THRESHOLD = 1.0f;
    
    // Camera state
    private boolean cameraActive = false;
    private Vec3d cameraPosition = Vec3d.ZERO;
    private float cameraYaw = 0f;
    private float cameraPitch = 0f;
    private boolean shouldRenderHands = true;
    private boolean shouldRenderPlayerModel = true;
    private boolean disableChunkCulling = false;
    private Entity originalCameraEntity = null;
    private boolean originalChunkCulling = true;
    
    // Movement state
    private Vec3d cameraVelocity = Vec3d.ZERO;
    
    private CameraSystem() {
        // Private constructor for singleton
    }
    
    /**
     * Get the singleton instance of the camera system
     */
    public static CameraSystem getInstance() {
        if (instance == null) {
            instance = new CameraSystem();
        }
        return instance;
    }
    
    /**
     * Activates the custom camera for the given mode
     */
    public void activateCamera(CameraMode mode) {
        MinecraftClient mc = MinecraftClient.getInstance();
        if (mc.player == null || mc.world == null) return;
        
        ninja.trek.Craneshot.LOGGER.info("Activating camera in mode: {}", mode);
        
        // Get the current camera if available
        Camera currentCamera = mc.gameRenderer.getCamera();
        Vec3d currentCameraPos = null;
        float currentYaw = 0;
        float currentPitch = 0;
        
        // Capture current camera position if possible
        if (currentCamera != null) {
            currentCameraPos = currentCamera.getPos();
            currentYaw = currentCamera.getYaw();
            currentPitch = currentCamera.getPitch();
            ninja.trek.Craneshot.LOGGER.info("Current camera position: {} {} {}",
                currentCameraPos.getX(), currentCameraPos.getY(), currentCameraPos.getZ());
        }
        
        // Only activate if not already active
        if (!cameraActive) {
            // Store original state
            originalCameraEntity = mc.getCameraEntity();
            originalChunkCulling = mc.chunkCullingEnabled;
            
            ninja.trek.Craneshot.LOGGER.info("Original camera entity: {}", originalCameraEntity);
            
            // Initialize camera position and rotation from either current camera (if available)
            // or from the player position
            if (currentCameraPos != null) {
                // Use actual current camera position if available
                cameraPosition = currentCameraPos;
                cameraYaw = currentYaw;
                cameraPitch = currentPitch;
            } else if (originalCameraEntity != null) {
                // Fallback to entity position
                cameraPosition = originalCameraEntity.getEyePos();
                cameraYaw = originalCameraEntity.getYaw();
                cameraPitch = originalCameraEntity.getPitch();
            }
            
            ninja.trek.Craneshot.LOGGER.info("Initial camera position: {} {} {}", 
                cameraPosition.getX(), cameraPosition.getY(), cameraPosition.getZ());
            ninja.trek.Craneshot.LOGGER.info("Initial camera rotation: {} {}", cameraYaw, cameraPitch);
            
            // Set camera flags based on mode
            shouldRenderHands = !mode.hideHands;
            shouldRenderPlayerModel = mode.showPlayerModel;
            disableChunkCulling = mode.disableChunkCulling;
            
            // Apply chunk culling setting
            mc.chunkCullingEnabled = !disableChunkCulling;
            
            // Set the camera entity to null to detach from player
            ninja.trek.Craneshot.LOGGER.info("Setting camera entity to null");
            mc.setCameraEntity(null);
            
            cameraActive = true;
            
            // Explicitly apply position and rotation to ensure immediate update
            if (currentCamera != null) {
                ninja.trek.Craneshot.LOGGER.info("Initial camera update");
                ((CameraAccessor) currentCamera).invokesetPos(cameraPosition);
                ((CameraAccessor) currentCamera).invokeSetRotation(cameraYaw, cameraPitch);
            }
        } else {
            // Update settings if camera is already active
            ninja.trek.Craneshot.LOGGER.info("Camera already active, updating settings");
            shouldRenderHands = !mode.hideHands;
            shouldRenderPlayerModel = mode.showPlayerModel;
            
            if (disableChunkCulling != mode.disableChunkCulling) {
                disableChunkCulling = mode.disableChunkCulling;
                mc.chunkCullingEnabled = !disableChunkCulling;
            }
        }
    }
    
    /**
     * Deactivates the custom camera and restores original state
     */
    public void deactivateCamera() {
        if (!cameraActive) return;
        
        MinecraftClient mc = MinecraftClient.getInstance();
        
        ninja.trek.Craneshot.LOGGER.info("Deactivating camera system");
        
        // Restore original settings
        if (originalCameraEntity != null && mc != null) {
            ninja.trek.Craneshot.LOGGER.info("Restoring original camera entity");
            mc.setCameraEntity(originalCameraEntity);
        }
        
        if (mc != null) {
            mc.chunkCullingEnabled = originalChunkCulling;
        }
        
        // Reset camera state
        cameraActive = false;
        cameraVelocity = Vec3d.ZERO;
        
        ninja.trek.Craneshot.LOGGER.info("Final camera position: {} {} {}", 
            cameraPosition.getX(), cameraPosition.getY(), cameraPosition.getZ());
        ninja.trek.Craneshot.LOGGER.info("Final camera rotation: {} {}", cameraYaw, cameraPitch);
        
        // Mark chunks for rebuild to fix any rendering issues
        if (mc != null && mc.worldRenderer != null) {
            int chunkX = MathHelper.floor(cameraPosition.getX()) >> 4;
            int chunkZ = MathHelper.floor(cameraPosition.getZ()) >> 4;
            for (int x = chunkX - 3; x <= chunkX + 3; x++) {
                for (int z = chunkZ - 3; z <= chunkZ + 3; z++) {
                    for (int y = 0; y < 16; y++) {
                        mc.worldRenderer.scheduleChunkRender(x, y, z);
                    }
                }
            }
        }
        
        originalCameraEntity = null;
    }
    
    /**
     * Updates the camera position and rotation
     * @param camera The Minecraft camera instance
     */
    public void updateCamera(Camera camera) {
        if (!cameraActive || camera == null) return;
        
        MinecraftClient mc = MinecraftClient.getInstance();
        
        // Ensure we're not using player as camera entity
        if (mc.getCameraEntity() != null) {
            ninja.trek.Craneshot.LOGGER.debug("Resetting camera entity to null");
            mc.setCameraEntity(null);
        }
        
        // Get the current camera position for logging
        Vec3d currentPos = ((CameraAccessor) camera).getPos();
        float currentYaw = camera.getYaw();
        float currentPitch = camera.getPitch();
        
        // Log current and target positions
        ninja.trek.Craneshot.LOGGER.debug("Current camera pos: {} {} {}, target: {} {} {}",
            currentPos.getX(), currentPos.getY(), currentPos.getZ(),
            cameraPosition.getX(), cameraPosition.getY(), cameraPosition.getZ());
        
        // Apply position and rotation to the camera
        ((CameraAccessor) camera).invokesetPos(cameraPosition);
        ((CameraAccessor) camera).invokeSetRotation(cameraYaw, cameraPitch);
        
        // Verify that our changes actually took effect
        Vec3d actualPos = ((CameraAccessor) camera).getPos();
        if (!actualPos.equals(cameraPosition)) {
            ninja.trek.Craneshot.LOGGER.warn("Camera position not updated correctly! Expected: {} but got: {}", 
                cameraPosition, actualPos);
        }
    }
    
    /**
     * Handles keyboard movement input for the camera
     */
    public void handleMovementInput(float baseSpeed, float acceleration, float deceleration) {
        if (!cameraActive) return;
        
        MinecraftClient mc = MinecraftClient.getInstance();
        if (mc == null) return;
        
        // Calculate target velocity based on input
        Vec3d targetVelocity = calculateTargetVelocity(mc, baseSpeed);
        
        // Apply acceleration/deceleration
        if (targetVelocity.lengthSquared() > 0.0001) {
            // Accelerate toward target velocity
            cameraVelocity = cameraVelocity.add(
                targetVelocity.subtract(cameraVelocity).multiply(acceleration));
        } else {
            // Decelerate when no input
            cameraVelocity = cameraVelocity.multiply(1.0 - deceleration);
            // Zero out very small velocities to prevent drift
            if (cameraVelocity.lengthSquared() < 0.0001) {
                cameraVelocity = Vec3d.ZERO;
            }
        }
        
        // Apply velocity to position
        cameraPosition = cameraPosition.add(cameraVelocity);
        
        // Immediately update camera if available
        Camera camera = mc.gameRenderer.getCamera();
        if (camera != null) {
            updateCamera(camera);
        }
    }
    
    /**
     * Calculates the target velocity based on keyboard input
     */
    private Vec3d calculateTargetVelocity(MinecraftClient mc, float baseSpeed) {
        boolean isOrtho = OrthographicCameraManager.isOrthographicMode();
        boolean isFreeMode = CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE;
        
        double x = 0, y = 0, z = 0;
        
        // Get keyboard input
        if (mc.options.forwardKey.isPressed()) z += 1.0;
        if (mc.options.backKey.isPressed()) z -= 1.0;
        if (mc.options.leftKey.isPressed()) x += 1.0;
        if (mc.options.rightKey.isPressed()) x -= 1.0;
        if (mc.options.jumpKey.isPressed()) y += 1.0;
        if (mc.options.sneakKey.isPressed()) y -= 1.0;
        
        // Check if any movement keys are pressed
        if (x == 0 && y == 0 && z == 0) {
            return Vec3d.ZERO;
        }
        
        // Apply sprint multiplier
        if (mc.options.sprintKey.isPressed()) {
            baseSpeed *= 3.0f;
        }
        
        // Normalize if moving in multiple directions
        if ((x != 0 && z != 0) || (x != 0 && y != 0) || (z != 0 && y != 0)) {
            double length = Math.sqrt(x * x + y * y + z * z);
            x /= length;
            y /= length;
            z /= length;
        }
        
        Vec3d velocity;
        
        // For orthographic or flat movement mode, use camera-relative movement on XZ plane
        if (isOrtho || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT) {
            double xFactor = Math.sin(cameraYaw * Math.PI / 180.0);
            double zFactor = Math.cos(cameraYaw * Math.PI / 180.0);
            
            double moveX = (x * zFactor - z * xFactor);
            double moveZ = (z * zFactor + x * xFactor);
            
            velocity = new Vec3d(moveX, y, moveZ);
        }
        // For free movement, use full camera-relative movement
        else if (isFreeMode) {
            double xFactor = Math.sin(cameraYaw * Math.PI / 180.0);
            double zFactor = Math.cos(cameraYaw * Math.PI / 180.0);
            double pitchFactor = Math.sin(cameraPitch * Math.PI / 180.0);
            
            double moveX = (x * zFactor - z * xFactor);
            double moveY = y;
            double moveZ = (z * zFactor + x * xFactor);
            
            if (Math.abs(cameraPitch) > 30 && isFreeMode) {
                // Adjust vertical movement based on pitch in free mode
                moveY -= z * pitchFactor * 0.5;
            }
            
            velocity = new Vec3d(moveX, moveY, moveZ);
        }
        // Default to simple movement
        else {
            velocity = new Vec3d(x, y, z);
        }
        
        // Normalize and apply speed
        if (velocity.lengthSquared() > 0.0001) {
            return velocity.normalize().multiply(baseSpeed);
        }
        
        return Vec3d.ZERO;
    }
    
    /**
     * Updates the camera rotation based on mouse movement
     */
    public void updateRotation(double deltaX, double deltaY, double sensitivity) {
        if (!cameraActive) return;
        
        // Apply mouse movement to rotation
        cameraYaw += deltaX * sensitivity;
        // Normalize yaw to prevent floating-point issues after extended rotation
        while (cameraYaw > 360.0f) cameraYaw -= 360.0f;
        while (cameraYaw < 0.0f) cameraYaw += 360.0f;
        
        cameraPitch = (float) MathHelper.clamp(cameraPitch - deltaY * sensitivity, -90.0f, 90.0f);
        
        // Immediately update camera if available
        MinecraftClient mc = MinecraftClient.getInstance();
        if (mc != null) {
            Camera camera = mc.gameRenderer.getCamera();
            if (camera != null) {
                updateCamera(camera);
            }
        }
    }
    
    /**
     * Sets the camera position directly
     */
    public void setCameraPosition(Vec3d position) {
        if (position == null) {
            ninja.trek.Craneshot.LOGGER.warn("Attempted to set camera position to null!");
            return;
        }
        
        this.cameraPosition = position;
        
        // Log position for debugging
        ninja.trek.Craneshot.LOGGER.debug("CameraSystem.setCameraPosition: {} {} {}", 
            position.getX(), position.getY(), position.getZ());
        
        // Apply changes immediately if camera is active
        if (cameraActive) {
            MinecraftClient mc = MinecraftClient.getInstance();
            if (mc != null) {
                Camera camera = mc.gameRenderer.getCamera();
                if (camera != null) {
                    ((CameraAccessor) camera).invokesetPos(cameraPosition);
                }
            }
        }
    }
    
    /**
     * Sets the camera rotation directly
     */
    public void setCameraRotation(float yaw, float pitch) {
        this.cameraYaw = yaw;
        this.cameraPitch = pitch;
        
        // Log rotation for debugging
        ninja.trek.Craneshot.LOGGER.debug("CameraSystem.setCameraRotation: {} {}", yaw, pitch);
        
        // Apply changes immediately if camera is active
        if (cameraActive) {
            MinecraftClient mc = MinecraftClient.getInstance();
            if (mc != null) {
                Camera camera = mc.gameRenderer.getCamera();
                if (camera != null) {
                    ((CameraAccessor) camera).invokeSetRotation(cameraYaw, cameraPitch);
                }
            }
        }
    }
    
    /**
     * Get the current camera position
     */
    public Vec3d getCameraPosition() {
        return cameraPosition;
    }
    
    /**
     * Get the current camera yaw
     */
    public float getCameraYaw() {
        return cameraYaw;
    }
    
    /**
     * Get the current camera pitch
     */
    public float getCameraPitch() {
        return cameraPitch;
    }
    
    /**
     * Check if the camera is currently active
     */
    public boolean isCameraActive() {
        return cameraActive;
    }
    
    /**
     * Check if hands should be rendered
     * Takes into account both the camera mode setting and distance threshold
     */
    public boolean shouldRenderHands() {
        if (!shouldRenderHands) return false;
        
        // Check camera distance to player
        MinecraftClient mc = MinecraftClient.getInstance();
        if (mc.player != null && cameraActive) {
            double distanceToPlayer = cameraPosition.distanceTo(mc.player.getEyePos());
            // Render hands only when closer than the threshold
            return distanceToPlayer < PLAYER_RENDER_THRESHOLD;
        }
        
        return shouldRenderHands;
    }
    
    /**
     * Check if player model should be rendered
     * Takes into account both the camera mode setting and distance threshold
     */
    public boolean shouldRenderPlayerModel() {
        if (!shouldRenderPlayerModel) return false;
        
        // Check camera distance to player
        MinecraftClient mc = MinecraftClient.getInstance();
        if (mc.player != null && cameraActive) {
            double distanceToPlayer = cameraPosition.distanceTo(mc.player.getEyePos());
            // Render player model only when farther than the threshold
            return distanceToPlayer >= PLAYER_RENDER_THRESHOLD;
        }
        
        return shouldRenderPlayerModel;
    }
    
    /**
     * Set whether to render hands
     */
    public void setShouldRenderHands(boolean renderHands) {
        this.shouldRenderHands = renderHands;
    }
    
    /**
     * Camera mode defines how the camera should behave
     */
    public static class CameraMode {
        public final boolean hideHands;
        public final boolean showPlayerModel;
        public final boolean disableChunkCulling;
        
        public CameraMode(boolean hideHands, boolean showPlayerModel, boolean disableChunkCulling) {
            this.hideHands = hideHands;
            this.showPlayerModel = showPlayerModel;
            this.disableChunkCulling = disableChunkCulling;
        }
        
        // Predefined camera modes
        public static final CameraMode ORTHOGRAPHIC = new CameraMode(
            true,     // Hide hands
            true,     // Show player model
            true      // Disable chunk culling
        );
        
        public static final CameraMode THIRD_PERSON = new CameraMode(
            true,     // Hide hands
            true,     // Show player model
            true      // Disable chunk culling
        );
        
        public static final CameraMode FREE_CAMERA = new CameraMode(
            true,     // Hide hands
            false,    // Don't show player model
            true      // Disable chunk culling
        );
        
        public static final CameraMode FIRST_PERSON = new CameraMode(
            false,    // Show hands
            false,    // Don't show player model
            false     // Normal chunk culling
        );
    }
}

================
File: client/java/ninja/trek/CameraController.java
================
package ninja.trek;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.client.option.Perspective;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.BlockView;
import ninja.trek.camera.CameraSystem;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.cameramovements.AbstractMovementSettings.POST_MOVE_KEYS;
import ninja.trek.cameramovements.AbstractMovementSettings.POST_MOVE_MOUSE;
import ninja.trek.cameramovements.CameraTarget;
import ninja.trek.config.FreeCamSettings;
import ninja.trek.config.GeneralMenuSettings;
import ninja.trek.mixin.client.CameraAccessor;
import ninja.trek.mixin.client.FovAccessor;

public class CameraController {
    public static POST_MOVE_KEYS currentKeyMoveMode = POST_MOVE_KEYS.NONE;
    public static POST_MOVE_MOUSE currentMouseMoveMode = POST_MOVE_MOUSE.NONE;
    public static Vec3d freeCamPosition = Vec3d.ZERO;
    public static float freeCamYaw = 0f;
    public static float freeCamPitch = 0f;
    public static CameraTarget controlStick = new CameraTarget();

    private String currentMessage = "";
    private long messageTimer = 0;
    private static final long MESSAGE_DURATION = 2000;
    public static final double FIRST_PERSON_THRESHOLD_MIN = 2.0;
    public static final double FIRST_PERSON_THRESHOLD_MAX = 5.0;

    public static AbstractMovementSettings.END_TARGET currentEndTarget = AbstractMovementSettings.END_TARGET.HEAD_BACK;
    private Vec3d lastPlayerPos = Vec3d.ZERO;
    private Vec3d cumulativeMovement = Vec3d.ZERO;
    private float targetYaw = 0f;
    private static final double FULL_ROTATE_DISTANCE = 2.0; // Blocks to move for full rotation

    private Vec3d currentVelocity = Vec3d.ZERO;

    private void updateControlStick(MinecraftClient client) {
        if (currentKeyMoveMode != POST_MOVE_KEYS.MOVE_CAMERA_FLAT &&
                currentKeyMoveMode != POST_MOVE_KEYS.MOVE_CAMERA_FREE) {

            if (client.player == null) return;
            Camera camera = client.gameRenderer.getCamera();
            if (camera != null) {
                Vec3d eyePos = client.player.getEyePos();
                float yaw = client.player.getYaw();
                float pitch = client.player.getPitch();

                // Update movement tracking for VELOCITY targets
                if (currentEndTarget == AbstractMovementSettings.END_TARGET.VELOCITY_BACK ||
                        currentEndTarget == AbstractMovementSettings.END_TARGET.VELOCITY_FRONT) {
                    updateMovementTracking(client.player.getPos());
                }

                // Calculate final angles based on target type
                float finalYaw = calculateTargetYaw(yaw);
                float finalPitch = calculateTargetPitch(pitch);

                controlStick.set(eyePos, finalYaw, finalPitch);
            }
        }
    }

    private float calculateTargetYaw(float playerYaw) {
        switch (currentEndTarget) {
            case HEAD_BACK:
                return playerYaw;
            case HEAD_FRONT:
                return (playerYaw + 180);
            case VELOCITY_BACK:
                return 360-targetYaw;
            case VELOCITY_FRONT:
                return (360-targetYaw + 180)%360;
            case FIXED_BACK:
                return playerYaw;
            case FIXED_FRONT:
                return (playerYaw + 180);
            default:
                return playerYaw;
        }
    }

    private float calculateTargetPitch(float playerPitch) {
        switch (currentEndTarget) {
            case HEAD_FRONT:
                return -playerPitch;
            case HEAD_BACK:
                return playerPitch;
            case VELOCITY_FRONT:
            case FIXED_FRONT:
                return 45f;  // Looking down at player
            case VELOCITY_BACK:
            case FIXED_BACK:
                return 45f; // Looking up from behind
            default:
                return playerPitch;
        }
    }

    private void updateMovementTracking(Vec3d currentPos) {
        if (lastPlayerPos.equals(Vec3d.ZERO)) {
            lastPlayerPos = currentPos;
            return;
        }

        // Calculate movement in XZ plane
        Vec3d movement = new Vec3d(
                currentPos.x - lastPlayerPos.x,
                0,
                currentPos.z - lastPlayerPos.z
        );

        if (movement.lengthSquared() > 0.001) { // Only update if there's significant movement
            cumulativeMovement = cumulativeMovement.add(movement);

            // Calculate movement direction (Minecraft coordinates)
            double movementYaw = Math.toDegrees(Math.atan2(movement.x, movement.z));
            while (movementYaw < 0) movementYaw += 360;

            // Linear interpolation based on cumulative movement distance
            double moveDistance = cumulativeMovement.length();
            double progress = Math.min(moveDistance / FULL_ROTATE_DISTANCE, 1.0);

            // Update target yaw
            targetYaw = (float)movementYaw;

            // Reset cumulative movement if we've reached full rotation
            if (moveDistance >= FULL_ROTATE_DISTANCE) {
                cumulativeMovement = Vec3d.ZERO;
            }
        }

        lastPlayerPos = currentPos;
    }

    public void setPreMoveStates(AbstractMovementSettings m){
        currentEndTarget = m.getEndTarget();
        // Reset any FOV modifications when starting a new movement
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.gameRenderer instanceof FovAccessor) {
            ((FovAccessor) client.gameRenderer).setFovModifier(1.0f);
        }
    }

    public void setPostMoveStates(AbstractMovementSettings m) {
        if (m == null) {
            // Reset state when movement ends
            currentKeyMoveMode = POST_MOVE_KEYS.NONE;
            currentMouseMoveMode = POST_MOVE_MOUSE.NONE;
            MouseInterceptor.setIntercepting(false);
            
            // Reset tracking variables
            lastPlayerPos = Vec3d.ZERO;
            cumulativeMovement = Vec3d.ZERO;
            
            // Reset keyboard input handling
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.player != null && client.player.input instanceof IKeyboardInputMixin) {
                ((IKeyboardInputMixin) client.player.input).setDisabled(false);
            }
            
            // Disable camera system
            CameraSystem.getInstance().deactivateCamera();
        } else {
            // Set new movement modes
            currentMouseMoveMode = m.getPostMoveMouse();
            currentKeyMoveMode = m.getPostMoveKeys();

            MinecraftClient client = MinecraftClient.getInstance();
            Camera camera = client.gameRenderer.getCamera();
            
            // This is where the position must be preserved
            // freeCamPosition, freeCamYaw, and freeCamPitch should already be set by CameraMovementManager
            // before this method is called, so we don't need to capture them again here
            
            // Handle input disabling
            if (client.player != null && client.player.input instanceof IKeyboardInputMixin) {
                boolean shouldDisable = (currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
                        currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FREE);
                ((IKeyboardInputMixin) client.player.input).setDisabled(shouldDisable);
            }

            // Enable mouse interception for camera rotation
            if (currentMouseMoveMode == POST_MOVE_MOUSE.ROTATE_CAMERA) {
                MouseInterceptor.setIntercepting(true);
            }
            
            // Determine if we should activate custom camera mode
            boolean isFreeCamMode = (currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
                                    currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FREE ||
                                    currentMouseMoveMode == POST_MOVE_MOUSE.ROTATE_CAMERA);
            
            boolean isOutPosition = (currentEndTarget == AbstractMovementSettings.END_TARGET.HEAD_BACK ||
                                    currentEndTarget == AbstractMovementSettings.END_TARGET.FIXED_BACK ||
                                    currentEndTarget == AbstractMovementSettings.END_TARGET.VELOCITY_BACK);
            
            // Capture existing camera position before activating any new camera mode
            Vec3d existingCameraPos = camera.getPos();
            float existingYaw = camera.getYaw();
            float existingPitch = camera.getPitch();
            
            // Activate the appropriate camera mode
            CameraSystem cameraSystem = CameraSystem.getInstance();
            if (isFreeCamMode) {
                // Set the position first, so it's available during activation
                cameraSystem.setCameraPosition(freeCamPosition);
                cameraSystem.setCameraRotation(freeCamYaw, freeCamPitch);
                
                // Then activate the camera
                cameraSystem.activateCamera(CameraSystem.CameraMode.FREE_CAMERA);
                
                // Update the camera immediately to apply our position
                cameraSystem.updateCamera(camera);
                
                // Add debug logging
                ninja.trek.Craneshot.LOGGER.info("Activating free camera at position: {} {} {}", 
                    freeCamPosition.getX(), freeCamPosition.getY(), freeCamPosition.getZ());
            } else if (isOutPosition) {
                cameraSystem.activateCamera(CameraSystem.CameraMode.THIRD_PERSON);
            }
        }
    }

    private void handleKeyboardMovement(MinecraftClient client, Camera camera) {
        if (client.player == null) return;

        // Let the camera system handle movement
        CameraSystem cameraSystem = CameraSystem.getInstance();
        if (cameraSystem.isCameraActive()) {
            FreeCamSettings settings = GeneralMenuSettings.getFreeCamSettings();
            cameraSystem.handleMovementInput(
                settings.getMoveSpeed(),
                settings.getAcceleration(),
                settings.getDeceleration()
            );
            return;
        }

        // Legacy movement code
        // Base movement speed in blocks per tick
        float baseSpeed = GeneralMenuSettings.getFreeCamSettings().getMoveSpeed();

        // Sprint multiplier
        if (client.options.sprintKey.isPressed()) {
            baseSpeed *= 3.0f;
        }

        Vec3d targetVelocity = Vec3d.ZERO;
        
        // Calculate movement direction
        if (currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            // Free camera movement in all directions
            double x = 0, y = 0, z = 0;
            
            if (client.options.forwardKey.isPressed()) {
                z += 1.0;
            }
            if (client.options.backKey.isPressed()) {
                z -= 1.0;
            }
            if (client.options.leftKey.isPressed()) {
                x += 1.0;
            }
            if (client.options.rightKey.isPressed()) {
                x -= 1.0;
            }
            if (client.options.jumpKey.isPressed()) {
                y += 1.0;
            }
            if (client.options.sneakKey.isPressed()) {
                y -= 1.0;
            }
            
            // Normalize if moving in multiple directions simultaneously
            if ((x != 0 && z != 0) || (x != 0 && y != 0) || (z != 0 && y != 0)) {
                double length = Math.sqrt(x * x + y * y + z * z);
                x /= length;
                y /= length;
                z /= length;
            }
            
            // Convert to camera-relative movement
            float yaw = freeCamYaw;
            float pitch = freeCamPitch;
            double xFactor = Math.sin(yaw * Math.PI / 180.0);
            double zFactor = Math.cos(yaw * Math.PI / 180.0);
            
            targetVelocity = new Vec3d(
                (x * zFactor - z * xFactor), 
                y, 
                (z * zFactor + x * xFactor)
            );
            
        } else if (currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FLAT) {
            // Y-axis locked camera movement
            double x = 0, z = 0;
            
            if (client.options.forwardKey.isPressed()) {
                z += 1.0;
            }
            if (client.options.backKey.isPressed()) {
                z -= 1.0;
            }
            if (client.options.leftKey.isPressed()) {
                x += 1.0;
            }
            if (client.options.rightKey.isPressed()) {
                x -= 1.0;
            }
            
            // Y movement from jump/sneak
            double y = 0;
            if (client.options.jumpKey.isPressed()) {
                y += 1.0;
            }
            if (client.options.sneakKey.isPressed()) {
                y -= 1.0;
            }
            
            // Normalize XZ movement
            if (x != 0 && z != 0) {
                double length = Math.sqrt(x * x + z * z);
                x /= length;
                z /= length;
            }
            
            // Convert to camera-relative XZ movement with free Y
            float yaw = freeCamYaw;
            double xFactor = Math.sin(yaw * Math.PI / 180.0);
            double zFactor = Math.cos(yaw * Math.PI / 180.0);
            
            targetVelocity = new Vec3d(
                (x * zFactor - z * xFactor), 
                y, 
                (z * zFactor + x * xFactor)
            );
        }

        // Normalize and apply speed to target velocity if there's any movement
        if (targetVelocity.lengthSquared() > 0.0001) {
            targetVelocity = targetVelocity.normalize().multiply(baseSpeed);
        }

        // Apply acceleration or deceleration
        float acceleration = GeneralMenuSettings.getFreeCamSettings().getAcceleration();
        float deceleration = GeneralMenuSettings.getFreeCamSettings().getDeceleration();

        if (targetVelocity.lengthSquared() > 0.0001) {
            // Accelerating
            currentVelocity = currentVelocity.add(
                    targetVelocity.subtract(currentVelocity).multiply(acceleration)
            );
        } else {
            // Decelerating
            currentVelocity = currentVelocity.multiply(1.0 - deceleration);
            // Zero out very small velocities to prevent perpetual drift
            if (currentVelocity.lengthSquared() < 0.0001) {
                currentVelocity = Vec3d.ZERO;
            }
        }

        // Apply movement
        freeCamPosition = freeCamPosition.add(currentVelocity);
        ((CameraAccessor) camera).invokesetPos(freeCamPosition);
    }

    public void updateCamera(MinecraftClient client, Camera camera, float delta) {
        updateControlStick(client);

        // Get the base camera state from movement manager - always update to track state
        CameraTarget baseTarget = CraneshotClient.MOVEMENT_MANAGER.update(client, camera);

        if (baseTarget != null) {
            // Update FOV in game renderer
            if (client.gameRenderer instanceof FovAccessor) {
                float fovMultiplier = (float) baseTarget.getFovMultiplier();
                ((FovAccessor) client.gameRenderer).setFovModifier(fovMultiplier);
                // Only log significant FOV changes to reduce console spam
                if (Math.abs(fovMultiplier - 1.0) > 0.001) {
                    Craneshot.LOGGER.debug("set fov {}", fovMultiplier);
                }
            }
            
            // Check if camera system is active
            CameraSystem cameraSystem = CameraSystem.getInstance();
            
            if (cameraSystem.isCameraActive()) {
                // Let the camera system update its state
                if (currentMouseMoveMode == POST_MOVE_MOUSE.ROTATE_CAMERA && client.mouse instanceof IMouseMixin) {
                    IMouseMixin mouseMixin = (IMouseMixin) client.mouse;
                    double deltaX = mouseMixin.getCapturedDeltaX();
                    double deltaY = -mouseMixin.getCapturedDeltaY();
                    
                    if (deltaX != 0 || deltaY != 0) {
                        double mouseSensitivity = client.options.getMouseSensitivity().getValue();
                        double calculatedSensitivity = 0.6 * mouseSensitivity * mouseSensitivity * mouseSensitivity + 0.2;
                        cameraSystem.updateRotation(
                            deltaX * calculatedSensitivity * 0.55D,
                            deltaY * calculatedSensitivity * 0.55D,
                            1.0
                        );
                    }
                } else {
                    // Use the movement manager's position/rotation if not freely rotating
                    cameraSystem.setCameraPosition(baseTarget.getPosition());
                    cameraSystem.setCameraRotation(baseTarget.getYaw(), baseTarget.getPitch());
                }
                
                // Update our tracking variables for legacy code support
                freeCamPosition = cameraSystem.getCameraPosition();
                freeCamYaw = cameraSystem.getCameraYaw();
                freeCamPitch = cameraSystem.getCameraPitch();
                
                // Let the camera system update the camera
                cameraSystem.updateCamera(camera);
            } else {
                // Legacy camera handling
                // Only update freeCamPosition from movement if we're not in free movement mode
                if (currentKeyMoveMode != POST_MOVE_KEYS.MOVE_CAMERA_FLAT &&
                        currentKeyMoveMode != POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
                    freeCamPosition = baseTarget.getPosition();
                }

                // Handle rotation based on movement mode
                if (currentMouseMoveMode == POST_MOVE_MOUSE.ROTATE_CAMERA && client.mouse instanceof IMouseMixin) {
                    IMouseMixin mouseMixin = (IMouseMixin) client.mouse;
                    double deltaX = mouseMixin.getCapturedDeltaX();
                    double deltaY = -mouseMixin.getCapturedDeltaY();
                    double mouseSensitivity = client.options.getMouseSensitivity().getValue();
                    double calculatedSensitivity = 0.6 * mouseSensitivity * mouseSensitivity * mouseSensitivity + 0.2;
                    deltaX *= calculatedSensitivity * 0.55D;
                    deltaY *= calculatedSensitivity * 0.55D;
                    if (deltaX != 0 || deltaY != 0) {
                        freeCamYaw += deltaX;
                        freeCamPitch = (float) Math.max(-90.0F, Math.min(90.0F, freeCamPitch - deltaY));
                    }
                } else {
                    freeCamYaw = baseTarget.getYaw();
                    freeCamPitch = baseTarget.getPitch();
                }
                
                // Apply the camera position and rotation
                ((CameraAccessor) camera).invokesetPos(freeCamPosition);
                ((CameraAccessor) camera).invokeSetRotation(freeCamYaw, freeCamPitch);
            }
        }

        // Handle keyboard movement for camera modes
        if (currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
                currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            handleKeyboardMovement(client, camera);
        }

        updatePerspective(client, camera);
        updateMessageTimer();
    }

    /**
     * Previously updated the camera perspective based on the distance.
     * Now this method is no longer needed as CameraSystem handles rendering decisions.
     * Kept as a stub for backwards compatibility.
     */
    private void updatePerspective(MinecraftClient client, Camera camera) {
        // In orthographic mode, we still need to ensure third person mode
        if (client.player == null) return;
        
        // In orthographic mode, we always want to be in third person
        if (OrthographicCameraManager.isOrthographicMode() && 
            client.options.getPerspective() == Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.THIRD_PERSON_BACK);
        }
        
        // No other perspective changes needed - CameraSystem now handles arm/body rendering
    }

    //=== Message Handling ========================================================

    public void showMessage(String message) {
        currentMessage = message;
        messageTimer = System.currentTimeMillis() + MESSAGE_DURATION;
    }

    public String getCurrentMessage() {
        return currentMessage;
    }

    public boolean hasActiveMessage() {
        return System.currentTimeMillis() < messageTimer;
    }

    private void updateMessageTimer() {
        if (System.currentTimeMillis() >= messageTimer) {
            currentMessage = "";
        }
    }

    /**
     * Updates the camera each frame. This method (which used to be called handleCameraUpdate)
     * is responsible for applying the computed camera state (from the movement manager) as well as
     * processing any free keyboard/mouse input. It should be placed in CameraController.
     */
    public void handleCameraUpdate(BlockView area, Entity focusedEntity, boolean thirdPerson,
                                   boolean inverseView, float tickDelta, Camera camera) {
        // Verify that both the camera and the focused entity exist.
        if (camera == null || focusedEntity == null) return;

        MinecraftClient client = MinecraftClient.getInstance();
        if (client == null || client.world == null) return;

        // Update the camera based on movement-manager and free control states.
        updateCamera(client, camera, tickDelta);

        // Optionally update keyboard input (e.g. disable it when free control is active)
        updateKeyboardInput(client);
    }

    private void updateKeyboardInput(MinecraftClient client) {
        if (client.player != null && client.player.input instanceof IKeyboardInputMixin) {
            // Check if camera system is active and should disable player movement
            CameraSystem cameraSystem = CameraSystem.getInstance();
            if (cameraSystem.isCameraActive()) {
                ((IKeyboardInputMixin) client.player.input).setDisabled(true);
                return;
            }
            
            // Legacy keyboard input control
            boolean shouldDisable = currentKeyMoveMode == POST_MOVE_KEYS.MOVE8 ||
                                   currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
                                   currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FREE;
            ((IKeyboardInputMixin) client.player.input).setDisabled(shouldDisable);
        }
    }

    public void onComplete() {
        // Only reset mouse/key modes if they're not actively being used in post-move mode
        // This preserves post-movement settings when a camera movement completes
        if (currentMouseMoveMode != POST_MOVE_MOUSE.ROTATE_CAMERA) {
            currentMouseMoveMode = POST_MOVE_MOUSE.NONE;
        }
        
        if (currentKeyMoveMode != POST_MOVE_KEYS.MOVE_CAMERA_FLAT && 
            currentKeyMoveMode != POST_MOVE_KEYS.MOVE_CAMERA_FREE && 
            currentKeyMoveMode != POST_MOVE_KEYS.MOVE8) {
            currentKeyMoveMode = POST_MOVE_KEYS.NONE;
        }
        
        // Keep camera system active if we're using post-movement controls
        boolean hasPostMoveControls = 
            currentMouseMoveMode != POST_MOVE_MOUSE.NONE || 
            currentKeyMoveMode != POST_MOVE_KEYS.NONE;
            
        if (!hasPostMoveControls) {
            // Deactivate camera system only if not using post-movement controls
            CameraSystem.getInstance().deactivateCamera();
        }
    }
}

================
File: client/java/ninja/trek/CameraMovementManager.java
================
package ninja.trek;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import ninja.trek.cameramovements.CameraTarget;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.cameramovements.MovementState;
import ninja.trek.cameramovements.movements.FreeCamReturnMovement;
import ninja.trek.config.GeneralMenuSettings;
import ninja.trek.config.SlotMenuSettings;
import ninja.trek.mixin.client.CameraAccessor;

import java.util.*;

public class CameraMovementManager {
    private List<List<ICameraMovement>> slots;
    private List<Integer> currentTypes;
    private Integer activeMovementSlot;
    private Map<Integer, Boolean> toggledStates;
    private ICameraMovement activeMovement;
    private CameraTarget baseTarget;
    private boolean isOut;
    
    // For handling free camera return
    private boolean inFreeCamReturnPhase = false;

    // New fields for managing scroll selection
    private Map<Integer, Integer> scrollSelectedTypes;
    private Map<Integer, Boolean> hasScrolledDuringPress;
    private Map<Integer, Long> keyPressStartTimes;

    public CameraMovementManager() {
        int numSlots = 3;
        slots = new ArrayList<>();
        currentTypes = new ArrayList<>();
        toggledStates = new HashMap<>();
        scrollSelectedTypes = new HashMap<>();
        hasScrolledDuringPress = new HashMap<>();
        keyPressStartTimes = new HashMap<>();

        for (int i = 0; i < numSlots; i++) {
            slots.add(new ArrayList<>());
            currentTypes.add(0);
            scrollSelectedTypes.put(i, 0);
        }

        activeMovementSlot = null;
        activeMovement = null;
        baseTarget = null;
    }

    public void setAllSlots(List<List<ICameraMovement>> savedSlots) {
        this.slots = savedSlots;
        currentTypes = new ArrayList<>();
        for (int i = 0; i < slots.size(); i++) {
            currentTypes.add(0);
            scrollSelectedTypes.put(i, 0);
        }
    }

    public void addMovement(int slotIndex, ICameraMovement movement) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            slots.get(slotIndex).add(movement);
        }
    }

    public void removeMovement(int slotIndex, int movementIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (movementIndex >= 0 && movementIndex < slotMovements.size() && slotMovements.size() > 1) {
                slotMovements.remove(movementIndex);
                if (currentTypes.get(slotIndex) >= slotMovements.size()) {
                    currentTypes.set(slotIndex, slotMovements.size() - 1);
                }
            }
        }
    }

    public void swapMovements(int slotIndex, int index1, int index2) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (index1 >= 0 && index1 < slotMovements.size() &&
                    index2 >= 0 && index2 < slotMovements.size()) {
                Collections.swap(slotMovements, index1, index2);
            }
        }
    }

    public int getMovementCount() {
        return slots.size();
    }

    public List<ICameraMovement> getAvailableMovementsForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            return new ArrayList<>(slots.get(slotIndex));
        }
        return new ArrayList<>();
    }

    public ICameraMovement getMovementAt(int index) {
        if (index >= 0 && index < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(index);
            int currentType = currentTypes.get(index);
            if (!slotMovements.isEmpty() && currentType < slotMovements.size()) {
                return slotMovements.get(currentType);
            }
        }
        return null;
    }

    public void handleMouseScroll(int slotIndex, boolean scrollUp) {

        if (slotIndex < 0 || slotIndex >= slots.size()) return;
        Craneshot.LOGGER.info("scroll up:{}", scrollUp);

        List<ICameraMovement> slotMovements = slots.get(slotIndex);
        if (slotMovements.isEmpty()) return;

        boolean wrap = SlotMenuSettings.getWrapState(slotIndex);
        int currentType = currentTypes.get(slotIndex);

        // Calculate new movement type index
        int newType;
        if (scrollUp) {
            newType = wrap ?
                    (currentType + 1) % slotMovements.size() :
                    Math.min(currentType + 1, slotMovements.size() - 1);
        } else {
            newType = wrap ?
                    (currentType - 1 + slotMovements.size()) % slotMovements.size() :
                    Math.max(currentType - 1, 0);
        }

        // Update current type immediately
        currentTypes.set(slotIndex, newType);
        scrollSelectedTypes.put(slotIndex, newType);
        hasScrolledDuringPress.put(slotIndex, true);
        // Show movement name and toast
        ICameraMovement selectedMovement = slotMovements.get(newType);
        if (selectedMovement != null) {
            CraneshotClient.CAMERA_CONTROLLER.showMessage(
                    "Camera " + (slotIndex + 1) + ": " + selectedMovement.getName()
            );
            MovementToastRenderer.showToast(slotIndex);
        }
    }

    private boolean isSlotKeyPressed(int slotIndex) {
        return keyPressStartTimes.containsKey(slotIndex);
    }

    public void startTransition(MinecraftClient client, Camera camera, int slotIndex) {
        ICameraMovement movement = getMovementAt(slotIndex);
        if (movement == null) return;

        if (activeMovementSlot != null && activeMovementSlot.equals(slotIndex)) {
            finishTransition(client, camera);
            return;
        }

        isOut = false;
        if (activeMovementSlot != null && !activeMovementSlot.equals(slotIndex)) {
            toggledStates.put(activeMovementSlot, false);
            finishTransition(client, camera);
        }

        activeMovementSlot = slotIndex;
        activeMovement = movement;
        CraneshotClient.CAMERA_CONTROLLER.setPostMoveStates(null);
        movement.start(client, camera);
        CraneshotClient.CAMERA_CONTROLLER.setPreMoveStates((AbstractMovementSettings) movement);

        // Show the toast when starting a new movement
        MovementToastRenderer.showToast(slotIndex);
    }

    public void finishTransition(MinecraftClient client, Camera camera) {
        if (activeMovement != null) {
            // Check if we're in free camera mode before initiating return
            boolean inFreeCameraMode = 
                CraneshotClient.CAMERA_CONTROLLER.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
                CraneshotClient.CAMERA_CONTROLLER.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE ||
                CraneshotClient.CAMERA_CONTROLLER.currentMouseMoveMode == AbstractMovementSettings.POST_MOVE_MOUSE.ROTATE_CAMERA;

            if (inFreeCameraMode) {
                ninja.trek.Craneshot.LOGGER.info("Starting FreeCamReturnMovement to handle return from free camera");
                
                // Store the original active movement to return to after FreeCamReturnMovement completes
                ICameraMovement originalMovement = activeMovement;
                Integer originalSlot = activeMovementSlot;
                
                // Clear post-move settings to disable free camera mode
                CraneshotClient.CAMERA_CONTROLLER.setPostMoveStates(null);
                
                // Start the FreeCamReturnMovement to handle the transition back to normal camera
                FreeCamReturnMovement freeCamReturnMovement = GeneralMenuSettings.getFreeCamReturnMovement();
                
                // Set the FreeCamReturnMovement's endTarget to match the original movement
                if (originalMovement instanceof AbstractMovementSettings) {
                    AbstractMovementSettings originalSettings = (AbstractMovementSettings) originalMovement;
                    freeCamReturnMovement.endTarget = originalSettings.getEndTarget();
                }
                
                freeCamReturnMovement.start(client, camera);
                
                // Set the FreeCamReturnMovement as the active movement
                activeMovement = freeCamReturnMovement;
                inFreeCamReturnPhase = true;
                
                // We'll keep track of the original movement to queue its reset after FreeCamReturnMovement completes
                return;
            }
            
            // Normal case - queue reset directly
            // This will trigger return to the player's head position and rotation
            activeMovement.queueReset(client, camera);
        }
    }

    public void handleKeyStateChange(int keyIndex, boolean pressed, MinecraftClient client, Camera camera, boolean isToggleMode) {
        if (pressed) {
            // Key press logic
            keyPressStartTimes.put(keyIndex, System.currentTimeMillis());
            hasScrolledDuringPress.put(keyIndex, false);

            // Initialize scroll selection to current type
            scrollSelectedTypes.put(keyIndex, currentTypes.get(keyIndex));

            // Show current movement name
            List<ICameraMovement> movements = slots.get(keyIndex);
            if (!movements.isEmpty()) {
                ICameraMovement movement = movements.get(scrollSelectedTypes.get(keyIndex));
                CraneshotClient.CAMERA_CONTROLLER.showMessage(
                        "Camera " + (keyIndex + 1) + ": " + movement.getName()
                );
            }
        } else {
            // Key release logic
            if (keyPressStartTimes.containsKey(keyIndex)) {
                keyPressStartTimes.remove(keyIndex);

                if (activeMovementSlot != null && !activeMovementSlot.equals(keyIndex)) {
                    toggledStates.put(activeMovementSlot, false);
                    finishTransition(client, camera);
                }

                if (!isToggleMode || (isToggleMode && !toggledStates.getOrDefault(keyIndex, false))) {
                    // Determine which movement to use
                    int selectedType = scrollSelectedTypes.get(keyIndex);
                    boolean hasScrolled = hasScrolledDuringPress.getOrDefault(keyIndex, false);

                    if (!hasScrolled && GeneralMenuSettings.isAutoAdvance()) {
                        // Auto advance to next movement if no scrolling occurred
                        List<ICameraMovement> movements = slots.get(keyIndex);
                        selectedType = (currentTypes.get(keyIndex) + 1) % movements.size();
                    }

                    // Update current type and start transition
                    currentTypes.set(keyIndex, selectedType);
                    startTransition(client, camera, keyIndex);

                    if (isToggleMode) {
                        toggledStates.put(keyIndex, true);
                    }
                } else if (isToggleMode && toggledStates.getOrDefault(keyIndex, false)) {
                    toggledStates.put(keyIndex, false);
                    finishTransition(client, camera);
                }

                // Clear scroll state
                hasScrolledDuringPress.remove(keyIndex);
            }
        }
    }

    public MovementState calculateState(MinecraftClient client, Camera camera) {
        if (activeMovement == null || client.player == null) {
            return null;
        }
        
        // Check if we're in FreeCamReturn phase
        if (inFreeCamReturnPhase) {
            FreeCamReturnMovement freeCamReturnMovement = GeneralMenuSettings.getFreeCamReturnMovement();
            if (activeMovement == freeCamReturnMovement) {
                MovementState state = freeCamReturnMovement.calculateState(client, camera);
                baseTarget = state.getCameraTarget().withAdjustedPosition(client.player, activeMovement.getRaycastType());
                
                // Check if FreeCamReturnMovement has completed
                if (state.isComplete() || freeCamReturnMovement.isComplete()) {
                    ninja.trek.Craneshot.LOGGER.info("FreeCamReturnMovement completed, returning to normal camera");
                    
                    // Reset the FreeCamReturnMovement phase
                    inFreeCamReturnPhase = false;
                    
                    // Switch back to normal camera movement - normal state
                    activeMovementSlot = null;
                    activeMovement = null;
                    isOut = false;
                    
                    // Reset state in the controller
                    CraneshotClient.CAMERA_CONTROLLER.onComplete();
                    CraneshotClient.CAMERA_CONTROLLER.setPostMoveStates(null);
                    
                    return null;
                }
                
                return state;
            }
        }
        
        // Normal movement state calculation
        MovementState state = activeMovement.calculateState(client, camera);
        if (!isOut) {
            isOut = activeMovement.hasCompletedOutPhase();
            if (isOut) {
                // CRITICAL FIX: Get the exact current target position from the movement
                CameraTarget currentTarget = state.getCameraTarget();
                
                // Apply raycast adjustment for collision
                currentTarget = currentTarget.withAdjustedPosition(client.player, activeMovement.getRaycastType());
                
                // Set the base target for reference
                baseTarget = currentTarget;
                
                // Store the exact position in static controller variables
                CraneshotClient.CAMERA_CONTROLLER.freeCamPosition = currentTarget.getPosition();
                CraneshotClient.CAMERA_CONTROLLER.freeCamYaw = currentTarget.getYaw();
                CraneshotClient.CAMERA_CONTROLLER.freeCamPitch = currentTarget.getPitch();
                
                // Set the camera directly to this position before applying post-move settings
                if (camera != null) {
                    ((CameraAccessor) camera).invokesetPos(currentTarget.getPosition());
                    ((CameraAccessor) camera).invokeSetRotation(currentTarget.getYaw(), currentTarget.getPitch());
                    
                    // Log position for debugging
                    ninja.trek.Craneshot.LOGGER.info("OUT PHASE - Setting exact camera position: {} {} {}", 
                        currentTarget.getPosition().getX(), 
                        currentTarget.getPosition().getY(), 
                        currentTarget.getPosition().getZ());
                }
                
                // Apply post-move settings AFTER we've captured and set the position
                AbstractMovementSettings settings = (AbstractMovementSettings) activeMovement;
                CraneshotClient.CAMERA_CONTROLLER.setPostMoveStates(settings);
            }
        }
        if (state.isComplete()) {
            // Store final camera position before ending movement
            CameraTarget finalTarget = state.getCameraTarget().withAdjustedPosition(client.player, activeMovement.getRaycastType());
            baseTarget = finalTarget;
            
            // Clean up movement state
            Integer previousSlot = activeMovementSlot;
            ICameraMovement previousMovement = activeMovement;
            
            // Reset movement tracking variables
            activeMovement = null;
            activeMovementSlot = null;
            if (previousSlot != null) {
                toggledStates.put(previousSlot, false);
            }
            
            // Only clear post-move states if we don't have an active post-movement setting
            if (previousMovement instanceof AbstractMovementSettings) {
                AbstractMovementSettings settings = (AbstractMovementSettings) previousMovement;
                boolean hasPostSettings = settings.getPostMoveMouse() != AbstractMovementSettings.POST_MOVE_MOUSE.NONE || 
                                          settings.getPostMoveKeys() != AbstractMovementSettings.POST_MOVE_KEYS.NONE;
                                          
                if (!hasPostSettings) {
                    CraneshotClient.CAMERA_CONTROLLER.setPostMoveStates(null);
                }
            } else {
                CraneshotClient.CAMERA_CONTROLLER.setPostMoveStates(null);
            }
            
            // Notify controller of completion, but maintain final camera position
            CraneshotClient.CAMERA_CONTROLLER.onComplete();
            
            // Return the final state to ensure one last smooth frame
            return new MovementState(finalTarget, true);
        }

        baseTarget = state.getCameraTarget().withAdjustedPosition(client.player, activeMovement.getRaycastType());
        return state;
    }

    public CameraTarget update(MinecraftClient client, Camera camera) {
        if (activeMovement == null || client.player == null) {
            return null;
        }
        MovementState state = calculateState(client, camera);
        if (state == null) return null;
        return state.getCameraTarget();
    }

    public Integer getActiveMovementSlot() {
        return activeMovementSlot;
    }

    public ICameraMovement getActiveMovement() {
        return activeMovement;
    }

    public List<List<ICameraMovement>> getSlots() {
        return slots;
    }

    // Add this method to CameraMovementManager class
    public int getCurrentTypeForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < currentTypes.size()) {
            return currentTypes.get(slotIndex);
        }
        return 0;
    }

    /**
     * Cycles the current movement type in the given slot.
     * @param forward if true, cycles forward; if false, cycles backward.
     * @param wrap whether to wrap around the list.
     */
    public void cycleMovementType(boolean forward, int slotIndex, boolean wrap) {
        if (slotIndex < 0 || slotIndex >= slots.size()) return;
        List<ICameraMovement> slotMovements = slots.get(slotIndex);
        if (slotMovements.isEmpty()) return;

        int currentType = currentTypes.get(slotIndex);
        int newType;
        if (forward) {
            newType = wrap ? (currentType + 1) % slotMovements.size() : Math.min(currentType + 1, slotMovements.size() - 1);
        } else {
            newType = wrap ? (currentType - 1 + slotMovements.size()) % slotMovements.size() : Math.max(currentType - 1, 0);
        }
        currentTypes.set(slotIndex, newType);
    }

    public boolean hasActiveMovement() {
        return activeMovement != null;
    }

    public AbstractMovementSettings.SCROLL_WHEEL getActiveMouseWheelMode() {
        if (activeMovement != null && activeMovement instanceof AbstractMovementSettings) {
            return ((AbstractMovementSettings) activeMovement).mouseWheel;
        }
        return AbstractMovementSettings.SCROLL_WHEEL.NONE;
    }
}

================
File: client/java/ninja/trek/CameraMovementRegistry.java
================
package ninja.trek;

import ninja.trek.cameramovements.CameraMovementType;
import ninja.trek.cameramovements.ICameraMovement;
import net.fabricmc.loader.api.FabricLoader;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.net.URL;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;

public class CameraMovementRegistry {
    private static final List<Class<? extends ICameraMovement>> movementTypes = new ArrayList<>();
    private static int currentTypeIndex = 0;
    private static final String BASE_PACKAGE = "ninja.trek.cameramovements";

    public static void initialize() {
        try {
            scanPackage(BASE_PACKAGE);
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to scan for camera movements", e);
        }
    }

    private static void scanPackage(String packageName) {
        try {
            String path = packageName.replace('.', '/');
            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
            Enumeration<URL> resources = classLoader.getResources(path);

            while (resources.hasMoreElements()) {
                URL resource = resources.nextElement();
                String protocol = resource.getProtocol();

                if (protocol.equals("file")) {
                    scanDirectory(new File(resource.getFile()), packageName);
                } else if (protocol.equals("jar")) {
                    scanJar(resource, path);
                }
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Error scanning package: " + packageName, e);
        }
    }

    private static void scanDirectory(File directory, String packageName) {
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    scanDirectory(file, packageName + "." + file.getName());
                } else if (file.getName().endsWith(".class")) {
                    String className = packageName + "." + file.getName().substring(0, file.getName().length() - 6);
                    processClass(className);
                }
            }
        }
    }

    private static void scanJar(URL resourceUrl, String path) {
        String jarPath = resourceUrl.getPath().substring(5, resourceUrl.getPath().indexOf("!"));
        try (JarFile jarFile = new JarFile(jarPath)) {
            Enumeration<JarEntry> entries = jarFile.entries();
            while (entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String entryName = entry.getName();
                if (entryName.startsWith(path) && entryName.endsWith(".class")) {
                    String className = entryName.substring(0, entryName.length() - 6).replace('/', '.');
                    processClass(className);
                }
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Error scanning JAR file: " + jarPath, e);
        }
    }

    private static void processClass(String className) {
        try {
            Class<?> cls = Class.forName(className);
            if (ICameraMovement.class.isAssignableFrom(cls) &&
                    cls.isAnnotationPresent(CameraMovementType.class)) {

                CameraMovementType annotation = cls.getAnnotation(CameraMovementType.class);
                if (annotation.enabled()) {
                    @SuppressWarnings("unchecked")
                    Class<? extends ICameraMovement> movementClass = (Class<? extends ICameraMovement>) cls;
                    registerMovement(movementClass);
                }
            }
        } catch (ClassNotFoundException e) {
            Craneshot.LOGGER.error("Error loading class: " + className, e);
        }
    }

    public static void registerMovement(Class<? extends ICameraMovement> movementClass) {
        Craneshot.LOGGER.info("found movement type: " + movementClass);
        if (!movementTypes.contains(movementClass)) {
            movementTypes.add(movementClass);

        }
    }

    public static ICameraMovement createCurrentMovement() {
        try {
            Constructor<? extends ICameraMovement> constructor = movementTypes.get(currentTypeIndex).getDeclaredConstructor();
            return constructor.newInstance();
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to create movement instance", e);
            return null;
        }
    }

    public static List<MovementInfo> getAllMovements() {
        List<MovementInfo> movements = new ArrayList<>();
        for (Class<? extends ICameraMovement> cls : movementTypes) {
            CameraMovementType annotation = cls.getAnnotation(CameraMovementType.class);
            if (annotation != null) {
                movements.add(new MovementInfo(
                        annotation.name().isEmpty() ? cls.getSimpleName() : annotation.name(),
                        annotation.description(),
                        cls
                ));
            }
        }
        return movements;
    }

    public static void cycleNextMovement() {
        currentTypeIndex = (currentTypeIndex + 1) % movementTypes.size();
    }

    public static String getCurrentMovementName() {
        Class<? extends ICameraMovement> currentClass = movementTypes.get(currentTypeIndex);
        CameraMovementType annotation = currentClass.getAnnotation(CameraMovementType.class);
        return annotation != null && !annotation.name().isEmpty() ?
                annotation.name() : currentClass.getSimpleName();
    }

    public static int getMovementCount() {
        return movementTypes.size();
    }

    // Helper class to hold movement type information
    public static class MovementInfo {
        private final String name;
        private final String description;
        private final Class<? extends ICameraMovement> movementClass;

        public MovementInfo(String name, String description, Class<? extends ICameraMovement> movementClass) {
            this.name = name;
            this.description = description;
            this.movementClass = movementClass;
        }

        public String getName() { return name; }
        public String getDescription() { return description; }
        public Class<? extends ICameraMovement> getMovementClass() { return movementClass; }
    }
}

================
File: client/java/ninja/trek/cameramovements/AbstractMovementSettings.java
================
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.entity.player.PlayerEntity;
import ninja.trek.Craneshot;
import ninja.trek.config.MovementSetting;
import ninja.trek.config.MovementSettingType;

import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;

public abstract class AbstractMovementSettings {
    private String customName = null;
    @MovementSetting(label = "Pitch offset", min = -180, max = 180)
    protected float pitchOffset = 0.0f;

    @MovementSetting(
            label = "Raycast Type",
            type = MovementSettingType.ENUM,
            description = "Controls how the camera handles collision with blocks"
    )
    private RaycastType raycastType = RaycastType.NEAR;
    public double alpha;

    public END_TARGET getEndTarget() {
        return endTarget;
    }

    public enum START_TARGET {PLAYER};
    public enum END_TARGET {HEAD_BACK, HEAD_FRONT, VELOCITY_BACK, VELOCITY_FRONT, FIXED_BACK, FIXED_FRONT}
    public enum POST_MOVE_MOUSE {
        NONE,       // Default behavior
        ROTATE_CAMERA // Allow free mouse control after movement
           // Allow WASD movement after movement
    }

    @MovementSetting(
            label = "Post-Movement Mouse",
            type = MovementSettingType.ENUM,
            description = "Controls camera behavior after movement completes"
    )
    protected POST_MOVE_MOUSE postMoveMouse = POST_MOVE_MOUSE.NONE;
    public POST_MOVE_MOUSE getPostMoveMouse() {
        return postMoveMouse;
    }

    public enum POST_MOVE_KEYS {
        NONE,       // Default behavior
        MOVE_CAMERA_FLAT, // Y-axis locked camera-relative movement
        MOVE_CAMERA_FREE, // Full camera-relative movement including pitch
        MOVE8       // 8-directional player movement relative to camera
    }

    @MovementSetting(
            label = "Post-Movement Keys",
            type = MovementSettingType.ENUM,
            description = "Controls camera behavior after movement completes"
    )
    protected POST_MOVE_KEYS postMoveKeys = POST_MOVE_KEYS.NONE;
    public POST_MOVE_KEYS getPostMoveKeys(){return postMoveKeys;}

    @MovementSetting(
            label = "Camera Position",
            type = MovementSettingType.ENUM,
            description = "Determines if camera follows in front or behind the player"
    )
    public END_TARGET endTarget = END_TARGET.HEAD_BACK;

    public enum SCROLL_WHEEL {NONE, DISTANCE, FOV};

    @MovementSetting(
            label = "Scroll",
            type = MovementSettingType.ENUM,
            description = "What the scroll wheel does while movement is active"
    )
    public SCROLL_WHEEL mouseWheel = SCROLL_WHEEL.NONE;

    @MovementSetting(label = "FOV Easing", min = 0.01, max = 1.0)
    protected double fovEasing = 0.1;

    @MovementSetting(label = "FOV Speed Limit", min = 0.1, max = 100.0)
    protected double fovSpeedLimit = 10.0;


    protected double minFov = 1.0;


    protected double maxFov = 180.0;

    @MovementSetting(label = "FOV Multiplier", min = 0.1, max = 3.0)
    protected float fovMultiplier = 1.0f;

    public void adjustFov(boolean increase, MinecraftClient client){};






    protected boolean headLockedToCamera = true;
    public boolean isHeadLockedToCamera() {
        return headLockedToCamera;
    }


    public RaycastType getRaycastType() {
        return raycastType != null ? raycastType : RaycastType.NONE;
    }

    public void setRaycastType(RaycastType type) {
        this.raycastType = type;
    }

    public String getDisplayName() {
        return customName != null ? customName : getClass().getSimpleName();
    }

    public void setCustomName(String name) {
        this.customName = name;
    }

    public Map<String, Object> getSettings() {
        Map<String, Object> settings = new HashMap<>();
        Stream.concat(
                        Arrays.stream(this.getClass().getDeclaredFields()),
                        Arrays.stream(AbstractMovementSettings.class.getDeclaredFields())
                )
                .filter(field -> field.isAnnotationPresent(MovementSetting.class) || field.getName().equals("customName"))
                .forEach(field -> {
                    field.setAccessible(true);
                    try {
                        Object value = field.get(this);
                        if (value instanceof Enum<?>) {
                            settings.put(field.getName(), ((Enum<?>) value).name());
                        } else {
                            settings.put(field.getName(), value);
                        }
                    } catch (IllegalAccessException e) {
                        Craneshot.LOGGER.error("Error accessing field: " + field.getName(), e);
                    }
                });
        return settings;
    }

    public void updateSetting(String key, Object value) {
        try {
            if (key.equals("customName")) {
                setCustomName((String)value);
                return;
            }

            Field field = findField(key);
            if (field != null && field.isAnnotationPresent(MovementSetting.class)) {
                field.setAccessible(true);

                // Handle different field types
                if (field.getType().isEnum()) {
                    if (value instanceof String) {
                        @SuppressWarnings("unchecked")
                        Enum<?> enumValue = Enum.valueOf(field.getType().asSubclass(Enum.class), (String) value);
                        field.set(this, enumValue);
                        if (key.equals("raycastType")) {
                            setRaycastType((RaycastType)enumValue);
                        }
                    }
                } else if (field.getType() == double.class || field.getType() == Double.class) {
                    double doubleValue;
                    if (value instanceof Number) {
                        doubleValue = ((Number)value).doubleValue();
                    } else if (value instanceof String) {
                        doubleValue = Double.parseDouble((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to double");
                    }
                    field.setDouble(this, doubleValue);
                } else if (field.getType() == float.class || field.getType() == Float.class) {
                    float floatValue;
                    if (value instanceof Number) {
                        floatValue = ((Number)value).floatValue();
                    } else if (value instanceof String) {
                        floatValue = Float.parseFloat((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to float");
                    }
                    field.setFloat(this, floatValue);
                } else if (field.getType() == int.class || field.getType() == Integer.class) {
                    int intValue;
                    if (value instanceof Number) {
                        intValue = ((Number)value).intValue();
                    } else if (value instanceof String) {
                        intValue = Integer.parseInt((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to integer");
                    }
                    field.setInt(this, intValue);
                } else {
                    // Default fallback for other types
                    field.set(this, value);
                }
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Error updating setting {} with value {}: {}", key, value, e.getMessage());
        }
    }

    private Field findField(String key) {
        try {
            return this.getClass().getDeclaredField(key);
        } catch (NoSuchFieldException e) {
            try {
                return AbstractMovementSettings.class.getDeclaredField(key);
            } catch (NoSuchFieldException ex) {
                Craneshot.LOGGER.error("Field not found: {}", key);
                return null;
            }
        }
    }
}

================
File: client/java/ninja/trek/cameramovements/CameraMovementType.java
================
package ninja.trek.cameramovements;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CameraMovementType {
    String name() default "";
    String description() default "";
    boolean enabled() default true;
}

================
File: client/java/ninja/trek/cameramovements/CameraState.java
================
package ninja.trek.cameramovements;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.input.Input;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;

public class CameraState {
    private Vec3d position;
    private float yaw;
    private float pitch;

    public CameraState(Vec3d position, float yaw, float pitch) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
    }

    public static CameraState fromCamera(Camera camera) {
        return new CameraState(camera.getPos(), camera.getYaw(), camera.getPitch());
    }

    public Vec3d getPosition() { return position; }
    public float getYaw() { return yaw; }
    public float getPitch() { return pitch; }

    public CameraState lerp(CameraState other, double t) {
        Vec3d lerpedPos = this.position.lerp(other.position, t);
        float lerpedYaw = lerpAngle(this.yaw, other.yaw, (float)t);
        float lerpedPitch = lerpAngle(this.pitch, other.pitch, (float)t);
        return new CameraState(lerpedPos, lerpedYaw, lerpedPitch);
    }

    private float lerpAngle(float start, float end, float t) {
        float diff = end - start;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return start + diff * t;
    }
}

================
File: client/java/ninja/trek/cameramovements/CameraTarget.java
================
package ninja.trek.cameramovements;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.mixin.client.FovAccessor;

public class CameraTarget {
    private Vec3d position;
    private float yaw;
    private float pitch;
    private float fovMultiplier;  // 1.0 = normal FOV, >1 = wider, <1 = narrower

    public CameraTarget(Vec3d position, float yaw, float pitch, float fovMultiplier) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
        this.fovMultiplier = Math.max(0.1f, fovMultiplier);
    }

    public CameraTarget(Vec3d position, float yaw, float pitch) {
        this(position, yaw, pitch, 1.0f); // Default to normal FOV
    }

    public CameraTarget() {
        position = new Vec3d(0, 0, 0);
        yaw = 0;
        pitch = 0;
        fovMultiplier = 1.0f; // Default to normal FOV
    }

    public static CameraTarget fromCamera(Camera camera) {
        MinecraftClient client = MinecraftClient.getInstance();
        float currentFovMultiplier = 1.0f;
        if (client.gameRenderer instanceof FovAccessor) {
            currentFovMultiplier = ((FovAccessor) client.gameRenderer).getFovModifier();
            if (currentFovMultiplier == 0) currentFovMultiplier = 1.0f;
        }
        return new CameraTarget(camera.getPos(), camera.getYaw(), camera.getPitch(), currentFovMultiplier);
    }

    public static CameraTarget fromDistanceBack(PlayerEntity player, double distance) {
        double yaw = Math.toRadians(player.getYaw());
        double pitch = Math.toRadians(player.getPitch());
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * distance;
        double yOffset = Math.sin(pitch) * distance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * distance;
        Vec3d targetPos = player.getEyePos().add(xOffset, yOffset, zOffset);
        return new CameraTarget(targetPos, player.getYaw(), player.getPitch(), 1.0f);
    }

    public static CameraTarget fromDistanceFront(PlayerEntity player, double distance) {
        double yaw = Math.toRadians(player.getYaw() + 180);
        double pitch = Math.toRadians(-player.getPitch());
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * distance;
        double yOffset = Math.sin(pitch) * distance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * distance;
        Vec3d targetPos = player.getEyePos().add(xOffset, yOffset, zOffset);
        return new CameraTarget(targetPos, player.getYaw() + 180, -player.getPitch(), 1.0f);
    }

    public Vec3d getPosition() {
        return position;
    }

    public float getYaw() {
        return yaw;
    }

    public float getPitch() {
        return pitch;
    }

    public float getFovMultiplier() {
        return fovMultiplier;
    }

    public void setFovMultiplier(float multiplier) {
        this.fovMultiplier = Math.max(0.1f, multiplier); // Ensure we never have a zero or negative multiplier
    }

    public CameraTarget withAdjustedPosition(PlayerEntity player, RaycastType raycastType) {
        Vec3d adjustedPos = RaycastUtil.adjustForCollision(player.getEyePos(), this.position, raycastType);
        return new CameraTarget(adjustedPos, this.yaw, this.pitch, this.fovMultiplier);
    }

    public void set(Vec3d v, float yaw, float pitch) {
        set(v, yaw, pitch, this.fovMultiplier);
    }

    public void set(Vec3d v, float yaw, float pitch, float fovMultiplier) {
        position = v;
        this.yaw = yaw;
        this.pitch = pitch;
        this.fovMultiplier = fovMultiplier != 0 ? fovMultiplier : 1.0f;
    }

    public void set(CameraTarget t) {
        position = t.position;
        this.pitch = t.pitch;
        this.yaw = t.yaw;
        this.fovMultiplier = t.fovMultiplier != 0 ? t.fovMultiplier : 1.0f;
    }

    public CameraTarget lerp(CameraTarget other, float t) {
        Vec3d lerpedPos = this.position.lerp(other.position, t);
        float lerpedYaw = lerpAngle(this.yaw, other.yaw, t);
        float lerpedPitch = lerpAngle(this.pitch, other.pitch, t);

        // Ensure we're interpolating between valid FOV multipliers
        float startFov = this.fovMultiplier != 0 ? this.fovMultiplier : 1.0f;
        float endFov = other.fovMultiplier != 0 ? other.fovMultiplier : 1.0f;
        float lerpedFov = startFov + (endFov - startFov) * t;

        return new CameraTarget(lerpedPos, lerpedYaw, lerpedPitch, lerpedFov);
    }

    private float lerpAngle(float start, float end, float t) {
        float diff = end - start;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return start + diff * t;
    }
}

================
File: client/java/ninja/trek/cameramovements/ICameraMovement.java
================
package ninja.trek.cameramovements;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;

public interface ICameraMovement {
    void start(MinecraftClient client, Camera camera);
    MovementState calculateState(MinecraftClient client, Camera camera);
    void queueReset(MinecraftClient client, Camera camera);
    void adjustDistance(boolean increase, MinecraftClient client);
    String getName();
    float getWeight(); // For blending calculations
    boolean isComplete(); // To determine if movement should be removed
    RaycastType getRaycastType();
    default boolean hasCompletedOutPhase() { return false; }
}

================
File: client/java/ninja/trek/cameramovements/movements/BezierMovement.java
================
package ninja.trek.cameramovements.movements;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import ninja.trek.CameraController;
import ninja.trek.cameramovements.*;
import ninja.trek.config.MovementSetting;
import ninja.trek.mixin.client.FovAccessor;

@CameraMovementType(
        name = "Bezier",
        description = "Moves the camera in a curved line"
)
public class BezierMovement extends AbstractMovementSettings implements ICameraMovement {
    @MovementSetting(label = "Position Easing", min = 0.01, max = 1.0)
    private double positionEasing = 0.1;

    @MovementSetting(label = "Position Speed Limit", min = 0.1, max = 100.0)
    private double positionSpeedLimit = 10;

    @MovementSetting(label = "Rotation Easing", min = 0.01, max = 1.0)
    private double rotationEasing = 0.1;

    @MovementSetting(label = "Rotation Speed Limit", min = 0.1, max = 1000)
    private double rotationSpeedLimit = 500;

    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10.0;

    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0;

    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0;

    @MovementSetting(label = "Control Point Displacement", min = 0.0, max = 30)
    private double controlPointDisplacement = 5;

    @MovementSetting(label = "Displacement Angle", min = -180.0, max = 180.0)
    private double displacementAngle = 0.0;

    @MovementSetting(label = "Displacement Angle Variance", min = 0.0, max = 180.0)
    private double displacementAngleVariance = 0.0;

    public CameraTarget start = new CameraTarget();
    private CameraTarget end = new CameraTarget();
    public CameraTarget current = new CameraTarget();
    private Vec3d controlPoint;
    private double progress;
    private boolean resetting = false;
    private boolean linearMode = false;
    private boolean distanceChanged = false;
    private float weight = 1.0f;
    private float baseFov;

    @Override
    public void start(MinecraftClient client, Camera camera) {
        start = CameraTarget.fromCamera(camera);
        current = CameraTarget.fromCamera(camera);

        // Store base FOV
        baseFov = client.options.getFov().getValue().floatValue();

        Vec3d targetPos = calculateTargetPosition(CameraController.controlStick);
        end = new CameraTarget(targetPos, CameraController.controlStick.getYaw(),
                CameraController.controlStick.getPitch());

        controlPoint = generateControlPoint(start.getPosition(), end.getPosition());
        progress = 0.0;
        resetting = false;
        linearMode = false;
        distanceChanged = false;
        weight = 1.0f;
        alpha = 1;
    }

    private Vec3d calculateTargetPosition(CameraTarget stick) {
        double yaw = Math.toRadians(stick.getYaw());
        double pitch = Math.toRadians(stick.getPitch());
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * targetDistance;
        double yOffset = Math.sin(pitch) * targetDistance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * targetDistance;
        return stick.getPosition().add(xOffset, yOffset, zOffset);
    }

    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        if (client.player == null) return new MovementState(current, true);

        // Update start target with controlStick's current state
        start = new CameraTarget(
                CameraController.controlStick.getPosition(),
                CameraController.controlStick.getYaw(),
                CameraController.controlStick.getPitch(),
                start.getFovMultiplier()
        );

        // Update end target based on controlStick and target distance
        Vec3d targetPos = calculateTargetPosition(CameraController.controlStick);
        end = new CameraTarget(targetPos, CameraController.controlStick.getYaw(),
                CameraController.controlStick.getPitch(), end.getFovMultiplier());

        if (distanceChanged) {
            controlPoint = generateControlPoint(start.getPosition(), end.getPosition());
            distanceChanged = false;
        }

        CameraTarget a = resetting ? end : start;
        CameraTarget b = resetting ? start : end;
        
        // When returning, continuously update the target to follow the player's head position and rotation
        if (resetting && client.player != null) {
            Vec3d playerPos = client.player.getEyePos();
            float playerYaw = client.player.getYaw();
            float playerPitch = client.player.getPitch();
            
            // Update return target to always be the player's current head position and rotation
            b = new CameraTarget(playerPos, playerYaw, playerPitch, b.getFovMultiplier());
            
            // If needed, update the control point to ensure smooth path to player
            if (progress < 0.5) {
                controlPoint = generateControlPoint(current.getPosition(), playerPos);
            }
        }
        
        Vec3d desiredPos;

        if (!linearMode) {
            // Bezier movement mode
            double potentialDelta = (1.0 - progress) * positionEasing;
            double totalDistance = a.getPosition().distanceTo(b.getPosition());
            double maxMove = positionSpeedLimit * (1.0 / 20.0);
            double allowedDelta = totalDistance > 0 ? maxMove / totalDistance : potentialDelta;
            double progressDelta = Math.min(potentialDelta, allowedDelta);
            progress = Math.min(1.0, progress + progressDelta);
            desiredPos = quadraticBezier(
                    a.getPosition(),
                    controlPoint,
                    b.getPosition(),
                    progress
            );
        } else {
            // Linear movement mode
            Vec3d delta = b.getPosition().subtract(current.getPosition());
            double deltaLength = delta.length();
            double maxMove = positionSpeedLimit * (1.0 / 20.0);
            Vec3d move;
            if (deltaLength > 0) {
                move = delta.multiply(positionEasing);
                if (move.length() > maxMove) {
                    move = move.normalize().multiply(maxMove);
                }
            } else {
                move = Vec3d.ZERO;
            }
            desiredPos = current.getPosition().add(move);
        }

        // Calculate target rotation and FOV
        float targetYaw = b.getYaw();
        float targetPitch = b.getPitch();
        float targetFovDelta = (float) b.getFovMultiplier();

        // Apply rotation easing
        float yawError = targetYaw - current.getYaw();
        float pitchError = targetPitch - current.getPitch();
        float fovError = (float) (targetFovDelta - current.getFovMultiplier());

        while (yawError > 180) yawError -= 360;
        while (yawError < -180) yawError += 360;

        float desiredYawSpeed = (float)(yawError * rotationEasing);
        float desiredPitchSpeed = (float)(pitchError * rotationEasing);
        float desiredFovSpeed = (float)(fovError * fovEasing);

        // Apply speed limits
        float maxRotation = (float)(rotationSpeedLimit * (1.0 / 20.0));
        float maxFovChange = (float)(fovSpeedLimit * (1.0 / 20.0));

        if (Math.abs(desiredYawSpeed) > maxRotation) {
            desiredYawSpeed = Math.signum(desiredYawSpeed) * maxRotation;
        }
        if (Math.abs(desiredPitchSpeed) > maxRotation) {
            desiredPitchSpeed = Math.signum(desiredPitchSpeed) * maxRotation;
        }
        if (Math.abs(desiredFovSpeed) > maxFovChange) {
            desiredFovSpeed = Math.signum(desiredFovSpeed) * maxFovChange;
        }

        float newYaw = current.getYaw() + desiredYawSpeed;
        float newPitch = current.getPitch() + desiredPitchSpeed;
        float newFovDelta = (float) (current.getFovMultiplier() + desiredFovSpeed);

        // Update current target
        current = new CameraTarget(desiredPos, newYaw, newPitch, newFovDelta);

        // Update FOV in game renderer
        if (client.gameRenderer instanceof FovAccessor) {
            ((FovAccessor) client.gameRenderer).setFovModifier((float) current.getFovMultiplier());
        }

        // Update alpha for external systems
        double remaining = current.getPosition().distanceTo(b.getPosition());
        double totalDistance = a.getPosition().distanceTo(b.getPosition());
        alpha = totalDistance != 0 ? remaining / totalDistance : 0.0;

        // Switch to linear mode when out phase completes
        if (!resetting && progress >= 0.999) {
            linearMode = true;
        }

        boolean complete = resetting && progress >= 0.999;
        return new MovementState(current, complete);
    }

    private Vec3d quadraticBezier(Vec3d p0, Vec3d p1, Vec3d p2, double t) {
        double oneMinusT = 1.0 - t;
        return p0.multiply(oneMinusT * oneMinusT)
                .add(p1.multiply(2 * oneMinusT * t))
                .add(p2.multiply(t * t));
    }

    private Vec3d generateControlPoint(Vec3d start, Vec3d end) {
        Vec3d mid = start.add(end).multiply(0.5);
        Vec3d diff = end.subtract(start);

        if (diff.lengthSquared() < 1e-6) {
            return mid.add(new Vec3d(0, controlPointDisplacement, 0));
        }

        Vec3d direction = diff.normalize();
        Vec3d worldUp = new Vec3d(0, 1, 0);
        Vec3d right = direction.crossProduct(worldUp).normalize();
        Vec3d perpUp = direction.crossProduct(right).normalize();

        if (perpUp.y < 0) {
            perpUp = perpUp.multiply(-1);
        }

        if (Math.abs(displacementAngle) > 0 || displacementAngleVariance > 0) {
            double angleOffset = displacementAngle +
                    (displacementAngleVariance > 0 ? (Math.random() * 2 - 1) * displacementAngleVariance : 0);
            double angleRadians = Math.toRadians(angleOffset);
            perpUp = perpUp.multiply(Math.cos(angleRadians))
                    .add(direction.crossProduct(perpUp).multiply(Math.sin(angleRadians)));
        }

        return mid.add(perpUp.multiply(controlPointDisplacement));
    }

    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        if (!resetting) {
            resetting = true;
            linearMode = false;
            progress = 0.0;
            
            // Always target the player head position/rotation during return phase
            if (client.player != null) {
                // Always return to player's head rotation regardless of END_TARGET
                float playerYaw = client.player.getYaw();
                float playerPitch = client.player.getPitch();
                Vec3d playerPos = client.player.getEyePos();
                
                // Set the target position to player head with proper rotation for return
                end = new CameraTarget(playerPos, playerYaw, playerPitch, 1.0f);
                
                ninja.trek.Craneshot.LOGGER.info("BezierMovement return to player head rotation: pos={}, yaw={}, pitch={}", 
                    playerPos, playerYaw, playerPitch);
            }
            
            // Update current camera position
            current = CameraTarget.fromCamera(camera);
            
            // Generate a control point for the return path
            // We're always returning to player position now
            if (client.player != null) {
                controlPoint = generateControlPoint(current.getPosition(), client.player.getEyePos());
                
                ninja.trek.Craneshot.LOGGER.info("Returning with control point: {} {} {}", 
                    controlPoint.getX(), controlPoint.getY(), controlPoint.getZ());
            }
            
            // Reset FOV delta when movement ends
            end.setFovMultiplier(1.0f);
        }
    }

    @Override
    public void adjustDistance(boolean increase, MinecraftClient client) {
        if (mouseWheel == SCROLL_WHEEL.DISTANCE) {
            double multiplier = increase ? 1.1 : 0.9;
            targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
            distanceChanged = true;
        } else if (mouseWheel == SCROLL_WHEEL.FOV) {
            adjustFov(increase, client);
        }
    }

    @Override
    public void adjustFov(boolean increase, MinecraftClient client) {
        if (mouseWheel != SCROLL_WHEEL.FOV) return;
        // Change multiplier by 10% each scroll
        float change = increase ? 0.2f : -0.2f;
        float newMultiplier = (float) (fovMultiplier + change);
        float basefov = client.options.getFov().getValue();

        // Calculate the new FOV
        float newFov = basefov * newMultiplier;

        // Clamp the FOV between 1 and 180
        newFov = Math.max(1, Math.min(newFov, 180));

        // Adjust the fovMultiplier to ensure the FOV stays within the desired range
        fovMultiplier = newFov / basefov;

        // Update current target's FOV immediately
        current.setFovMultiplier(fovMultiplier);

        // Update end target's FOV for smooth transitions
        end.setFovMultiplier(fovMultiplier);
    }

    @Override
    public String getName() {
        return "Bezier";
    }

    @Override
    public float getWeight() {
        return weight;
    }

    @Override
    public boolean isComplete() {
        return resetting && current.getPosition().distanceTo(start.getPosition()) < 0.03;
    }

    @Override
    public boolean hasCompletedOutPhase() {
        if (resetting) return false;
        if (linearMode) {
            return alpha < 0.1;
        } else {
            return progress >= 0.999;
        }
    }
}

================
File: client/java/ninja/trek/cameramovements/movements/FreeCamReturnMovement.java
================
package ninja.trek.cameramovements.movements;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import ninja.trek.CameraController;
import ninja.trek.Craneshot;
import ninja.trek.cameramovements.*;
import ninja.trek.config.MovementSetting;
import ninja.trek.mixin.client.FovAccessor;

@CameraMovementType(
        name = "FreeCamReturn",
        description = "Smoothly returns from free camera mode to the normal camera position"
)
public class FreeCamReturnMovement extends AbstractMovementSettings implements ICameraMovement {
    @MovementSetting(label = "Position Easing", min = 0.01, max = 1.0)
    private double positionEasing = 0.2;

    @MovementSetting(label = "Position Speed Limit", min = 0.1, max = 100.0)
    private double positionSpeedLimit = 5.0;

    @MovementSetting(label = "Rotation Easing", min = 0.01, max = 1.0)
    private double rotationEasing = 0.2;

    @MovementSetting(label = "Rotation Speed Limit", min = 0.1, max = 3600.0)
    private double rotationSpeedLimit = 90.0;

    private CameraTarget start = new CameraTarget();
    private CameraTarget end = new CameraTarget();
    private CameraTarget current = new CameraTarget();
    private boolean isComplete = false;
    private boolean isStarted = false;
    private double completionThreshold = 0.05; // Distance in blocks to consider movement complete
    private END_TARGET originalEndTarget = END_TARGET.HEAD_BACK; // Store the original movement's target type

    @Override
    public void start(MinecraftClient client, Camera camera) {
        // Initialize with the current camera position (free camera position)
        start = CameraTarget.fromCamera(camera);
        current = CameraTarget.fromCamera(camera);
        
        // Store the original end target for proper rotation calculation
        originalEndTarget = CameraController.currentEndTarget;
        
        // Calculate the destination (out position)
        Vec3d targetPos = CameraController.controlStick.getPosition();
        float targetYaw = CameraController.controlStick.getYaw();
        float targetPitch = CameraController.controlStick.getPitch();
        
        // Ensure target rotation is correct for the original movement's end target type
        if (originalEndTarget == END_TARGET.HEAD_FRONT) {
            // For HEAD_FRONT we need to ensure we return to the player's head rotation inverted
            if (client.player != null) {
                targetYaw = (client.player.getYaw() + 180) % 360;
                targetPitch = -client.player.getPitch();
            }
        }
        
        end = new CameraTarget(targetPos, targetYaw, targetPitch, 1.0f);
        
        isComplete = false;
        isStarted = true;
        
        Craneshot.LOGGER.info("FreeCamReturnMovement started: {} -> {}, Original Target: {}", 
            start.getPosition(), end.getPosition(), originalEndTarget);
    }

    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        if (!isStarted || client.player == null) {
            return new MovementState(current, true);
        }
        
        // For HEAD_FRONT target type, we need to continuously update the target rotation
        // since the player might be moving and changing their orientation
        if (originalEndTarget == END_TARGET.HEAD_FRONT) {
            // Update the end target rotation based on player's current orientation
            float targetYaw = (client.player.getYaw() + 180) % 360;
            float targetPitch = -client.player.getPitch();
            end = new CameraTarget(end.getPosition(), targetYaw, targetPitch, end.getFovMultiplier());
        }
        
        // Position interpolation with speed limit
        Vec3d desired = current.getPosition().lerp(end.getPosition(), positionEasing);
        Vec3d moveVector = desired.subtract(current.getPosition());
        double moveDistance = moveVector.length();
        
        if (moveDistance > 0.01) {
            double maxMove = positionSpeedLimit * (1.0/20.0); // Convert blocks/second to blocks/tick
            if (moveDistance > maxMove) {
                Vec3d limitedMove = moveVector.normalize().multiply(maxMove);
                desired = current.getPosition().add(limitedMove);
            }
        }

        // Rotation interpolation with speed limit
        float targetYaw = end.getYaw();
        float targetPitch = end.getPitch();
        float yawDiff = targetYaw - current.getYaw();
        float pitchDiff = targetPitch - current.getPitch();

        // Normalize angles to [-180, 180]
        while (yawDiff > 180) yawDiff -= 360;
        while (yawDiff < -180) yawDiff += 360;

        // Apply easing to get desired rotation speed
        float desiredYawSpeed = (float)(yawDiff * rotationEasing);
        float desiredPitchSpeed = (float)(pitchDiff * rotationEasing);

        // Apply rotation speed limit
        float maxRotation = (float)(rotationSpeedLimit * (1.0/20.0));
        if (Math.abs(desiredYawSpeed) > maxRotation) {
            desiredYawSpeed = Math.signum(desiredYawSpeed) * maxRotation;
        }
        if (Math.abs(desiredPitchSpeed) > maxRotation) {
            desiredPitchSpeed = Math.signum(desiredPitchSpeed) * maxRotation;
        }

        // Apply final changes
        float newYaw = current.getYaw() + desiredYawSpeed;
        float newPitch = current.getPitch() + desiredPitchSpeed;

        // Update current target
        current = new CameraTarget(desired, newYaw, newPitch, current.getFovMultiplier());

        // Update FOV in game renderer
        if (client.gameRenderer instanceof FovAccessor) {
            ((FovAccessor) client.gameRenderer).setFovModifier((float) current.getFovMultiplier());
        }

        // Check if we've reached the destination
        double remainingDistance = current.getPosition().distanceTo(end.getPosition());
        double yawRemaining = Math.abs(yawDiff);
        double pitchRemaining = Math.abs(pitchDiff);
        
        // Movement is complete when we're close enough to the destination
        boolean positionComplete = remainingDistance < completionThreshold;
        boolean rotationComplete = yawRemaining < 1.0 && pitchRemaining < 1.0;
        isComplete = positionComplete && rotationComplete;
        
        if (isComplete) {
            Craneshot.LOGGER.info("FreeCamReturnMovement completed");
        }
        
        return new MovementState(current, isComplete);
    }

    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        // This movement doesn't have a reset phase - it's already returning
        isComplete = true;
    }

    @Override
    public void adjustDistance(boolean increase, MinecraftClient client) {
        // Not applicable for this movement
    }

    @Override
    public String getName() {
        return "FreeCamReturn";
    }

    @Override
    public float getWeight() {
        return 1.0f;
    }

    @Override
    public boolean isComplete() {
        return isComplete;
    }

    @Override
    public RaycastType getRaycastType() {
        return RaycastType.NONE; // Assuming we don't need raycast for this movement
    }
}

================
File: client/java/ninja/trek/cameramovements/movements/LinearMovement.java
================
package ninja.trek.cameramovements.movements;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import ninja.trek.CameraController;
import ninja.trek.Craneshot;
import ninja.trek.CraneshotClient;
import ninja.trek.cameramovements.*;
import ninja.trek.config.MovementSetting;
import ninja.trek.mixin.client.FovAccessor;

@CameraMovementType(
        name = "Linear",
        description = "Moves the camera along a line"
)
public class LinearMovement extends AbstractMovementSettings implements ICameraMovement {
    @MovementSetting(label = "Position Easing", min = 0.01, max = 1.0)
    private double positionEasing = 0.1;

    @MovementSetting(label = "Position Speed Limit", min = 0.1, max = 100.0)
    private double positionSpeedLimit = 2.0;

    @MovementSetting(label = "Rotation Easing", min = 0.01, max = 1.0)
    private double rotationEasing = 0.1;

    @MovementSetting(label = "Rotation Speed Limit", min = 0.1, max = 3600.0)
    private double rotationSpeedLimit = 45.0;

    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10.0;

    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0;

    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0;

    public CameraTarget start = new CameraTarget();
    public CameraTarget end = new CameraTarget();
    public CameraTarget current = new CameraTarget();
    private boolean resetting = false;
    private float weight = 1.0f;
    private double baseFov;

    public void start(MinecraftClient client, Camera camera) {
        // Initialize with camera's current state
        start = CameraTarget.fromCamera(camera);
        current = CameraTarget.fromCamera(camera);
        // Store base FOV and set initial FOV delta to 0
        baseFov = client.options.getFov().getValue().doubleValue();
        start.setFovMultiplier(1.0f);  // Start at normal FOV
        current.setFovMultiplier(1.0f); // Start at normal FOV
        // Calculate end target based on controlStick
        Vec3d targetPos = calculateTargetPosition(CameraController.controlStick);
        end = new CameraTarget(targetPos, CameraController.controlStick.getYaw(),
                CameraController.controlStick.getPitch() + pitchOffset, 1.0f);
        resetting = false;
        weight = 1.0f;
    }


    private Vec3d calculateTargetPosition(CameraTarget stick) {
        double yaw = Math.toRadians(stick.getYaw());
        double pitch = Math.toRadians(stick.getPitch() + pitchOffset);
        // Calculate offset based on target distance
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * targetDistance;
        double yOffset = Math.sin(pitch) * targetDistance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * targetDistance;
        return stick.getPosition().add(xOffset, yOffset, zOffset);
    }

    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        if (client.player == null) return new MovementState(current, true);

        // Update start target with controlStick's current state
        start = new CameraTarget(
                CameraController.controlStick.getPosition(),
                CameraController.controlStick.getYaw(),
                CameraController.controlStick.getPitch() + pitchOffset,
                start.getFovMultiplier()
        );

        // Update end target based on controlStick and target distance
        Vec3d targetPos = calculateTargetPosition(CameraController.controlStick);
        end = new CameraTarget(targetPos, CameraController.controlStick.getYaw(),
                CameraController.controlStick.getPitch() + pitchOffset, end.getFovMultiplier());

        CameraTarget a = resetting ? end : start;
        CameraTarget b = resetting ? start : end;
        
        // When returning, continuously update the target to follow the player's head position and rotation
        if (resetting && client.player != null) {
            Vec3d playerPos = client.player.getEyePos();
            float playerYaw = client.player.getYaw();
            float playerPitch = client.player.getPitch();
            
            // Update return target to always be the player's current head position and rotation
            b = new CameraTarget(playerPos, playerYaw, playerPitch, b.getFovMultiplier());
        }

        // Position interpolation with speed limit
        Vec3d desired = current.getPosition().lerp(b.getPosition(), positionEasing);
        Vec3d moveVector = desired.subtract(current.getPosition());
        double moveDistance = moveVector.length();
        if (moveDistance > 0.01) {
            double maxMove = positionSpeedLimit * (1.0/20.0); // Convert blocks/second to blocks/tick
            if (moveDistance > maxMove) {
                Vec3d limitedMove = moveVector.normalize().multiply(maxMove);
                desired = current.getPosition().add(limitedMove);
            }
        }

        // Rotation interpolation with speed limit
        float targetYaw = b.getYaw();
        float targetPitch = b.getPitch();
        float yawDiff = targetYaw - current.getYaw();
        float pitchDiff = targetPitch - current.getPitch();

        // Normalize angles to [-180, 180]
        while (yawDiff > 180) yawDiff -= 360;
        while (yawDiff < -180) yawDiff += 360;

        // Apply easing to get desired rotation speed
        float desiredYawSpeed = (float)(yawDiff * rotationEasing);
        float desiredPitchSpeed = (float)(pitchDiff * rotationEasing);

        // Apply rotation speed limit
        float maxRotation = (float)(rotationSpeedLimit * (1.0/20.0));
        if (Math.abs(desiredYawSpeed) > maxRotation) {
            desiredYawSpeed = Math.signum(desiredYawSpeed) * maxRotation;
        }
        if (Math.abs(desiredPitchSpeed) > maxRotation) {
            desiredPitchSpeed = Math.signum(desiredPitchSpeed) * maxRotation;
        }

        // FOV interpolation with speed limit
        float targetFovDelta = b.getFovMultiplier();
        float fovDiff = targetFovDelta - current.getFovMultiplier();
        float desiredFovSpeed = (float) (fovDiff * fovEasing);
        float maxFovChange = (float) (fovSpeedLimit * (1.0f/20.0f));

        if (Math.abs(desiredFovSpeed) > maxFovChange) {
            desiredFovSpeed = Math.signum(desiredFovSpeed) * maxFovChange;
        }

        // Apply final changes
        float newYaw = current.getYaw() + desiredYawSpeed;
        float newPitch = current.getPitch() + desiredPitchSpeed;
        float newFovDelta = current.getFovMultiplier() + desiredFovSpeed;

        // Update current target with all new values
        current = new CameraTarget(desired, newYaw, newPitch, newFovDelta);

        // Update FOV in game renderer
        if (client.gameRenderer instanceof FovAccessor) {
            ((FovAccessor) client.gameRenderer).setFovModifier(current.getFovMultiplier());
        }

        // Calculate progress for blending
        alpha = current.getPosition().distanceTo(b.getPosition()) /
                a.getPosition().distanceTo(b.getPosition());

        boolean complete = resetting && moveDistance < 0.01;
        return new MovementState(current, complete);
    }

    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        if (client.player == null) return;
        resetting = true;
        
        // Always target the player head position/rotation during return phase
        if (client.player != null) {
            // Always return to player's head rotation regardless of END_TARGET
            float playerYaw = client.player.getYaw();
            float playerPitch = client.player.getPitch();
            
            // Set the target position to player head and proper rotation for return
            Vec3d playerPos = client.player.getEyePos();
            end = new CameraTarget(playerPos, playerYaw, playerPitch, 1.0f);
            
            ninja.trek.Craneshot.LOGGER.info("LinearMovement return to player head rotation: pos={}, yaw={}, pitch={}", 
                playerPos, playerYaw, playerPitch);
        }
        
        // For free camera, also update the current target's position to ensure smooth transition
        if (current.getPosition().distanceTo(camera.getPos()) > 0.1) {
            current = CameraTarget.fromCamera(camera);
        }
        
        // Reset FOV delta when movement ends
        end.setFovMultiplier(1.0f);
    }

    @Override
    public void adjustDistance(boolean increase, MinecraftClient client) {
        if (mouseWheel == SCROLL_WHEEL.DISTANCE) {
            double multiplier = increase ? 1.1 : 0.9;
            targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
        } else if (mouseWheel == SCROLL_WHEEL.FOV) {
            adjustFov(increase, client);
        }
    }
    @Override
    public void adjustFov(boolean increase, MinecraftClient client) {
        if (mouseWheel != SCROLL_WHEEL.FOV) return;
        // Change multiplier by 10% each scroll
        float change = increase ? 0.2f : -0.2f;
        float newMultiplier = fovMultiplier + change;
        float basefov = client.options.getFov().getValue();

        // Calculate the new FOV
        float newFov = basefov * newMultiplier;

        // Clamp the FOV between 1 and 180
        newFov = Math.max(1, Math.min(newFov, 140));

        // Adjust the fovMultiplier to ensure the FOV stays within the desired range
        fovMultiplier = newFov / basefov;

        // Update current target's FOV immediately
        current.setFovMultiplier(fovMultiplier);

        // Update end target's FOV for smooth transitions
        end.setFovMultiplier(fovMultiplier);
    }

    @Override
    public String getName() {
        return "Linear";
    }

    @Override
    public float getWeight() {
        return weight;
    }

    @Override
    public boolean isComplete() {
        return resetting && current.getPosition().distanceTo(start.getPosition()) < 0.03;
    }

    @Override
    public boolean hasCompletedOutPhase() {
        return !resetting && alpha < .1;
    }
}

================
File: client/java/ninja/trek/cameramovements/MovementState.java
================
package ninja.trek.cameramovements;

public class MovementState {
    private final CameraTarget target;
    private final boolean isComplete;

    public MovementState(CameraTarget target, boolean isComplete) {
        this.target = target;
        this.isComplete = isComplete;
    }

    public CameraTarget getCameraTarget() {
        return target;
    }

    public boolean isComplete() {
        return isComplete;
    }
}

================
File: client/java/ninja/trek/cameramovements/RaycastType.java
================
package ninja.trek.cameramovements;

/**
 * Enum defining different raycast behaviors for camera collision handling
 */
public enum RaycastType {
    /**
     * No raycast collision checking - camera can clip through blocks
     */
    NONE,

    /**
     * Raycasts from player to desired camera position.
     * If collision detected, moves camera closer to player.
     * Behaves like default Minecraft third person camera.
     */
    NEAR,

    /**
     * Raycasts from desired camera position towards player.
     * If camera would be inside block, moves it to first non-solid position.
     * Provides more stable distant shots by preferring to keep camera far out.
     */
    FAR
}

================
File: client/java/ninja/trek/cameramovements/RaycastUtil.java
================
package ninja.trek.cameramovements;

import net.minecraft.client.MinecraftClient;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.RaycastContext;

public class RaycastUtil {
    private static final double CAMERA_OFFSET = 0.5;
    private static final double STEP_SIZE = 0.5;
    private static final double FINE_STEP_SIZE = 0.1;

    public static Vec3d adjustForCollision(Vec3d playerPos, Vec3d targetPos, RaycastType raycastType) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.world == null || raycastType == RaycastType.NONE) {
            return targetPos;
        }

        switch (raycastType) {
            case NEAR:
                return handleNearRaycast(client, playerPos, targetPos);
            case FAR:
                return handleFarRaycast(client, playerPos, targetPos);
            default:
                return targetPos;
        }
    }

    private static Vec3d handleNearRaycast(MinecraftClient client, Vec3d playerPos, Vec3d targetPos) {
        BlockHitResult hit = client.world.raycast(new RaycastContext(
                playerPos,
                targetPos,
                RaycastContext.ShapeType.VISUAL,
                RaycastContext.FluidHandling.NONE,
                client.player
        ));

        if (hit.getType() == HitResult.Type.BLOCK) {
            Vec3d hitPos = hit.getPos();
            Vec3d directionVector = hitPos.subtract(playerPos).normalize();
            return hitPos.subtract(directionVector.multiply(CAMERA_OFFSET));
        }
        return targetPos;
    }

    private static Vec3d handleFarRaycast(MinecraftClient client, Vec3d playerPos, Vec3d targetPos) {
        Vec3d direction = targetPos.subtract(playerPos).normalize();
        double totalDistance = targetPos.distanceTo(playerPos);

        // Start from target position
        Vec3d currentPos = targetPos;

        if (isPositionInAir(client, currentPos)) {
            return refinePosition(client, currentPos, direction);
        }

        // Coarse search
        for (double distance = STEP_SIZE; distance < totalDistance; distance += STEP_SIZE) {
            Vec3d checkPos = targetPos.subtract(direction.multiply(distance));

            if (isPositionInAir(client, checkPos)) {
                return refinePosition(client, checkPos, direction.multiply(-1));
            }
        }

        return playerPos;
    }

    private static Vec3d refinePosition(MinecraftClient client, Vec3d startPos, Vec3d direction) {
        // Raycast forward until we hit something
        BlockHitResult hit = client.world.raycast(new RaycastContext(
                startPos,
                startPos.add(direction.multiply(2.0)), // Look 2 blocks ahead
                RaycastContext.ShapeType.VISUAL,
                RaycastContext.FluidHandling.NONE,
                client.player
        ));

        if (hit.getType() == HitResult.Type.BLOCK) {
            Vec3d hitPos = hit.getPos();
            return hitPos.subtract(direction.multiply(CAMERA_OFFSET));
        }

        return startPos;
    }

    private static boolean isPositionInAir(MinecraftClient client, Vec3d pos) {
        BlockPos blockPos = BlockPos.ofFloored(pos);
        return client.world.getBlockState(blockPos).isAir();
    }
}

================
File: client/java/ninja/trek/config/FreeCamSettings.java
================
package ninja.trek.config;

public class FreeCamSettings {
    private float moveSpeed = 0.2f;
    private float acceleration = 0.1f;
    private float deceleration = 0.2f;
    private MovementMode movementMode = MovementMode.CAMERA;

    public enum MovementMode {
        CAMERA,    // Movement relative to camera direction
        AXIS_ALIGNED  // Movement along world axes
    }

    public float getMoveSpeed() {
        return moveSpeed;
    }

    public void setMoveSpeed(float speed) {
        moveSpeed = speed;
    }

    public float getAcceleration() {
        return acceleration;
    }

    public void setAcceleration(float acc) {
        acceleration = acc;
    }

    public float getDeceleration() {
        return deceleration;
    }

    public void setDeceleration(float dec) {
        deceleration = dec;
    }

    public MovementMode getMovementMode() {
        return movementMode;
    }

    public void setMovementMode(MovementMode mode) {
        movementMode = mode;
    }
}

================
File: client/java/ninja/trek/config/GeneralMenuSettings.java
================
package ninja.trek.config;

import ninja.trek.cameramovements.movements.FreeCamReturnMovement;

public class GeneralMenuSettings {
    private static boolean autoAdvance = false;
    private static final FreeCamSettings freeCamSettings = new FreeCamSettings();
    private static final FreeCamReturnMovement freeCamReturnMovement = new FreeCamReturnMovement();


    public static boolean isAutoAdvance() {
        return autoAdvance;
    }

    public static void setAutoAdvance(boolean value) {
        autoAdvance = value;
    }

    public static FreeCamSettings getFreeCamSettings() {
        return freeCamSettings;
    }
    
    public static FreeCamReturnMovement getFreeCamReturnMovement() {
        return freeCamReturnMovement;
    }
}

================
File: client/java/ninja/trek/config/GeneralSettingsIO.java
================
package ninja.trek.config;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonObject;
import net.minecraft.client.MinecraftClient;
import ninja.trek.Craneshot;
import java.io.*;

public class GeneralSettingsIO {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_general.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();

    public static void saveSettings() {
        try {
            if (!CONFIG_FILE.getParentFile().exists()) {
                CONFIG_FILE.getParentFile().mkdirs();
            }
            try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
                JsonObject settingsObj = new JsonObject();

                // Save wrap states and toggle states
                JsonObject wrapStatesObj = new JsonObject();
                JsonObject toggleStatesObj = new JsonObject();
                for (int i = 0; i < 3; i++) {
                    wrapStatesObj.addProperty("slot" + i, SlotMenuSettings.getWrapState(i));
                    toggleStatesObj.addProperty("slot" + i, SlotMenuSettings.getToggleState(i));
                }
                settingsObj.add("wrapStates", wrapStatesObj);
                settingsObj.add("toggleStates", toggleStatesObj);

                // Save FreeCamSettings
                JsonObject freeCamObj = new JsonObject();
                FreeCamSettings freeCam = GeneralMenuSettings.getFreeCamSettings();
                freeCamObj.addProperty("moveSpeed", freeCam.getMoveSpeed());
                freeCamObj.addProperty("acceleration", freeCam.getAcceleration());
                freeCamObj.addProperty("deceleration", freeCam.getDeceleration());
                freeCamObj.addProperty("movementMode", freeCam.getMovementMode().name());
                settingsObj.add("freeCam", freeCamObj);
                
                // Save FreeCamReturnMovement settings
                JsonObject freeCamReturnObj = new JsonObject();
                ninja.trek.cameramovements.movements.FreeCamReturnMovement freeCamReturn = GeneralMenuSettings.getFreeCamReturnMovement();
                // Save settings using reflection to access private fields
                java.util.Map<String, Object> returnSettings = ((ninja.trek.cameramovements.AbstractMovementSettings)freeCamReturn).getSettings();
                returnSettings.forEach((key, value) -> {
                    if (value instanceof Float || value instanceof Double) {
                        freeCamReturnObj.addProperty(key, ((Number)value).doubleValue());
                    } else if (value instanceof String) {
                        freeCamReturnObj.addProperty(key, (String)value);
                    } else if (value instanceof Boolean) {
                        freeCamReturnObj.addProperty(key, (Boolean)value);
                    } else if (value instanceof Enum) {
                        freeCamReturnObj.addProperty(key, ((Enum<?>)value).name());
                    }
                });
                settingsObj.add("freeCamReturn", freeCamReturnObj);

                // Save autoAdvance
                settingsObj.addProperty("autoAdvance", GeneralMenuSettings.isAutoAdvance());
                
                // Save expanded settings state
                JsonArray expandedSettingsArray = new JsonArray();
                for (String key : MenuOverlayScreen.getExpandedSettings()) {
                    expandedSettingsArray.add(key);
                }
                settingsObj.add("expandedSettings", expandedSettingsArray);

                GSON.toJson(settingsObj, writer);
                Craneshot.LOGGER.info("Saved general settings configuration");
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Failed to save general settings", e);
        }
    }

    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) {
            Craneshot.LOGGER.info("No general settings file found, using defaults");
            return;
        }

        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            JsonObject settingsObj = GSON.fromJson(reader, JsonObject.class);

            // Load wrap states and toggle states
            if (settingsObj.has("wrapStates")) {
                JsonObject wrapStatesObj = settingsObj.getAsJsonObject("wrapStates");
                for (int i = 0; i < 3; i++) {
                    String key = "slot" + i;
                    if (wrapStatesObj.has(key)) {
                        boolean wrapState = wrapStatesObj.get(key).getAsBoolean();
                        SlotMenuSettings.setWrapState(i, wrapState);
                    }
                }
            }

            if (settingsObj.has("toggleStates")) {
                JsonObject toggleStatesObj = settingsObj.getAsJsonObject("toggleStates");
                for (int i = 0; i < 3; i++) {
                    String key = "slot" + i;
                    if (toggleStatesObj.has(key)) {
                        boolean toggleState = toggleStatesObj.get(key).getAsBoolean();
                        SlotMenuSettings.setToggleState(i, toggleState);
                    }
                }
            }

            // Load FreeCamSettings
            if (settingsObj.has("freeCam")) {
                JsonObject freeCamObj = settingsObj.getAsJsonObject("freeCam");
                FreeCamSettings freeCam = GeneralMenuSettings.getFreeCamSettings();

                if (freeCamObj.has("moveSpeed")) {
                    freeCam.setMoveSpeed(freeCamObj.get("moveSpeed").getAsFloat());
                }
                if (freeCamObj.has("acceleration")) {
                    freeCam.setAcceleration(freeCamObj.get("acceleration").getAsFloat());
                }
                if (freeCamObj.has("deceleration")) {
                    freeCam.setDeceleration(freeCamObj.get("deceleration").getAsFloat());
                }
                if (freeCamObj.has("movementMode")) {
                    freeCam.setMovementMode(
                            FreeCamSettings.MovementMode.valueOf(
                                    freeCamObj.get("movementMode").getAsString()
                            )
                    );
                }
            }
            
            // Load FreeCamReturnMovement settings
            if (settingsObj.has("freeCamReturn")) {
                JsonObject returnObj = settingsObj.getAsJsonObject("freeCamReturn");
                ninja.trek.cameramovements.movements.FreeCamReturnMovement freeCamReturn = GeneralMenuSettings.getFreeCamReturnMovement();
                
                // Use the movement's updateSetting method to load each setting
                for (String key : returnObj.keySet()) {
                    try {
                        if (returnObj.get(key).isJsonPrimitive()) {
                            if (returnObj.get(key).getAsJsonPrimitive().isString()) {
                                ((ninja.trek.cameramovements.AbstractMovementSettings)freeCamReturn).updateSetting(
                                    key, returnObj.get(key).getAsString());
                            } else if (returnObj.get(key).getAsJsonPrimitive().isNumber()) {
                                ((ninja.trek.cameramovements.AbstractMovementSettings)freeCamReturn).updateSetting(
                                    key, returnObj.get(key).getAsDouble());
                            } else if (returnObj.get(key).getAsJsonPrimitive().isBoolean()) {
                                ((ninja.trek.cameramovements.AbstractMovementSettings)freeCamReturn).updateSetting(
                                    key, returnObj.get(key).getAsBoolean());
                            }
                        }
                    } catch (Exception e) {
                        Craneshot.LOGGER.error("Error loading FreeCamReturn setting: " + key, e);
                    }
                }
            }

            // Load autoAdvance
            if (settingsObj.has("autoAdvance")) {
                GeneralMenuSettings.setAutoAdvance(settingsObj.get("autoAdvance").getAsBoolean());
            }
            
            // Load expanded settings
            if (settingsObj.has("expandedSettings") && settingsObj.get("expandedSettings").isJsonArray()) {
                JsonArray expandedSettingsArray = settingsObj.getAsJsonArray("expandedSettings");
                MenuOverlayScreen.clearExpandedSettings();
                for (int i = 0; i < expandedSettingsArray.size(); i++) {
                    if (expandedSettingsArray.get(i).isJsonPrimitive()) {
                        MenuOverlayScreen.addExpandedSetting(expandedSettingsArray.get(i).getAsString());
                    }
                }
            }

            Craneshot.LOGGER.info("Loaded general settings configuration");
        } catch (IOException e) {
            Craneshot.LOGGER.error("Failed to load general settings", e);
        }
    }
}

================
File: client/java/ninja/trek/config/MenuOverlayScreen.java
================
package ninja.trek.config;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.Element;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.tooltip.Tooltip;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.CheckboxWidget;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;
import ninja.trek.CameraMovementRegistry;
import ninja.trek.Craneshot;
import ninja.trek.CraneshotClient;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.cameramovements.ICameraMovement;
import java.lang.reflect.Field;
import java.util.*;

public class MenuOverlayScreen extends Screen {
    private static final Map<Integer, Set<Integer>> expandedMovements = new HashMap<>();
    private static final Set<String> expandedSettings = new HashSet<>();
    private static final int MARGIN = 0;
    private static final int TAB_HEIGHT = 30;
    private static final int CONTENT_START_Y = TAB_HEIGHT - 10;
    private static final double SCROLL_SPEED = 10;
    private static boolean isMenuOpen = false;
    private int selectedTab = 0;
    private final List<SettingSlider> settingSliders = new ArrayList<>();
    private int scrollOffset = 0;
    private int maxScroll = 0;
    private int guiWidth;
    private int guiHeight;
    private int centerX;
    private int centerY;
    private int selectedMovementTypeIndex = 0;

    public MenuOverlayScreen() {
        super(Text.literal("CraneShot Settings"));
        isMenuOpen = false;
    }

    @Override
    protected void init() {
        this.guiWidth = this.width - (MARGIN * 2);
        this.guiHeight = this.height - (MARGIN * 2);
        this.centerX = MARGIN;
        this.centerY = MARGIN;
        int visibleStartY = centerY + CONTENT_START_Y+40;
        int visibleEndY = centerY + guiHeight+20;

        createTabButtons();

        int BUTTON_HEIGHT = 20;
        int MOVEMENT_SPACING = BUTTON_HEIGHT - 5;
        int MOVEMENT_ROW_HEIGHT = BUTTON_HEIGHT + 5;
        int SETTING_HEIGHT = BUTTON_HEIGHT + 5;

        if (selectedTab > 0) {
            int slotIndex = selectedTab - 1;
            createControlsBar(slotIndex, visibleStartY, BUTTON_HEIGHT);
            createMovementList(slotIndex, visibleStartY, visibleEndY, BUTTON_HEIGHT,
                    MOVEMENT_ROW_HEIGHT, MOVEMENT_SPACING, SETTING_HEIGHT);
        } else if (selectedTab == 0) {
            addGeneralSettings();
        }
    }

    private void createTabButtons() {
        int tabCount = CraneshotClient.MOVEMENT_MANAGER.getMovementCount() + 1;
        int tabWidth = Math.min(100, (guiWidth - 20) / tabCount);

        for (int i = 0; i <= CraneshotClient.MOVEMENT_MANAGER.getMovementCount(); i++) {
            int tabIndex = i;
            String tabName = (i == 0) ? "General" : "Slot " + i;
            Text buttonText = Text.literal(tabName);
            if (i != selectedTab) {
                buttonText = buttonText.copy().formatted(Formatting.GRAY);
            }

            ButtonWidget slotBtn = ButtonWidget.builder(buttonText, button -> switchTab(tabIndex))
                    .dimensions(centerX + (i * (tabWidth + 5)), centerY, tabWidth, 20)
                    .build();
            this.addDrawableChild(slotBtn);
        }
    }

    private void createControlsBar(int slotIndex, int visibleStartY, int BUTTON_HEIGHT) {
        // Remove the visibility check since these controls should always be visible
        int addButtonWidth = 60;
        int typeButtonWidth = 120;
        int clipboardButtonWidth = 40;
        int spacing = 10;

        // Add movement button
        this.addDrawableChild(ButtonWidget.builder(Text.literal("Add"), button -> addMovement(slotIndex))
                .dimensions(centerX + 10, centerY + CONTENT_START_Y, addButtonWidth, BUTTON_HEIGHT)
                .build());

        // Paste button
        this.addDrawableChild(ButtonWidget.builder(Text.literal("Paste"), button -> pasteMovement(slotIndex))
                .dimensions(centerX + addButtonWidth + spacing, centerY + CONTENT_START_Y, clipboardButtonWidth, BUTTON_HEIGHT)
                .build());

        // Movement type selector
        List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
        String currentTypeName = movements.isEmpty() ? "None" : movements.get(selectedMovementTypeIndex).getName();
        this.addDrawableChild(ButtonWidget.builder(Text.literal("Type: " + currentTypeName),
                        button -> cycleMovementType())
                .dimensions(centerX + addButtonWidth + clipboardButtonWidth + spacing * 2, centerY + CONTENT_START_Y,
                        typeButtonWidth, BUTTON_HEIGHT)
                .build());

        // Wrap checkbox
        this.addDrawableChild(CheckboxWidget.builder(Text.literal("Wrap"), this.textRenderer)
                .pos(centerX + addButtonWidth + clipboardButtonWidth + typeButtonWidth + spacing * 3, centerY + CONTENT_START_Y)
                .checked(SlotMenuSettings.getWrapState(slotIndex))
                .callback((checkbox, checked) -> SlotMenuSettings.setWrapState(slotIndex, checked))
                .build());

        // Toggle checkbox - add right after Wrap checkbox
        this.addDrawableChild(CheckboxWidget.builder(Text.literal("Toggle"), this.textRenderer)
                .pos(centerX + addButtonWidth + clipboardButtonWidth + typeButtonWidth + spacing * 3 + 100, centerY + CONTENT_START_Y)
                .checked(SlotMenuSettings.getToggleState(slotIndex))
                .callback((checkbox, checked) -> SlotMenuSettings.setToggleState(slotIndex, checked))
                .build());
    }
    private void createMovementControls(int slotIndex, int index, ICameraMovement movement, int rowY, int BUTTON_HEIGHT) {
        int controlX = centerX + 10;

        // Movement control buttons
        if (index > 0) {
            addDrawableChild(ButtonWidget.builder(Text.literal("↑"),
                            button -> moveMovement(slotIndex, index, index - 1))
                    .dimensions(controlX, rowY, 20, BUTTON_HEIGHT).build());
        }
        controlX += 25;

        if (index < CraneshotClient.MOVEMENT_MANAGER.getAvailableMovementsForSlot(slotIndex).size() - 1) {
            addDrawableChild(ButtonWidget.builder(Text.literal("↓"),
                            button -> moveMovement(slotIndex, index, index + 1))
                    .dimensions(controlX, rowY, 20, BUTTON_HEIGHT).build());
        }
        controlX += 25;

        if (CraneshotClient.MOVEMENT_MANAGER.getAvailableMovementsForSlot(slotIndex).size() > 1) {
            addDrawableChild(ButtonWidget.builder(Text.literal("×"),
                            button -> deleteMovement(slotIndex, index))
                    .dimensions(controlX, rowY, 20, BUTTON_HEIGHT).build());
        }
        controlX += 25;

        // Rename button
        if (movement instanceof AbstractMovementSettings settings) {
            addDrawableChild(ButtonWidget.builder(Text.literal("r"), button -> {
                        if (client != null) {
                            client.setScreen(new RenameModal(this, settings, this::reinitialize));
                        }
                    })
                    .dimensions(controlX, rowY, 20, BUTTON_HEIGHT)
                    .build());
            controlX += 25;
        }

        // Movement name/expand button
        int remainingWidth = Math.min(200, guiWidth / 3);
        String displayName = movement instanceof AbstractMovementSettings ?
                ((AbstractMovementSettings)movement).getDisplayName() :
                movement.getName();
        addDrawableChild(ButtonWidget.builder(
                        Text.literal((isMovementExpanded(slotIndex, index) ? "▼ " : "▶ ") + displayName),
                        button -> {
                            toggleMovementExpanded(slotIndex, index);
                            reinitialize();
                        })
                .dimensions(controlX, rowY, remainingWidth, BUTTON_HEIGHT)
                .build());

        // Copy button after the name
        controlX += remainingWidth + 5;
        addDrawableChild(ButtonWidget.builder(Text.literal("Copy"), button -> copyMovement(movement))
                .dimensions(controlX, rowY, 30, BUTTON_HEIGHT)
                .build());
    }

    private void addGeneralSettings() {
        int yOffset = CONTENT_START_Y + 20;
        int buttonWidth = 200;
        int buttonX = centerX +20;
        int spacing = 25;

        // Define the necessary dimensions
        int BUTTON_HEIGHT = 20;
        int totalWidth = guiWidth - 40;
        int labelWidth = Math.min(200, totalWidth / 3);
        int controlWidth = Math.min(200, totalWidth / 2);

        // Auto Advance Checkbox
        this.addDrawableChild(CheckboxWidget.builder(Text.literal("Auto Advance"), this.textRenderer)
                .pos(buttonX, centerY + yOffset)
                .checked(GeneralMenuSettings.isAutoAdvance())
                .callback((checkbox, checked) -> GeneralMenuSettings.setAutoAdvance(checked))
                .build());

        yOffset += spacing;
        
        // Add collapsible Free Camera section header
        String freeCamKey = "freeCamSection";
        boolean freeCamExpanded = isSettingsExpanded(freeCamKey);
        this.addDrawableChild(ButtonWidget.builder(
                Text.literal((freeCamExpanded ? "▼ " : "▶ ") + "Free Camera Settings").formatted(Formatting.YELLOW),
                button -> {
                    toggleSettingsExpanded(freeCamKey);
                    reinitialize();
                })
                .dimensions(buttonX, centerY + yOffset, buttonWidth, BUTTON_HEIGHT)
                .build());
        yOffset += spacing;
        
        if (freeCamExpanded) {
            // Move Speed Slider
            float currentSpeed = GeneralMenuSettings.getFreeCamSettings().getMoveSpeed();
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Free Camera Speed"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Free Camera Speed"),
                    0.1f,
                    2.0f,
                    currentSpeed,
                    "moveSpeed",
                    new AbstractMovementSettings() {
                        @Override
                        public void updateSetting(String key, Object value) {
                            if (key.equals("moveSpeed") && value instanceof Number) {
                                GeneralMenuSettings.getFreeCamSettings().setMoveSpeed(((Number)value).floatValue());
                            }
                        }
                    }
            ));

            yOffset += spacing;

            // Acceleration Slider
            float currentAcceleration = GeneralMenuSettings.getFreeCamSettings().getAcceleration();
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Acceleration"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Acceleration"),
                    0.01f,
                    0.5f,
                    currentAcceleration,
                    "acceleration",
                    new AbstractMovementSettings() {
                        @Override
                        public void updateSetting(String key, Object value) {
                            if (key.equals("acceleration") && value instanceof Number) {
                                GeneralMenuSettings.getFreeCamSettings().setAcceleration(((Number)value).floatValue());
                            }
                        }
                    }
            ));

            yOffset += spacing;

            // Deceleration Slider
            float currentDeceleration = GeneralMenuSettings.getFreeCamSettings().getDeceleration();
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Deceleration"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Deceleration"),
                    0.01f,
                    0.5f,
                    currentDeceleration,
                    "deceleration",
                    new AbstractMovementSettings() {
                        @Override
                        public void updateSetting(String key, Object value) {
                            if (key.equals("deceleration") && value instanceof Number) {
                                GeneralMenuSettings.getFreeCamSettings().setDeceleration(((Number)value).floatValue());
                            }
                        }
                    }
            ));

            yOffset += spacing;

            // Movement Mode Button
            FreeCamSettings.MovementMode currentMode = GeneralMenuSettings.getFreeCamSettings().getMovementMode();
            this.addDrawableChild(ButtonWidget.builder(
                            Text.literal("Movement Mode: " + currentMode.name()),
                            button -> {
                                FreeCamSettings.MovementMode[] modes =
                                        FreeCamSettings.MovementMode.values();
                                int nextOrdinal = (currentMode.ordinal() + 1) % modes.length;
                                GeneralMenuSettings.getFreeCamSettings().setMovementMode(modes[nextOrdinal]);
                                button.setMessage(Text.literal("Movement Mode: " + modes[nextOrdinal].name()));
                            })
                    .dimensions(buttonX, centerY + yOffset, buttonWidth, 20)
                    .build()
            );
        }
        
        // Add collapsible Free Camera Return section header
        yOffset += spacing;
        String freeCamReturnKey = "freeCamReturnSection";
        boolean freeCamReturnExpanded = isSettingsExpanded(freeCamReturnKey);
        this.addDrawableChild(ButtonWidget.builder(
                Text.literal((freeCamReturnExpanded ? "▼ " : "▶ ") + "Free Camera Return Settings").formatted(Formatting.YELLOW),
                button -> {
                    toggleSettingsExpanded(freeCamReturnKey);
                    reinitialize();
                })
                .dimensions(buttonX, centerY + yOffset, buttonWidth, BUTTON_HEIGHT)
                .build());
                
        if (freeCamReturnExpanded) {
            // Add settings for FreeCamReturnMovement
            yOffset += spacing;
            ninja.trek.cameramovements.movements.FreeCamReturnMovement freeCamReturn = GeneralMenuSettings.getFreeCamReturnMovement();
            
            // Position Easing slider
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Position Easing"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
                    
            // Use reflection to get the current value
            double positionEasing = 0.2; // Default value
            try {
                java.lang.reflect.Field field = freeCamReturn.getClass().getDeclaredField("positionEasing");
                field.setAccessible(true);
                positionEasing = (double)field.get(freeCamReturn);
            } catch (Exception e) {
                Craneshot.LOGGER.error("Failed to get positionEasing", e);
            }
            
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Position Easing"),
                    0.01f,
                    1.0f,
                    positionEasing,
                    "positionEasing",
                    (AbstractMovementSettings)freeCamReturn
            ));
            
            // Position Speed Limit slider
            yOffset += spacing;
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Position Speed Limit"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
                    
            // Use reflection to get the current value
            double positionSpeedLimit = 5.0; // Default value
            try {
                java.lang.reflect.Field field = freeCamReturn.getClass().getDeclaredField("positionSpeedLimit");
                field.setAccessible(true);
                positionSpeedLimit = (double)field.get(freeCamReturn);
            } catch (Exception e) {
                Craneshot.LOGGER.error("Failed to get positionSpeedLimit", e);
            }
            
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Position Speed Limit"),
                    0.1f,
                    20.0f,
                    positionSpeedLimit,
                    "positionSpeedLimit",
                    (AbstractMovementSettings)freeCamReturn
            ));
            
            // Rotation Easing slider
            yOffset += spacing;
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Rotation Easing"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
                    
            // Use reflection to get the current value
            double rotationEasing = 0.2; // Default value
            try {
                java.lang.reflect.Field field = freeCamReturn.getClass().getDeclaredField("rotationEasing");
                field.setAccessible(true);
                rotationEasing = (double)field.get(freeCamReturn);
            } catch (Exception e) {
                Craneshot.LOGGER.error("Failed to get rotationEasing", e);
            }
            
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Rotation Easing"),
                    0.01f,
                    1.0f,
                    rotationEasing,
                    "rotationEasing",
                    (AbstractMovementSettings)freeCamReturn
            ));
            
            // Rotation Speed Limit slider
            yOffset += spacing;
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Rotation Speed Limit"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
                    
            // Use reflection to get the current value
            double rotationSpeedLimit = 90.0; // Default value
            try {
                java.lang.reflect.Field field = freeCamReturn.getClass().getDeclaredField("rotationSpeedLimit");
                field.setAccessible(true);
                rotationSpeedLimit = (double)field.get(freeCamReturn);
            } catch (Exception e) {
                Craneshot.LOGGER.error("Failed to get rotationSpeedLimit", e);
            }
            
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Rotation Speed Limit"),
                    0.1f,
                    360.0f,
                    rotationSpeedLimit,
                    "rotationSpeedLimit",
                    (AbstractMovementSettings)freeCamReturn
            ));
        }
        
        // Update max scroll to handle the expanded/collapsed sections
        updateScrollBounds(yOffset + spacing);
    }
    private void createMovementList(int slotIndex, int visibleStartY, int visibleEndY,
                                    int BUTTON_HEIGHT, int MOVEMENT_ROW_HEIGHT, int MOVEMENT_SPACING, int SETTING_HEIGHT) {
        List<ICameraMovement> movements = CraneshotClient.MOVEMENT_MANAGER.getAvailableMovementsForSlot(slotIndex);
        int yOffset = CONTENT_START_Y + BUTTON_HEIGHT + 10;

        for (int i = 0; i < movements.size(); i++) {
            int index = i;
            ICameraMovement movement = movements.get(i);
            int rowY = centerY + yOffset - scrollOffset;

            if (rowY >= visibleStartY - BUTTON_HEIGHT && rowY <= visibleEndY) {
                createMovementControls(slotIndex, index, movement, rowY, BUTTON_HEIGHT);
            }

            yOffset += MOVEMENT_ROW_HEIGHT;

            if (movement instanceof AbstractMovementSettings settings && isMovementExpanded(slotIndex, index)) {
                yOffset = createSettingsSection(settings, rowY, yOffset, visibleStartY, visibleEndY,
                        BUTTON_HEIGHT, SETTING_HEIGHT, MOVEMENT_SPACING);
            } else {
                yOffset += MOVEMENT_SPACING;
            }
        }

        updateScrollBounds(yOffset);
    }

    private int createSettingsSection(AbstractMovementSettings settings, int rowY, int yOffset,
                                      int visibleStartY, int visibleEndY, int BUTTON_HEIGHT, int SETTING_HEIGHT, int MOVEMENT_SPACING) {
        List<Field> settingFields = new ArrayList<>();
        collectSettingFields(settings, settingFields);

        int totalWidth = guiWidth - 40;
        int labelWidth = Math.min(200, totalWidth / 3);  // Increased from 150 to 200
        int controlWidth = Math.min(200, totalWidth / 2);
        int settingWidth = labelWidth + controlWidth + 10;
        int columnsCount = Math.max(1, Math.min(3, (totalWidth + 20) / (settingWidth + 20)));
        int settingsPerColumn = (int) Math.ceil(settingFields.size() / (double) columnsCount);

        for (int fieldIndex = 0; fieldIndex < settingFields.size(); fieldIndex++) {
            Field field = settingFields.get(fieldIndex);
            MovementSetting annotation = field.getAnnotation(MovementSetting.class);
            field.setAccessible(true);
            try {
                int column = fieldIndex / settingsPerColumn;
                int row = fieldIndex % settingsPerColumn;
                int settingX = centerX + 20 + column * (settingWidth + 20);
                int settingY = centerY + yOffset + (row * SETTING_HEIGHT) - scrollOffset;

                if (settingY >= visibleStartY - BUTTON_HEIGHT && settingY <= visibleEndY) {
                    createSettingControl(settings, field, annotation, settingX, settingY,
                            labelWidth, controlWidth, BUTTON_HEIGHT);
                }
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        return yOffset + (settingsPerColumn * SETTING_HEIGHT) + MOVEMENT_SPACING;
    }

    private void createSettingControl(AbstractMovementSettings settings, Field field,
                                      MovementSetting annotation, int settingX, int settingY,
                                      int labelWidth, int controlWidth, int BUTTON_HEIGHT)
            throws IllegalAccessException {
        if (annotation.type() == MovementSettingType.ENUM) {
            // For enums, create the button
            ButtonWidget enumButton = SettingWidget.createEnumButton(
                    settingX,
                    settingY,
                    labelWidth + controlWidth + 10,
                    BUTTON_HEIGHT,
                    field.getName(),
                    settings,
                    annotation
            );
            addDrawableChild(enumButton);

            // Add warning if needed for postMoveMouse field
            if (field.getName().equals("postMoveMouse")) {
                AbstractMovementSettings.POST_MOVE_MOUSE mouseMode =
                        (AbstractMovementSettings.POST_MOVE_MOUSE) field.get(settings);

                // Get the postMoveKeys field
                try {
                    Field keysField = AbstractMovementSettings.class.getDeclaredField("postMoveKeys");
                    keysField.setAccessible(true);
                    AbstractMovementSettings.POST_MOVE_KEYS keysMode =
                            (AbstractMovementSettings.POST_MOVE_KEYS) keysField.get(settings);

                    // Check warning conditions - only show warning for camera movement modes
                    if (mouseMode == AbstractMovementSettings.POST_MOVE_MOUSE.NONE &&
                            (keysMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
                                    keysMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) &&
                            keysMode != AbstractMovementSettings.POST_MOVE_KEYS.MOVE8 &&
                            keysMode != AbstractMovementSettings.POST_MOVE_KEYS.NONE) {

                        // Create warning button
                        ButtonWidget warningButton = ButtonWidget.builder(
                                        Text.literal("!").formatted(Formatting.GOLD),
                                        button -> {}
                                )
                                .dimensions(settingX + labelWidth + controlWidth + 15, settingY, 20, BUTTON_HEIGHT)
                                .tooltip(Tooltip.of(Text.literal(
                                        "Warning: Camera rotation will be locked, Rotate Camera recommended")))
                                .build();

                        addDrawableChild(warningButton);
                    }
                } catch (Exception e) {
                    Craneshot.LOGGER.error("Error checking warning conditions", e);
                }
            }
        } else {
            // For non-enum settings, keep the original label + control layout
            addDrawableChild(ButtonWidget.builder(Text.literal(annotation.label()), button -> {})
                    .dimensions(settingX, settingY, labelWidth, BUTTON_HEIGHT)
                    .build());
            addDrawableChild(SettingWidget.createSlider(
                    settingX + labelWidth + 10,
                    settingY,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal(annotation.label()),
                    annotation.min(),
                    annotation.max(),
                    ((Number) field.get(settings)).doubleValue(),
                    field.getName(),
                    settings
            ));
        }
    }

    private void collectSettingFields(AbstractMovementSettings settings, List<Field> settingFields) {
        // Get fields from the concrete class
        for (Field field : settings.getClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(MovementSetting.class)) {
                settingFields.add(field);
            }
        }
        // Get fields from AbstractMovementSettings
        for (Field field : AbstractMovementSettings.class.getDeclaredFields()) {
            if (field.isAnnotationPresent(MovementSetting.class)) {
                settingFields.add(field);
            }
        }
    }

    private void updateScrollBounds(int yOffset) {
        int contentHeight = yOffset - (CONTENT_START_Y + 20);
        int visibleHeight = guiHeight - CONTENT_START_Y - 30; // Additional padding
        maxScroll = Math.max(0, contentHeight - visibleHeight);
    }



    // In MenuOverlayScreen.java
    private void cycleMovementType() {
        List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
        if (!movements.isEmpty()) {
            selectedMovementTypeIndex = (selectedMovementTypeIndex + 1) % movements.size();

            // Update the button text immediately
            for (Element child : this.children()) {
                if (child instanceof ButtonWidget button) {
                    String buttonText = button.getMessage().getString();
                    if (buttonText.startsWith("Type: ")) {
                        String currentTypeName = movements.get(selectedMovementTypeIndex).getName();
                        button.setMessage(Text.literal("Type: " + currentTypeName));
                        break;
                    }
                }
            }
        }
    }

    private void addMovement(int slotIndex) {
        List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
        if (!movements.isEmpty()) {
            try {
                ICameraMovement newMovement = movements.get(selectedMovementTypeIndex)
                        .getMovementClass()
                        .getDeclaredConstructor()
                        .newInstance();
                CraneshotClient.MOVEMENT_MANAGER.addMovement(slotIndex, newMovement);
                reinitialize();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public void resize(MinecraftClient client, int width, int height) {
        super.resize(client, width, height);
        this.scrollOffset = 0;
        this.reinitialize();
    }

    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        context.fill(0, 0, this.width, this.height, 0x80000000);
        context.fill(
                centerX,
                centerY + CONTENT_START_Y,
                centerX + guiWidth,
                centerY + guiHeight,
                0xC0000000
        );
        super.render(context, mouseX, mouseY, delta);
        if (maxScroll > 0) {
            if (scrollOffset > 0) {
                context.drawCenteredTextWithShadow(
                        this.textRenderer,
                        Text.literal("▲"),
                        centerX + guiWidth - 15,
                        centerY + CONTENT_START_Y,
                        0xFFFFFF
                );
            }
            if (scrollOffset < maxScroll) {
                context.drawCenteredTextWithShadow(
                        this.textRenderer,
                        Text.literal("▼"),
                        centerX + guiWidth - 15,
                        centerY + guiHeight - 15,
                        0xFFFFFF
                );
            }
        }
    }

    // Keep existing helper methods
    private boolean isMovementExpanded(int slotIndex, int movementIndex) {
        return expandedMovements.computeIfAbsent(slotIndex, k -> new HashSet<>()).contains(movementIndex);
    }

    private void toggleMovementExpanded(int slotIndex, int movementIndex) {
        Set<Integer> expanded = expandedMovements.computeIfAbsent(slotIndex, k -> new HashSet<>());
        if (!expanded.remove(movementIndex)) {
            expanded.add(movementIndex);
        }
    }
    
    // New methods for managing collapsible settings
    private boolean isSettingsExpanded(String settingsKey) {
        return expandedSettings.contains(settingsKey);
    }

    private void toggleSettingsExpanded(String settingsKey) {
        if (!expandedSettings.remove(settingsKey)) {
            expandedSettings.add(settingsKey);
        }
    }



    private void deleteMovement(int slotIndex, int movementIndex) {
        CraneshotClient.MOVEMENT_MANAGER.removeMovement(slotIndex, movementIndex);
        reinitialize();
    }

    private void moveMovement(int slotIndex, int fromIndex, int toIndex) {
        CraneshotClient.MOVEMENT_MANAGER.swapMovements(slotIndex, fromIndex, toIndex);
        reinitialize();
    }

    void reinitialize() {
        this.clearChildren();
        this.init();
    }

    @Override
    public boolean mouseScrolled(double mouseX, double mouseY, double horizontalAmount, double verticalAmount) {
        if (verticalAmount != 0) {
            scroll((int)(-verticalAmount * SCROLL_SPEED));
            return true;
        }
        return super.mouseScrolled(mouseX, mouseY, horizontalAmount, verticalAmount);
    }

    @Override
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        if (keyCode == CraneshotClient.toggleMenuKey.getDefaultKey().getCode()) {
            toggleMenu();
            return true;
        }

        // Close on ESC (256) or inventory key
        if (keyCode == 256 || (this.client != null && keyCode == this.client.options.inventoryKey.getDefaultKey().getCode())) {
            close();
            return true;
        }

        return super.keyPressed(keyCode, scanCode, modifiers);
    }

    private void scroll(int amount) {
        if (maxScroll > 0) {
            scrollOffset = Math.max(0, Math.min(scrollOffset + amount, maxScroll));
            clearChildren();
            init();
        }
    }

    private void switchTab(int index) {
        selectedTab = index;
        scrollOffset = 0;
        clearChildren();
        init();
    }

    public void toggleMenu() {
        MinecraftClient client = MinecraftClient.getInstance();
        if (isMenuOpen) {
            close();
        } else {
            client.setScreen(this);
            isMenuOpen = true;
        }
    }

    @Override
    public void close() {
        // Save the current slots configuration before closing
        List<List<ICameraMovement>> slots = new ArrayList<>();
        for (int i = 0; i < CraneshotClient.MOVEMENT_MANAGER.getMovementCount(); i++) {
            slots.add(CraneshotClient.MOVEMENT_MANAGER.getAvailableMovementsForSlot(i));
        }
        SlotSettingsIO.saveSlots(slots);
        GeneralSettingsIO.saveSettings();

        if (this.client != null) {
            this.client.setScreen(null);
        }
        isMenuOpen = false;
    }

    private void copyMovement(ICameraMovement movement) {
        SlotSettingsIO.copyMovementToClipboard(movement);
    }

    private void pasteMovement(int slotIndex) {
        try {
            ICameraMovement newMovement = SlotSettingsIO.createMovementFromClipboard();
            if (newMovement != null) {
                CraneshotClient.MOVEMENT_MANAGER.addMovement(slotIndex, newMovement);
                reinitialize();
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to paste movement", e);
        }
    }

    @Override
    public boolean shouldPause() {
        return false;
    }
    
    // Static methods for managing expanded settings
    public static Set<String> getExpandedSettings() {
        return expandedSettings;
    }
    
    public static void clearExpandedSettings() {
        expandedSettings.clear();
    }
    
    public static void addExpandedSetting(String key) {
        expandedSettings.add(key);
    }
}

================
File: client/java/ninja/trek/config/MovementSetting.java
================
package ninja.trek.config;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface MovementSetting {
    String label();
    String description() default "";
    double min() default 0;
    double max() default 100;
    MovementSettingType type() default MovementSettingType.SLIDER;
}

================
File: client/java/ninja/trek/config/MovementSettingType.java
================
package ninja.trek.config;

public enum MovementSettingType {
    SLIDER,
    ENUM
}

================
File: client/java/ninja/trek/config/RenameModal.java
================
package ninja.trek.config;

import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.TextFieldWidget;
import net.minecraft.text.Text;
import net.minecraft.client.gui.DrawContext;
import ninja.trek.cameramovements.AbstractMovementSettings;

public class RenameModal extends Screen {
    private final Screen parent;
    private final AbstractMovementSettings movement;
    private TextFieldWidget nameField;
    private final Runnable onComplete;
    private static final int MODAL_WIDTH = 200;
    private static final int MODAL_HEIGHT = 100;

    public RenameModal(Screen parent, AbstractMovementSettings movement, Runnable onComplete) {
        super(Text.literal("Rename Movement"));
        this.parent = parent;
        this.movement = movement;
        this.onComplete = onComplete;
    }

    @Override
    protected void init() {
        int centerX = width / 2;
        int centerY = height / 2;
        int modalLeft = centerX - MODAL_WIDTH / 2;
        int modalTop = centerY - MODAL_HEIGHT / 2;

        // Create text field
        nameField = new TextFieldWidget(
                textRenderer,
                modalLeft + 10,
                modalTop + 30,
                MODAL_WIDTH - 20,
                20,
                Text.literal("Name")
        );
        nameField.setText(movement.getDisplayName());
        nameField.setMaxLength(32);
        addSelectableChild(nameField);
        setInitialFocus(nameField);

        // Create buttons
        addDrawableChild(ButtonWidget.builder(Text.literal("Save"), button -> {
                    movement.setCustomName(nameField.getText());
                    if (onComplete != null) onComplete.run();
                    close();
                })
                .dimensions(modalLeft + 10, modalTop + MODAL_HEIGHT - 30, 80, 20)
                .build());

        addDrawableChild(ButtonWidget.builder(Text.literal("Cancel"), button -> close())
                .dimensions(modalLeft + MODAL_WIDTH - 90, modalTop + MODAL_HEIGHT - 30, 80, 20)
                .build());
    }

    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        if (parent != null) {
           // parent.render(context, mouseX, mouseY, delta);
        }
        super.render(context, mouseX, mouseY, delta);

        int centerX = width / 2;
        int centerY = height / 2;
        int modalLeft = centerX - MODAL_WIDTH / 2;
        int modalTop = centerY - MODAL_HEIGHT / 2;

        // Draw modal background
        context.fill(modalLeft, modalTop, modalLeft + MODAL_WIDTH, modalTop + MODAL_HEIGHT, 0xF0000000);
        context.fill(modalLeft + 1, modalTop + 1, modalLeft + MODAL_WIDTH - 1, modalTop + MODAL_HEIGHT - 1, 0xFF444444);

        // Draw title
        context.drawCenteredTextWithShadow(textRenderer, "Rename Movement", centerX, modalTop + 10, 0xFFFFFF);

        nameField.render(context, mouseX, mouseY, delta);

    }

    @Override
    public void close() {
        if (this.client != null) {
            this.client.setScreen(parent);
        }
    }

    @Override
    public boolean shouldPause() {
        return false;
    }
}

================
File: client/java/ninja/trek/config/SettingSlider.java
================
package ninja.trek.config;

import net.minecraft.client.gui.widget.SliderWidget;
import net.minecraft.text.Text;
import ninja.trek.cameramovements.AbstractMovementSettings;

class SettingSlider extends SliderWidget {
    private final double min;
    private final double max;
    private final String fieldName;
    private final AbstractMovementSettings settings;
    private final Text label;

    public SettingSlider(int x, int y, int width, int height, Text label,
                         double min, double max, double value, String fieldName, AbstractMovementSettings settings) {
        super(x, y, width, height, label, (value - min) / (max - min));
        this.min = min;
        this.max = max;
        this.fieldName = fieldName;
        this.settings = settings;
        this.label = label;
        updateMessage();
    }

    @Override
    protected void updateMessage() {
        setMessage(Text.literal(String.format("%.2f", getValue())));
    }

    @Override
    protected void applyValue() {
        double value = min + (max - min) * this.value;
        settings.updateSetting(fieldName, value);
    }

    public Text getLabel() {
        return label;
    }

    private double getValue() {
        return min + (max - min) * this.value;
    }
}

================
File: client/java/ninja/trek/config/SettingWidget.java
================
package ninja.trek.config;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.tooltip.Tooltip;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.SliderWidget;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;
import ninja.trek.Craneshot;
import ninja.trek.cameramovements.AbstractMovementSettings;

import java.lang.reflect.Field;

public class SettingWidget {

    // Add this to the SettingWidget class in SettingWidget.java

    private static ButtonWidget createWarningButton(int x, int y) {
        return ButtonWidget.builder(
                        Text.literal("!").formatted(Formatting.GOLD),
                        button -> {}  // Empty click handler since we're just showing tooltip
                )
                .dimensions(x, y, 20, 20)
                .tooltip(Tooltip.of(Text.literal("Warning: This configuration may cause view instability")))
                .build();
    }

    public static ButtonWidget[] createEnumButtonWithWarning(
            int x, int y, int width, int height,
            String fieldName, AbstractMovementSettings settings,
            MovementSetting annotation
    ) {
        ButtonWidget enumButton = createEnumButton(x, y, width, height, fieldName, settings, annotation);

        // Check if we need to show warning
        boolean showWarning = false;
        try {
            if (fieldName.equals("postMoveMouse")) {
                Field mouseField = settings.getClass().getDeclaredField("postMoveMouse");
                Field keysField = settings.getClass().getDeclaredField("postMoveKeys");
                mouseField.setAccessible(true);
                keysField.setAccessible(true);

                AbstractMovementSettings.POST_MOVE_MOUSE mouseMode =
                        (AbstractMovementSettings.POST_MOVE_MOUSE) mouseField.get(settings);
                AbstractMovementSettings.POST_MOVE_KEYS keysMode =
                        (AbstractMovementSettings.POST_MOVE_KEYS) keysField.get(settings);

                if (mouseMode == AbstractMovementSettings.POST_MOVE_MOUSE.NONE &&
                        (keysMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
                                keysMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE)) {
                    showWarning = true;
                }
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Error checking warning conditions", e);
        }

        if (showWarning) {
            ButtonWidget warningButton = createWarningButton(x + width + 5, y);
            return new ButtonWidget[]{enumButton, warningButton};
        } else {
            return new ButtonWidget[]{enumButton};
        }
    }

    public static ButtonWidget createEnumButton(int x, int y, int width, int height,
                                                String fieldName, AbstractMovementSettings settings,
                                                MovementSetting annotation) {
        try {
            Field field = null;
            try {
                field = settings.getClass().getDeclaredField(fieldName);
            } catch (NoSuchFieldException e) {
                try {
                    field = AbstractMovementSettings.class.getDeclaredField(fieldName);
                } catch (NoSuchFieldException ex) {
                    throw new IllegalStateException("Field not found: " + fieldName);
                }
            }

            if (!field.getType().isEnum()) {
                throw new IllegalStateException("Field is not an enum type: " + fieldName);
            }

            field.setAccessible(true);
            Object initialValue = field.get(settings);
            if (!(initialValue instanceof Enum<?>)) {
                throw new IllegalStateException("Field value is not an enum: " + fieldName);
            }

            Class<? extends Enum<?>> enumClass = (Class<? extends Enum<?>>) field.getType().asSubclass(Enum.class);
            Enum<?>[] enumConstants = enumClass.getEnumConstants();
            final Field finalField = field;

            // Create button with current value
            ButtonWidget button = ButtonWidget.builder(
                    Text.literal(formatButtonText(annotation.label(), initialValue.toString())),
                    btn -> {
                        try {
                            Enum<?> currentValue = (Enum<?>) finalField.get(settings);
                            int currentIndex = currentValue.ordinal();
                            int nextIndex = (currentIndex + 1) % enumConstants.length;
                            Enum<?> nextValue = enumConstants[nextIndex];

                            // Set the new value and update the settings
                            finalField.set(settings, nextValue);
                            settings.updateSetting(fieldName, nextValue.name());

                            // Update button text
                            btn.setMessage(Text.literal(formatButtonText(annotation.label(), nextValue.toString())));

                            // If this is either the postMoveMouse or postMoveKeys field, force a menu refresh to update warnings
                            if (fieldName.equals("postMoveMouse") || fieldName.equals("postMoveKeys")) {
                                if (MinecraftClient.getInstance().currentScreen instanceof MenuOverlayScreen menuScreen) {
                                    menuScreen.reinitialize();
                                }
                            }
                        } catch (IllegalAccessException e) {
                            Craneshot.LOGGER.error("Failed to update enum setting", e);
                        }
                    }
            ).dimensions(x, y, width, height).build();

            return button;
        } catch (Exception e) {
            Craneshot.LOGGER.error("Error creating enum button", e);
            return null;
        }
    }




    private static String formatButtonText(String label, String value) {
        // Convert SNAKE_CASE to Title Case and format nicely
        String formattedValue = value.toLowerCase()
                .replace('_', ' ')
                .trim();
        formattedValue = Character.toUpperCase(formattedValue.charAt(0)) +
                formattedValue.substring(1);
        return label + ": " + formattedValue;
    }

    public static SliderWidget createSlider(int x, int y, int width, int height, Text label,
                                            double min, double max, double value, String fieldName, AbstractMovementSettings settings) {
        return new SettingSlider(x, y, width, height, label, min, max, value, fieldName, settings);
    }
}

================
File: client/java/ninja/trek/config/SlotMenuSettings.java
================
package ninja.trek.config;

import java.util.HashMap;
import java.util.Map;

public class SlotMenuSettings {
    private static final Map<Integer, Boolean> wrapStates = new HashMap<>();
    private static final Map<Integer, Boolean> toggleStates = new HashMap<>();

    public static boolean getWrapState(int slotIndex) {
        return wrapStates.getOrDefault(slotIndex, false);
    }

    public static void setWrapState(int slotIndex, boolean state) {
        wrapStates.put(slotIndex, state);
    }

    public static boolean getToggleState(int slotIndex) {
        return toggleStates.getOrDefault(slotIndex, false);
    }

    public static void setToggleState(int slotIndex, boolean state) {
        toggleStates.put(slotIndex, state);
    }
}

================
File: client/java/ninja/trek/config/SlotSettingsIO.java
================
package ninja.trek.config;

import com.google.gson.*;
import net.minecraft.client.MinecraftClient;
import ninja.trek.Craneshot;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.movements.LinearMovement;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class SlotSettingsIO {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_slots.json");
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .registerTypeAdapter(ICameraMovement.class, new CameraMovementSerializer())
            .create();

    public static JsonObject movementToJson(ICameraMovement movement) {
        JsonObject movementObj = new JsonObject();
        movementObj.addProperty("type", movement.getClass().getName());

        if (movement instanceof AbstractMovementSettings settings) {
            JsonObject settingsObj = new JsonObject();
            for (Map.Entry<String, Object> entry : settings.getSettings().entrySet()) {
                if (entry.getValue() != null) {
                    settingsObj.addProperty(entry.getKey(), entry.getValue().toString());
                }
            }
            movementObj.add("settings", settingsObj);
        }

        return movementObj;
    }

    public static void saveSlots(List<List<ICameraMovement>> slots) {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            JsonArray slotsArray = new JsonArray();

            for (List<ICameraMovement> slot : slots) {
                JsonArray slotArray = new JsonArray();
                for (ICameraMovement movement : slot) {
                    slotArray.add(movementToJson(movement));
                }
                slotsArray.add(slotArray);
            }

            GSON.toJson(slotsArray, writer);
            Craneshot.LOGGER.info("Saved camera movement slots configuration");
        } catch (IOException e) {
            Craneshot.LOGGER.error("Failed to save camera movement slots", e);
        }
    }

    public static ICameraMovement jsonToMovement(JsonObject movementObj) {
        String type = movementObj.get("type").getAsString();

        try {
            Class<?> movementClass = Class.forName(type);
            Constructor<?> constructor = movementClass.getDeclaredConstructor();
            ICameraMovement movement = (ICameraMovement) constructor.newInstance();

            if (movement instanceof AbstractMovementSettings settings &&
                    movementObj.has("settings")) {
                JsonObject settingsObj = movementObj.getAsJsonObject("settings");
                for (Map.Entry<String, JsonElement> entry : settingsObj.entrySet()) {
                    String value = entry.getValue().getAsString();
                    settings.updateSetting(entry.getKey(), value);
                }
            }

            return movement;
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to load movement: " + type, e);
            // Return default movement if loading fails
            return new LinearMovement();
        }
    }

    public static List<List<ICameraMovement>> loadSlots() {
        List<List<ICameraMovement>> slots = new ArrayList<>();

        if (!CONFIG_FILE.exists()) {
            // Return default configuration with one EasingMovement per slot
            for (int i = 0; i < 3; i++) {
                List<ICameraMovement> slot = new ArrayList<>();
                slot.add(new LinearMovement());
                slots.add(slot);
            }
            return slots;
        }

        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            JsonArray slotsArray = JsonParser.parseReader(reader).getAsJsonArray();

            for (JsonElement slotElement : slotsArray) {
                List<ICameraMovement> slot = new ArrayList<>();
                JsonArray slotArray = slotElement.getAsJsonArray();

                for (JsonElement movementElement : slotArray) {
                    JsonObject movementObj = movementElement.getAsJsonObject();
                    slot.add(jsonToMovement(movementObj));
                }

                slots.add(slot);
            }

            Craneshot.LOGGER.info("Loaded camera movement slots configuration");
        } catch (IOException e) {
            Craneshot.LOGGER.error("Failed to load camera movement slots", e);
            // Return default configuration on error
            for (int i = 0; i < 3; i++) {
                List<ICameraMovement> slot = new ArrayList<>();
                slot.add(new LinearMovement());
                slots.add(slot);
            }
        }

        return slots;
    }

    public static void copyMovementToClipboard(ICameraMovement movement) {
        try {
            JsonObject movementJson = movementToJson(movement);
            String jsonStr = GSON.toJson(movementJson);

            // Use Minecraft's clipboard handling
            MinecraftClient.getInstance().keyboard.setClipboard(jsonStr);
            Craneshot.LOGGER.info("Copied movement settings to clipboard");
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to copy movement settings", e);
        }
    }

    public static ICameraMovement createMovementFromClipboard() {
        try {
            // Use Minecraft's clipboard handling
            String clipboardText = MinecraftClient.getInstance().keyboard.getClipboard();
            JsonObject movementObj = JsonParser.parseString(clipboardText).getAsJsonObject();
            return jsonToMovement(movementObj);
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to create movement from clipboard", e);
            return new LinearMovement(); // Return default movement if parsing fails
        }
    }

    private static class CameraMovementSerializer implements JsonSerializer<ICameraMovement> {
        @Override
        public JsonElement serialize(ICameraMovement movement, java.lang.reflect.Type typeOfSrc, JsonSerializationContext context) {
            return movementToJson(movement);
        }
    }
}

================
File: client/java/ninja/trek/config/WrapSettings.java
================
package ninja.trek.config;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.client.MinecraftClient;

import java.io.*;
import java.util.HashMap;
import java.util.Map;

public class WrapSettings {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_wrap.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static Map<Integer, Boolean> wrapStates = new HashMap<>();

    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) return;
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            wrapStates = GSON.fromJson(reader, Map.class);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void saveSettings() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(wrapStates, writer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static boolean getWrapState(int slotIndex) {
        return wrapStates.getOrDefault(slotIndex, false);
    }

    public static void setWrapState(int slotIndex, boolean state) {
        wrapStates.put(slotIndex, state);
        saveSettings();
    }
}

================
File: client/java/ninja/trek/CraneshotClient.java
================
package ninja.trek;

import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.client.util.InputUtil;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.config.GeneralSettingsIO;
import ninja.trek.config.MenuOverlayScreen;
import ninja.trek.config.SlotSettingsIO;
import org.lwjgl.glfw.GLFW;

import java.util.List;


public class CraneshotClient implements ClientModInitializer {
	public static KeyBinding[] cameraKeyBinds;
	public static KeyBinding selectMovementType;
	public static KeyBinding toggleOrthographicMode;
	public static final CameraController CAMERA_CONTROLLER = new CameraController();
	public static KeyBinding toggleMenuKey;
	private static boolean isMenuOpen = false;
	public static MenuOverlayScreen MENU = new MenuOverlayScreen();
	public static final CameraMovementManager MOVEMENT_MANAGER = new CameraMovementManager();

	@Override
	public void onInitializeClient() {

		toggleMenuKey = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.toggle_menu",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_Z,
				"category.craneshot.ui"
		));

		selectMovementType = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.select_movement",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_X,
				"category.craneshot.camera"
		));
		
		toggleOrthographicMode = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.toggle_orthographic",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_O,
				"category.craneshot.camera"
		));

		cameraKeyBinds = new KeyBinding[]{
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera1",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_C,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera2",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_V,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera3",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_B,
						"category.craneshot.camera"
				))
		};
		CameraMovementRegistry.initialize();
		GeneralSettingsIO.loadSettings();

		List<List<ICameraMovement>> savedSlots = SlotSettingsIO.loadSlots();
		MOVEMENT_MANAGER.setAllSlots(savedSlots);
		CraneShotEventHandler.register();
	}
	public static void checkKeybinds() {
		if (toggleMenuKey.wasPressed()) {
			MENU.toggleMenu();
		}
		
		if (toggleOrthographicMode.wasPressed()) {
			boolean isOrthoEnabled = OrthographicCameraManager.toggleOrthographicMode();
			// Print a message to the player's chat to indicate the mode change
			ninja.trek.Craneshot.LOGGER.info("Orthographic camera mode: " + (isOrthoEnabled ? "enabled" : "disabled"));
		}
	}

}

================
File: client/java/ninja/trek/CraneshotDataGenerator.java
================
package ninja.trek;

import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;

public class CraneshotDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {

	}
}

================
File: client/java/ninja/trek/CraneShotEventHandler.java
================
package ninja.trek;

import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.config.SlotMenuSettings;

import java.util.HashMap;
import java.util.Map;

public class CraneShotEventHandler {
    private static final double SCROLL_COOLDOWN = 0.1;
    private static double lastScrollTime = 0;
    private static final Map<Integer, Boolean> keyStates = new HashMap<>();
    private static Integer lastActiveSlot = null;

    public static void register() {
        ClientTickEvents.END_CLIENT_TICK.register(client -> {
            handleScrollInput(client);
            CraneshotClient.checkKeybinds();
        });

        MovementToastRenderer.register();

        WorldRenderEvents.START.register(context -> {
            MinecraftClient client = MinecraftClient.getInstance();
            Camera camera = client.gameRenderer.getCamera();

            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                boolean currentlyPressed = CraneshotClient.cameraKeyBinds[i].isPressed();
                boolean wasPressed = keyStates.getOrDefault(i, false);

                if (currentlyPressed != wasPressed) {
                    boolean isToggle = SlotMenuSettings.getToggleState(i);
                    CraneshotClient.MOVEMENT_MANAGER.handleKeyStateChange(i, currentlyPressed, client, camera, isToggle);
                    if (currentlyPressed) {
                        lastActiveSlot = i;
                    }
                }
                keyStates.put(i, currentlyPressed);
            }
        });
    }

    /**
     * Safely get the scroll value from the mouse mixin
     * @param client The Minecraft client instance
     * @return The scroll value, or 0 if it couldn't be accessed
     */
    private static double getScrollValue(MinecraftClient client) {
        try {
            if (client.mouse instanceof IMouseMixin mouseMixin) {
                return mouseMixin.getLastScrollValue();
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Error accessing mouse mixin: " + e.getMessage());
        }
        return 0;
    }
    
    /**
     * Safely reset the scroll value in the mouse mixin
     * @param client The Minecraft client instance
     */
    private static void resetScrollValue(MinecraftClient client) {
        try {
            if (client.mouse instanceof IMouseMixin mouseMixin) {
                mouseMixin.setLastScrollValue(0);
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Error resetting scroll value: " + e.getMessage());
        }
    }

    private static void handleScrollInput(MinecraftClient client) {
        double currentTime = System.currentTimeMillis() / 1000.0;
        if (currentTime - lastScrollTime < SCROLL_COOLDOWN) {
            return;
        }

        double scrollDelta = getScrollValue(client);
        if (scrollDelta == 0) {
            return;
        }

        boolean scrollUp = scrollDelta < 0;

        // Check for active movement with scroll modes
        AbstractMovementSettings.SCROLL_WHEEL activeScrollMode =
                CraneshotClient.MOVEMENT_MANAGER.getActiveMouseWheelMode();
        ICameraMovement activeMovement = CraneshotClient.MOVEMENT_MANAGER.getActiveMovement();

        if (activeMovement != null) {
            if (activeScrollMode == AbstractMovementSettings.SCROLL_WHEEL.DISTANCE) {
                activeMovement.adjustDistance(!scrollUp, client);
                lastScrollTime = currentTime;
                resetScrollValue(client);
                return;
            } else if (activeScrollMode == AbstractMovementSettings.SCROLL_WHEEL.FOV) {
                if (activeMovement instanceof AbstractMovementSettings) {
                    ((AbstractMovementSettings) activeMovement).adjustFov(!scrollUp, client);
                    lastScrollTime = currentTime;
                    resetScrollValue(client);
                    return;
                }
            }
        }

        // Handle orthographic camera zoom if in orthographic mode
        if (OrthographicCameraManager.isOrthographicMode()) {
            // Use shift key as a modifier for orthographic zoom
            boolean shiftPressed = client.options.sneakKey.isPressed();
            if (shiftPressed) {
                if (scrollUp) {
                    OrthographicCameraManager.zoomIn();
                } else {
                    OrthographicCameraManager.zoomOut();
                }
                lastScrollTime = currentTime;
                resetScrollValue(client);
                return;
            }
        }
        
        // Handle normal slot scrolling if no active scroll modes
        for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
            if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                CraneshotClient.MOVEMENT_MANAGER.handleMouseScroll(i, scrollUp);
                lastScrollTime = currentTime;
                resetScrollValue(client);
                return;
            }
        }

        // Handle scroll with select movement key pressed
        if (CraneshotClient.selectMovementType.isPressed() && lastActiveSlot != null) {
            CraneshotClient.MOVEMENT_MANAGER.handleMouseScroll(lastActiveSlot, scrollUp);
            lastScrollTime = currentTime;
            resetScrollValue(client);
        }
    }
}

================
File: client/java/ninja/trek/IKeyboardInputMixin.java
================
package ninja.trek;

public interface IKeyboardInputMixin {
    void setDisabled(boolean disabled);
}

================
File: client/java/ninja/trek/IMouseMixin.java
================
package ninja.trek;

public interface IMouseMixin {
    double getCapturedDeltaX();
    double getCapturedDeltaY();
    double getLastScrollValue();
    void setLastScrollValue(double value);
}

================
File: client/java/ninja/trek/mixin/client/CameraAccessor.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.render.Camera;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.BlockView;
import ninja.trek.CraneshotClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import org.spongepowered.asm.mixin.gen.Invoker;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

// CameraAccessor.java
@Mixin(Camera.class)
public interface CameraAccessor {
    @Accessor("pos")
    void invokesetPos(Vec3d pos);

    @Accessor("pos")
    Vec3d getPos();

    @Invoker("setRotation")
    void invokeSetRotation(float yaw, float pitch);
}

================
File: client/java/ninja/trek/mixin/client/CameraMixin.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.render.Camera;
import net.minecraft.entity.Entity;
import net.minecraft.world.BlockView;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.option.Perspective;
import ninja.trek.CameraController;
import ninja.trek.CraneshotClient;
import ninja.trek.OrthographicCameraManager;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

// CameraMixin.java
@Mixin(Camera.class)
public class CameraMixin {
    @Inject(method = "update", at = @At("TAIL"))
    private void onCameraUpdate(BlockView area, Entity focusedEntity, boolean thirdPerson,
                                boolean inverseView, float tickDelta, CallbackInfo ci) {
        CraneshotClient.CAMERA_CONTROLLER.handleCameraUpdate(area, focusedEntity, thirdPerson, inverseView, tickDelta, (Camera)(Object)this);
    }
}

================
File: client/java/ninja/trek/mixin/client/CameraSubmersionMixin.java
================
package ninja.trek.mixin.client;

import net.minecraft.block.enums.CameraSubmersionType;
import net.minecraft.client.render.Camera;
import net.minecraft.client.MinecraftClient;
import ninja.trek.CameraController;
import ninja.trek.OrthographicCameraManager;
import ninja.trek.camera.CameraSystem;
import ninja.trek.cameramovements.AbstractMovementSettings;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

@Mixin(Camera.class)
public class CameraSubmersionMixin {
    /**
     * Prevents fluid fog when in freecam mode with shift held
     */
    @Inject(method = "getSubmersionType", at = @At("HEAD"), cancellable = true)
    private void disableFluidFog(CallbackInfoReturnable<CameraSubmersionType> cir) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client != null && client.options != null && client.options.sneakKey.isPressed()) {
            // Check if camera system is active
            CameraSystem cameraSystem = CameraSystem.getInstance();
            if (cameraSystem.isCameraActive()) {
                cir.setReturnValue(CameraSubmersionType.NONE);
                return;
            }
            
            // Legacy camera mode check
            boolean isSpecialCameraMode = 
                CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE ||
                CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
                OrthographicCameraManager.isOrthographicMode() ||
                CameraController.currentEndTarget == AbstractMovementSettings.END_TARGET.HEAD_BACK ||
                CameraController.currentEndTarget == AbstractMovementSettings.END_TARGET.VELOCITY_BACK ||
                CameraController.currentEndTarget == AbstractMovementSettings.END_TARGET.FIXED_BACK;
                
            if (isSpecialCameraMode) {
                cir.setReturnValue(CameraSubmersionType.NONE);
            }
        }
    }
}

================
File: client/java/ninja/trek/mixin/client/ExampleClientMixin.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}

================
File: client/java/ninja/trek/mixin/client/FovAccessor.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.render.GameRenderer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;

@Mixin(GameRenderer.class)
public interface FovAccessor {
    @Accessor("fovMultiplier")
    float getFovModifier();

    @Accessor("fovMultiplier")
    void setFovModifier(float modifier);

    @Accessor("lastFovMultiplier")
    float getLastFovModifier();

    @Accessor("lastFovMultiplier")
    void setLastFovModifier(float modifier);
}

================
File: client/java/ninja/trek/mixin/client/FrustumMixin.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.render.Frustum;
import net.minecraft.util.math.Box;
import ninja.trek.OrthographicCameraManager;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

/**
 * This mixin completely disables frustum culling for orthographic camera mode
 * by making all boxes visible regardless of their position relative to the frustum.
 */
@Mixin(Frustum.class)
public class FrustumMixin {
    
    /**
     * Force frustum.isVisible(Box) to always return true in orthographic mode
     */
    @Inject(method = "isVisible(Lnet/minecraft/util/math/Box;)Z", at = @At("HEAD"), cancellable = true)
    private void alwaysVisibleInOrthoMode(Box box, CallbackInfoReturnable<Boolean> cir) {
        // If we're in orthographic mode, everything is always visible
        if (OrthographicCameraManager.isOrthographicMode()) {
            cir.setReturnValue(true);
        }
    }
}

================
File: client/java/ninja/trek/mixin/client/GameRendererAccessor.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.render.GameRenderer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;

/**
 * Accessor for GameRenderer's private fields.
 */
@Mixin(GameRenderer.class)
public interface GameRendererAccessor {
    /**
     * Gets the zoom level.
     */
    @Accessor("zoom")
    float getZoom();

    /**
     * Gets the zoom X offset.
     */
    @Accessor("zoomX")
    float getZoomX();

    /**
     * Gets the zoom Y offset.
     */
    @Accessor("zoomY")
    float getZoomY();
}

================
File: client/java/ninja/trek/mixin/client/GameRendererMixin.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.client.render.GameRenderer;
import ninja.trek.OrthographicCameraManager;
import ninja.trek.camera.CameraSystem;
import org.joml.Matrix4f;
import org.spongepowered.asm.mixin.Final;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

/**
 * Mixin for GameRenderer to handle block outline rendering in orthographic mode
 * and to control hand rendering based on camera distance
 */
@Mixin(GameRenderer.class)
public class GameRendererMixin {
    
    @Shadow @Final private MinecraftClient client;
    
    /**
     * Control block outline rendering in orthographic mode
     * This injection targets the private shouldRenderBlockOutline method
     */
    @Inject(method = "shouldRenderBlockOutline", at = @At("RETURN"), cancellable = true)
    private void forceRenderBlockOutline(CallbackInfoReturnable<Boolean> cir) {
        // In orthographic mode, we want to ensure block outlines are visible
        // This helps with block selection and visualization
        if (OrthographicCameraManager.isOrthographicMode()) {
            // Enable block outlines in orthographic mode
            cir.setReturnValue(true);
        }
    }
    
    /**
     * Control hand rendering based on camera distance threshold
     * If camera is closer than threshold, render hands; if further, don't render hands
     */
    @Inject(method = "renderHand", at = @At("HEAD"), cancellable = true)
    private void onRenderHand(Camera camera, float tickDelta, Matrix4f matrix4f, CallbackInfo ci) {
        CameraSystem cameraSystem = CameraSystem.getInstance();
        
        // Cancel hand rendering if camera system is active and says not to render hands
        if (cameraSystem.isCameraActive() && !cameraSystem.shouldRenderHands()) {
            ci.cancel();
        }
    }
}

================
File: client/java/ninja/trek/mixin/client/InputAccessor.java
================
package ninja.trek.mixin.client;

// This file is intentionally left empty to be deleted
// It is no longer needed after the refactoring for 1.21.5

================
File: client/java/ninja/trek/mixin/client/KeyboardInputMixin.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.input.Input;
import net.minecraft.client.input.KeyboardInput;
import net.minecraft.util.PlayerInput;
import net.minecraft.util.math.Vec2f;
import ninja.trek.IKeyboardInputMixin;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

@Mixin(KeyboardInput.class)
public abstract class KeyboardInputMixin extends Input implements IKeyboardInputMixin {
    private boolean disabled = false;
    private PlayerInput savedInput;
    private Vec2f savedMovementVector;

    @Override
    public void setDisabled(boolean disabled) {
        if (this.disabled != disabled) {
            if (disabled) {
                // Store current state when disabling
                this.savedInput = this.playerInput;
                this.savedMovementVector = this.movementVector;

                // Immediately clear all movement
                this.playerInput = PlayerInput.DEFAULT;
                this.movementVector = Vec2f.ZERO;
            }
            this.disabled = disabled;
        }
    }

    @Inject(method = "tick", at = @At("HEAD"), cancellable = true)
    private void onTick(CallbackInfo ci) {
        if (disabled) {
            // Force all movement values to zero
            this.playerInput = PlayerInput.DEFAULT;
            this.movementVector = Vec2f.ZERO;
            ci.cancel();
        } else if (savedInput != null) {
            // Restore saved state when not disabled
            this.playerInput = this.savedInput;
            this.movementVector = this.savedMovementVector;
        }
    }
}

================
File: client/java/ninja/trek/mixin/client/MinecraftClientCameraMixin.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.MinecraftClient;
import net.minecraft.entity.Entity;
import ninja.trek.CameraController;
import ninja.trek.camera.CameraSystem;
import ninja.trek.cameramovements.AbstractMovementSettings;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

/**
 * Intercepts setCameraEntity calls in MinecraftClient to prevent vanilla from taking control
 */
@Mixin(MinecraftClient.class)
public class MinecraftClientCameraMixin {

    /**
     * This critical mixin prevents the vanilla game from setting the camera entity
     * when our custom camera system should be in control.
     */
    @Inject(method = "setCameraEntity", at = @At("HEAD"), cancellable = true)
    private void onSetCameraEntity(Entity entity, CallbackInfo ci) {
        CameraSystem cameraSystem = CameraSystem.getInstance();
        
        // If camera should be in ANY custom mode, prevent vanilla from setting the camera entity
        if (isCustomCameraActive()) {
            if (entity != null) {
                ci.cancel(); // Prevent the vanilla method from executing
                
                // Force to null if needed
                MinecraftClient mc = (MinecraftClient)(Object)this;
                if (mc.getCameraEntity() != null) {
                    // We have to use reflection or something similar here 
                    // since we can't directly set the field as it's private
                    // For now, we'll leave this part and rely on the camera update cycle
                    ninja.trek.Craneshot.LOGGER.info("Blocking attempt to set camera entity to: {}", entity);
                }
            }
        }
    }
    
    /**
     * Determine if our custom camera control should be active
     */
    private boolean isCustomCameraActive() {
        // Check if camera system is already active
        if (CameraSystem.getInstance().isCameraActive()) {
            return true;
        }
        
        // Check for free camera movement modes
        boolean isFreeCameraMode = 
            CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE || 
            CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT;
            
        // Check for mouse rotation mode
        boolean isMouseRotationMode = 
            CameraController.currentMouseMoveMode == AbstractMovementSettings.POST_MOVE_MOUSE.ROTATE_CAMERA;
            
        return isFreeCameraMode || isMouseRotationMode;
    }
}

================
File: client/java/ninja/trek/mixin/client/MinecraftClientMixin.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.MinecraftClient;
import ninja.trek.CameraController;
import ninja.trek.OrthographicCameraManager;
import ninja.trek.camera.CameraSystem;
import ninja.trek.cameramovements.AbstractMovementSettings;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

@Mixin(MinecraftClient.class)
public class MinecraftClientMixin {
    @Shadow public boolean chunkCullingEnabled;
    private boolean wasChunkCullingEnabled = true;

    /**
     * Disables chunk culling for special camera modes to ensure all chunks render correctly
     */
    @Inject(method = "tick", at = @At("HEAD"))
    private void updateChunkCullingOnTickStart(CallbackInfo ci) {
        // For orthographic mode, we disable culling at the start of every tick
        // This ensures it's always disabled, even if something else tries to enable it
        if (OrthographicCameraManager.isOrthographicMode()) {
            if (this.chunkCullingEnabled) {
                wasChunkCullingEnabled = true;
                this.chunkCullingEnabled = false;
            }
        }
    }

    /**
     * Disables chunk culling for special camera modes to ensure all chunks render correctly
     */
    @Inject(method = "tick", at = @At("TAIL"))
    private void updateChunkCulling(CallbackInfo ci) {
        // Check if we need to force chunk culling off
        boolean shouldDisableCulling = false;
        
        // Check new camera system state
        CameraSystem cameraSystem = CameraSystem.getInstance();
        if (cameraSystem.isCameraActive()) {
            shouldDisableCulling = true;
        }
        
        // Check orthographic mode - this should ALWAYS disable culling
        if (OrthographicCameraManager.isOrthographicMode()) {
            shouldDisableCulling = true;
        }
        
        // Check legacy camera modes
        boolean isLegacyCameraActive = 
            CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE ||
            CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
            CameraController.currentEndTarget == AbstractMovementSettings.END_TARGET.HEAD_BACK ||
            CameraController.currentEndTarget == AbstractMovementSettings.END_TARGET.VELOCITY_BACK ||
            CameraController.currentEndTarget == AbstractMovementSettings.END_TARGET.FIXED_BACK;
            
        if (isLegacyCameraActive) {
            shouldDisableCulling = true;
        }
        
        // Disable chunk culling when needed
        if (shouldDisableCulling) {
            if (this.chunkCullingEnabled) {
                wasChunkCullingEnabled = true;
                this.chunkCullingEnabled = false;
            }
        } else if (!this.chunkCullingEnabled && wasChunkCullingEnabled) {
            // Reset to default when not in special camera mode
            this.chunkCullingEnabled = true;
        }
    }
}

================
File: client/java/ninja/trek/mixin/client/MouseAccessor.java
================
package ninja.trek.mixin.client;

import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import net.minecraft.client.Mouse;

@Mixin(Mouse.class)
public interface MouseAccessor {
    @Accessor("cursorDeltaX")
    double getCursorDeltaX();

    @Accessor("cursorDeltaY")
    double getCursorDeltaY();

    @Accessor("cursorDeltaX")
    void setCursorDeltaX(double value);

    @Accessor("cursorDeltaY")
    void setCursorDeltaY(double value);
}

================
File: client/java/ninja/trek/mixin/client/MouseMixin.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.Mouse;
import ninja.trek.Craneshot;
import ninja.trek.CraneshotClient;
import ninja.trek.IMouseMixin;
import ninja.trek.MouseInterceptor;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

@Mixin(Mouse.class)
public class MouseMixin implements IMouseMixin {
    @Shadow private double cursorDeltaX;
    @Shadow private double cursorDeltaY;
    
    private double capturedDeltaX;
    private double capturedDeltaY;
    private double lastScrollValue;

    @Inject(method = "onMouseScroll", at = @At("HEAD"), cancellable = true)
    private void onMouseScroll(long window, double horizontal, double vertical, CallbackInfo ci) {
        MinecraftClient client = MinecraftClient.getInstance();

        // Always allow scrolling if any screen is open (game menu, mod menu, etc)
        if (client.currentScreen != null) {
            return;
        }

        // Otherwise, check if we should intercept
        boolean shouldIntercept = CraneshotClient.MOVEMENT_MANAGER.hasActiveMovement();

        // Also intercept if any camera slot key or select movement key is pressed
        if (!shouldIntercept) {
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    shouldIntercept = true;
                    break;
                }
            }
            if (CraneshotClient.selectMovementType.isPressed()) {
                shouldIntercept = true;
            }
        }

        // If we should intercept this scroll, store the value BEFORE cancelling
        if (shouldIntercept) {
            this.lastScrollValue = vertical * 15.0; // Match Minecraft's scroll multiplier
            ci.cancel();
        }
    }

    @Inject(method = "updateMouse", at = @At("HEAD"), cancellable = true)
    private void onUpdateMouse(CallbackInfo ci) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (MouseInterceptor.isIntercepting() && client.currentScreen == null) {
            capturedDeltaX = cursorDeltaX;
            capturedDeltaY = cursorDeltaY;
            cursorDeltaX = 0;
            cursorDeltaY = 0;
            ci.cancel();
        }
    }

    @Inject(method = "onMouseButton", at = @At("HEAD"), cancellable = true)
    private void onMouseButton(long window, int button, int action, int mods, CallbackInfo ci) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (MouseInterceptor.isIntercepting() && client.currentScreen == null) {
            ci.cancel();
        }
    }

    @Override
    public double getCapturedDeltaX() {
        return capturedDeltaX;
    }

    @Override
    public double getCapturedDeltaY() {
        return capturedDeltaY;
    }
    
    @Override
    public double getLastScrollValue() {
        return lastScrollValue;
    }
    
    @Override
    public void setLastScrollValue(double value) {
        this.lastScrollValue = value;
    }
}

================
File: client/java/ninja/trek/mixin/client/OrthographicGameRendererMixin.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.GameRenderer;
import ninja.trek.OrthographicCameraManager;
import org.joml.Matrix4f;
import org.spongepowered.asm.mixin.Final;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

@Mixin(GameRenderer.class)
public class OrthographicGameRendererMixin {

    @Shadow @Final
    private MinecraftClient client;

    /**
     * Modifies the projection matrix to use orthographic projection when enabled.
     * Uses an extremely wide view to prevent culling at the edges.
     */
    @Inject(method = "getBasicProjectionMatrix", at = @At("RETURN"), cancellable = true)
    private void onGetBasicProjectionMatrix(float fovDegrees, CallbackInfoReturnable<Matrix4f> cir) {
        // Only modify if orthographic mode is enabled
        if (OrthographicCameraManager.isOrthographicMode()) {
            GameRenderer thisRenderer = (GameRenderer)(Object)this;
            GameRendererAccessor accessor = (GameRendererAccessor)thisRenderer;
            
            Matrix4f matrix = new Matrix4f();
            
            // Get window dimensions
            float aspectRatio = (float) this.client.getWindow().getFramebufferWidth() / this.client.getWindow().getFramebufferHeight();
            float scale = OrthographicCameraManager.getOrthoScale();
            
            // Skip if rendering panorama
            if (thisRenderer.isRenderingPanorama()) {
                return;
            }
            
            // Apply zoom transformation if needed
            float zoom = accessor.getZoom();
            if (zoom != 1.0F) {
                matrix.translate(accessor.getZoomX(), -accessor.getZoomY(), 0.0F);
                matrix.scale(zoom, zoom, 1.0F);
            }
            
            // Create orthographic projection
            // The scale affects how much of the world is visible (larger = more zoomed out)
            float width = scale * aspectRatio;
            float height = scale;
            
            // Make the view frustum extremely large to prevent any culling
            // Use very aggressive near and far planes
            matrix.ortho(
                -width * 2, width * 2,     // left, right (doubled to prevent culling)
                -height * 2, height * 2,    // bottom, top (doubled to prevent culling)
                -1000.0F,                  // extremely close near plane
                2000.0F                    // very far plane
            );
            
            cir.setReturnValue(matrix);
            
            // Make sure chunk culling is disabled
            this.client.chunkCullingEnabled = false;
        }
    }
}

================
File: client/java/ninja/trek/mixin/client/WorldRendererChunkMixin.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.render.WorldRenderer;
import net.minecraft.util.math.BlockPos;
import ninja.trek.OrthographicCameraManager;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfoReturnable;

/**
 * Ensures all chunks are considered ready for rendering in orthographic mode
 */
@Mixin(WorldRenderer.class)
public class WorldRendererChunkMixin {
    
    /**
     * When in orthographic mode, we want to ensure that chunks are always
     * considered ready for rendering regardless of their actual state.
     * This helps ensure consistent rendering in orthographic camera mode.
     */
    @Inject(method = "isRenderingReady", at = @At("HEAD"), cancellable = true)
    private void alwaysRenderInOrthoMode(BlockPos pos, CallbackInfoReturnable<Boolean> cir) {
        if (OrthographicCameraManager.isOrthographicMode()) {
            // In orthographic mode, we want to render everything
            cir.setReturnValue(true);
        }
    }
}

================
File: client/java/ninja/trek/mixin/client/WorldRendererMixin.java
================
package ninja.trek.mixin.client;

import net.minecraft.client.render.WorldRenderer;
import net.minecraft.client.render.Camera;
import net.minecraft.client.render.Frustum;
import net.minecraft.client.MinecraftClient;
import net.minecraft.util.math.Vec3d;
import ninja.trek.CameraController;
import ninja.trek.OrthographicCameraManager;
import ninja.trek.camera.CameraSystem;
import ninja.trek.cameramovements.AbstractMovementSettings;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.Unique;
import org.spongepowered.asm.mixin.injection.*;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

@Mixin(WorldRenderer.class)
public abstract class WorldRendererMixin {
    @Shadow private double lastCameraX;
    @Shadow private double lastCameraY;
    @Shadow private double lastCameraZ;
    
    // Remove the shadow for needsTerrainUpdate since it doesn't exist in WorldRenderer
    @Unique
    private boolean needsTerrainUpdate;

    @Unique
    private long lastUpdateTime = 0;
    @Unique
    private static final long UPDATE_INTERVAL = 500; // Half second between forced updates

    /**
     * Improves chunk rendering in special camera modes by:
     * 1. Updating frustum position
     * 2. Forcing chunk rebuilding when camera moves significantly
     * 3. Scheduling terrain updates in orthographic mode
     */
    @Inject(
            method = "setupTerrain",
            at = @At("HEAD")
    )
    private void onSetupTerrainStart(Camera camera, Frustum frustum, boolean hasForcedFrustum, boolean spectator, CallbackInfo ci) {
        // Instead of setting needsTerrainUpdate directly, call scheduleTerrainUpdate() method
        if (OrthographicCameraManager.isOrthographicMode()) {
            WorldRenderer worldRenderer = (WorldRenderer)(Object)this;
            worldRenderer.scheduleTerrainUpdate();
        }
        
        // Check if using camera system
        CameraSystem cameraSystem = CameraSystem.getInstance();
        boolean isCameraSystemActive = cameraSystem.isCameraActive();
        
        // Check for legacy camera modes 
        boolean isLegacyCameraActive = 
            CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE ||
            CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
            OrthographicCameraManager.isOrthographicMode() ||
            CameraController.currentEndTarget == AbstractMovementSettings.END_TARGET.HEAD_BACK ||
            CameraController.currentEndTarget == AbstractMovementSettings.END_TARGET.VELOCITY_BACK ||
            CameraController.currentEndTarget == AbstractMovementSettings.END_TARGET.FIXED_BACK;
            
        if (isCameraSystemActive || isLegacyCameraActive) {
            // Get the camera position
            Vec3d camPos = camera.getPos();
            
            // Update the frustum to use the camera position
            frustum.setPosition(camPos.x, camPos.y, camPos.z);
            
            // For orthographic mode, we need special handling to render more chunks
            boolean isOrthographic = OrthographicCameraManager.isOrthographicMode();
            
            // Check if enough time has passed since last update for chunk rebuilding
            long currentTime = System.currentTimeMillis();
            
            // Force more frequent updates in orthographic mode
            long interval = isOrthographic ? UPDATE_INTERVAL / 2 : UPDATE_INTERVAL;
            boolean timeToUpdate = (currentTime - lastUpdateTime > interval);
            
            // Orthographic mode needs more aggressive chunk loading
            double movementThreshold = isOrthographic ? 4.0 : 12.0;
            double dx = Math.abs(camPos.x - lastCameraX);
            double dy = Math.abs(camPos.y - lastCameraY);
            double dz = Math.abs(camPos.z - lastCameraZ);
            boolean movedSignificantly = (dx > movementThreshold || dy > movementThreshold || dz > movementThreshold);

            if (timeToUpdate && (movedSignificantly || isOrthographic)) {
                // Update the last time we detected significant movement
                lastUpdateTime = currentTime;
                
                // Mark chunks for rebuild
                WorldRenderer worldRenderer = (WorldRenderer)(Object)this;
                int chunkX = (int)(camPos.x) >> 4;
                int chunkZ = (int)(camPos.z) >> 4;
                
                // Render more distant chunks in orthographic mode
                int radius = isOrthographic ? 8 : 3;
                
                for (int cx = chunkX - radius; cx <= chunkX + radius; cx++) {
                    for (int cz = chunkZ - radius; cz <= chunkZ + radius; cz++) {
                        // Only rebuild chunks that are closer in non-orthographic mode
                        if (!isOrthographic || Math.abs(cx - chunkX) <= 3 || Math.abs(cz - chunkZ) <= 3) {
                            for (int cy = 0; cy < 16; cy++) {
                                worldRenderer.scheduleChunkRender(cx, cy, cz);
                            }
                        }
                    }
                }
                
                // Force terrain update to make chunks render immediately
                if (isOrthographic) {
                    // Use the appropriate method instead of the field
                    worldRenderer.scheduleTerrainUpdate();
                }
            }
        }
    }
    
    /**
     * Modifies the chunk builder's camera position
     */
    @ModifyArg(
            method = "setupTerrain",
            at = @At(
                    value = "INVOKE",
                    target = "Lnet/minecraft/client/render/chunk/ChunkBuilder;setCameraPosition(Lnet/minecraft/util/math/Vec3d;)V"
            ),
            index = 0
    )
    private Vec3d modifyChunkBuilderCameraPosition(Vec3d original) {
        // Use the current camera position
        CameraSystem cameraSystem = CameraSystem.getInstance();
        if (cameraSystem.isCameraActive()) {
            return cameraSystem.getCameraPosition();
        }
        
        // Legacy support
        boolean isLegacyCameraActive = 
            CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE ||
            CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
            OrthographicCameraManager.isOrthographicMode() ||
            CameraController.currentEndTarget == AbstractMovementSettings.END_TARGET.HEAD_BACK ||
            CameraController.currentEndTarget == AbstractMovementSettings.END_TARGET.VELOCITY_BACK ||
            CameraController.currentEndTarget == AbstractMovementSettings.END_TARGET.FIXED_BACK;
            
        if (isLegacyCameraActive && CameraController.freeCamPosition != null) {
            return CameraController.freeCamPosition;
        }
        
        return original;
    }
}

================
File: client/java/ninja/trek/MouseInterceptor.java
================
package ninja.trek;

public class MouseInterceptor {
    private static boolean intercepting = false;

    public static void setIntercepting(boolean intercept) {
        intercepting = intercept;
    }

    public static boolean isIntercepting() {
        return intercepting;
    }
}

================
File: client/java/ninja/trek/MovementToastRenderer.java
================
package ninja.trek;

import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.font.TextRenderer;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.render.RenderTickCounter;
import net.minecraft.text.Text;
import ninja.trek.cameramovements.ICameraMovement;
import java.util.List;

public class MovementToastRenderer {
    private static final int PADDING = 4;
    private static final int MARGIN_BOTTOM = 40;
    private static final int MARGIN_LEFT = 10;
    private static final int LINE_HEIGHT = 12;
    private static final int WHITE_COLOR = 0xFFFFFFFF;
    private static final int GRAY_COLOR = 0xFF808080;
    private static final float HOLD_DURATION = 1.0f;
    private static final float FADE_DURATION = 0.5f;

    private static Long startTime = null;
    private static Integer currentToastSlot = null;
    private static boolean shouldRender = false;

    public static void showToast(int slotIndex) {
        currentToastSlot = slotIndex;
        startTime = System.currentTimeMillis();
        shouldRender = true;
    }

    public static void register() {
        HudRenderCallback.EVENT.register((DrawContext context, RenderTickCounter tickDelta) -> {
            // Early exit if we shouldn't render
            if (!shouldRender || startTime == null || currentToastSlot == null) {
                return;
            }

            MinecraftClient client = MinecraftClient.getInstance();
            if (client.player == null) return;

            long currentTime = System.currentTimeMillis();
            float timeSinceStart = (currentTime - startTime) / 1000f;

            // Check if we should stop rendering entirely
            if (timeSinceStart >= HOLD_DURATION + FADE_DURATION) {
                shouldRender = false;
                startTime = null;
                currentToastSlot = null;
                return;
            }

            float opacity = 1.0f;
            if (timeSinceStart > HOLD_DURATION) {
                opacity = 1.0f - ((timeSinceStart - HOLD_DURATION) / FADE_DURATION);
                opacity = Math.max(0.0f, opacity);
                if (opacity <= 0) {
                    shouldRender = false;
                    startTime = null;
                    currentToastSlot = null;
                    return;
                }
            }

            // Get movements for the current slot
            List<ICameraMovement> movements = CraneshotClient.MOVEMENT_MANAGER.getAvailableMovementsForSlot(currentToastSlot);
            if (movements.isEmpty()) return;

            int selectedIndex = CraneshotClient.MOVEMENT_MANAGER.getCurrentTypeForSlot(currentToastSlot);

            // Calculate dimensions
            TextRenderer textRenderer = client.textRenderer;
            int maxWidth = 0;
            for (ICameraMovement movement : movements) {
                maxWidth = Math.max(maxWidth, textRenderer.getWidth(movement.getName()));
            }

            int totalHeight = movements.size() * LINE_HEIGHT;
            int width = maxWidth + (PADDING * 2);

            // Calculate position
            int screenHeight = client.getWindow().getScaledHeight();
            int x = MARGIN_LEFT;
            int y = screenHeight - MARGIN_BOTTOM - totalHeight;

            // Draw movement names
            for (int i = 0; i < movements.size(); i++) {
                ICameraMovement movement = movements.get(i);
                int textY = y + (i * LINE_HEIGHT);

                int baseColor = (i == selectedIndex) ? WHITE_COLOR : GRAY_COLOR;
                int color = applyOpacity(baseColor, opacity);

                context.drawTextWithShadow(
                        textRenderer,
                        Text.literal(movement.getName()),
                        x + PADDING,
                        textY + (LINE_HEIGHT - textRenderer.fontHeight) / 2,
                        color
                );
            }
        });
    }

    private static int applyOpacity(int color, float opacity) {
        int alpha = (int) (((color >> 24) & 0xFF) * opacity);
        return (color & 0x00FFFFFF) | (alpha << 24);
    }
}

================
File: client/java/ninja/trek/OrthographicCameraManager.java
================
package ninja.trek;

import net.minecraft.client.MinecraftClient;
import net.minecraft.text.Text;
import ninja.trek.camera.CameraSystem;

/**
 * Manages the orthographic camera mode state.
 * This class handles toggling between perspective and orthographic projection modes.
 */
public class OrthographicCameraManager {
    private static boolean orthographicMode = false;
    private static float orthoScale = 20.0f; // Controls the zoom level of the orthographic view
    private static final float MIN_SCALE = 1.0f;
    private static final float MAX_SCALE = 100.0f;
    private static final float SCALE_STEP = 1.0f;

    /**
     * Toggles the camera mode between perspective and orthographic.
     * @return The new state (true if orthographic mode is now enabled)
     */
    public static boolean toggleOrthographicMode() {
        orthographicMode = !orthographicMode;
        
        // Activate camera system with appropriate mode when entering orthographic mode
        CameraSystem cameraSystem = CameraSystem.getInstance();
        if (orthographicMode) {
            cameraSystem.activateCamera(CameraSystem.CameraMode.ORTHOGRAPHIC);
            
            // Force third-person view for better visualization
            MinecraftClient client = MinecraftClient.getInstance();
            if (client != null && client.options != null) {
                client.options.setPerspective(net.minecraft.client.option.Perspective.THIRD_PERSON_BACK);
            }
        } else if (cameraSystem.isCameraActive()) {
            // Deactivate camera when leaving orthographic mode
            cameraSystem.deactivateCamera();
        }
        
        // Display a message to the player
        if (MinecraftClient.getInstance().player != null) {
            MinecraftClient.getInstance().player.sendMessage(
                Text.translatable("message.craneshot.orthographic." + (orthographicMode ? "enabled" : "disabled")),
                true
            );
        }
        
        return orthographicMode;
    }

    /**
     * Checks if orthographic mode is currently enabled.
     * @return true if orthographic mode is active, false otherwise
     */
    public static boolean isOrthographicMode() {
        return orthographicMode;
    }

    /**
     * Gets the current orthographic scale factor.
     * @return The scale value that determines the zoom level
     */
    public static float getOrthoScale() {
        return orthoScale;
    }

    /**
     * Sets the orthographic scale factor.
     * @param scale The new scale value
     */
    public static void setOrthoScale(float scale) {
        orthoScale = clampScale(scale);
    }

    /**
     * Adjusts the orthographic scale by the given amount.
     * Positive values zoom out (increase scale), negative values zoom in (decrease scale).
     * @param amount The amount to add to the current scale
     */
    public static void adjustOrthoScale(float amount) {
        orthoScale = clampScale(orthoScale + amount);
        
        // Display the current zoom level when changed
        if (MinecraftClient.getInstance().player != null && orthographicMode) {
            MinecraftClient.getInstance().player.sendMessage(
                Text.literal("Orthographic zoom: " + String.format("%.1f", orthoScale)),
                true
            );
        }
    }
    
    /**
     * Zoom in (decrease scale)
     */
    public static void zoomIn() {
        adjustOrthoScale(-SCALE_STEP);
    }
    
    /**
     * Zoom out (increase scale)
     */
    public static void zoomOut() {
        adjustOrthoScale(SCALE_STEP);
    }
    
    /**
     * Ensures the scale stays within the valid range
     * @param scale The scale to clamp
     * @return The clamped scale value
     */
    private static float clampScale(float scale) {
        return Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale));
    }
}

================
File: client/java/ninja/trek/util/CameraEntity.java
================
package ninja.trek.util;

// import annotation from org.jetbrains instead
import org.jetbrains.annotations.Nullable;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.network.ClientPlayNetworkHandler;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.client.option.GameOptions;
import net.minecraft.client.recipebook.ClientRecipeBook;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.entity.Entity;
import net.minecraft.entity.MovementType;
import net.minecraft.stat.StatHandler;
import net.minecraft.util.math.MathHelper;
import net.minecraft.util.math.Vec3d;

import ninja.trek.CraneshotClient;
import ninja.trek.config.GeneralMenuSettings;
import ninja.trek.config.FreeCamSettings;

/**
 * A dedicated camera entity for free camera movement
 * Used when the camera is in "out" position or in orthographic mode
 */
public class CameraEntity extends ClientPlayerEntity {
    @Nullable private static CameraEntity camera;
    @Nullable private static Entity originalCameraEntity;
    private static Vec3d cameraMotion = new Vec3d(0.0, 0.0, 0.0);
    private static boolean cullChunksOriginal;
    private static boolean sprinting;
    private static boolean originalCameraWasPlayer;

    private CameraEntity(MinecraftClient mc, ClientWorld world,
                         ClientPlayNetworkHandler netHandler, StatHandler stats,
                         ClientRecipeBook recipeBook) {
        super(mc, world, netHandler, stats, recipeBook, false, false);
    }

    @Override
    public boolean isSpectator() {
        return true;
    }

    /**
     * Returns an entity ID to prevent mods from complaining about missing ID
     */
    @Override
    public int getId() {
        if (originalCameraEntity != null) {
            return originalCameraEntity.getId();
        }
        return super.getId();
    }

    /**
     * Handles camera movement during each tick
     */
    public static void movementTick() {
        CameraEntity camera = getCamera();

        if (camera != null) {
            GameOptions options = MinecraftClient.getInstance().options;

            camera.updateLastTickPosition();

            if (options.sprintKey.isPressed()) {
                sprinting = true;
            } else if (options.forwardKey.isPressed() == false && options.backKey.isPressed() == false) {
                sprinting = false;
            }

            FreeCamSettings settings = GeneralMenuSettings.getFreeCamSettings();
            
            // Calculate deceleration
            cameraMotion = calculatePlayerMotionWithDeceleration(cameraMotion, 
                                                               settings.getAcceleration(),
                                                               settings.getDeceleration());
            
            double forward = sprinting ? cameraMotion.x * 3 : cameraMotion.x;
            camera.handleMotion(forward, cameraMotion.y, cameraMotion.z);
        }
    }

    /**
     * Calculates motion with deceleration similar to tweakeroo's implementation
     */
    private static Vec3d calculatePlayerMotionWithDeceleration(Vec3d motion, float acceleration, float deceleration) {
        MinecraftClient mc = MinecraftClient.getInstance();
        FreeCamSettings.MovementMode movementMode = GeneralMenuSettings.getFreeCamSettings().getMovementMode();
        
        double x = 0;
        double y = 0;
        double z = 0;
        
        if (mc.options.forwardKey.isPressed()) {
            z += 1.0;
        }
        
        if (mc.options.backKey.isPressed()) {
            z -= 1.0;
        }
        
        if (mc.options.leftKey.isPressed()) {
            x += 1.0;
        }
        
        if (mc.options.rightKey.isPressed()) {
            x -= 1.0;
        }
        
        if (mc.options.jumpKey.isPressed()) {
            y += 1.0;
        }
        
        if (mc.options.sneakKey.isPressed()) {
            y -= 1.0;
        }
        
        boolean keyPressed = x != 0 || y != 0 || z != 0;
        
        double accX = motion.x;
        double accY = motion.y;
        double accZ = motion.z;
        
        if (keyPressed) {
            // Normalize the input vector if there's input in multiple directions
            if ((x != 0 && z != 0) || (x != 0 && y != 0) || (z != 0 && y != 0)) {
                double norm = Math.sqrt(x * x + y * y + z * z);
                x /= norm;
                y /= norm;
                z /= norm;
            }
            
            // Accelerate towards the target motion
            accX = accX + (x - accX) * acceleration;
            accY = accY + (y - accY) * acceleration;
            accZ = accZ + (z - accZ) * acceleration;
        } else {
            // Decelerate when no input
            accX = accX * (1.0 - deceleration);
            accY = accY * (1.0 - deceleration);
            accZ = accZ * (1.0 - deceleration);
            
            // Fix very small values to zero to prevent perpetual small movements
            if (Math.abs(accX) < 0.001) accX = 0;
            if (Math.abs(accY) < 0.001) accY = 0;
            if (Math.abs(accZ) < 0.001) accZ = 0;
        }
        
        return new Vec3d(accX, accY, accZ);
    }

    private static double getMoveSpeed() {
        return GeneralMenuSettings.getFreeCamSettings().getMoveSpeed() * 10;
    }

    private void handleMotion(double forward, double up, double strafe) {
        float yaw = this.getYaw();
        double scale = getMoveSpeed();
        
        if (GeneralMenuSettings.getFreeCamSettings().getMovementMode() == FreeCamSettings.MovementMode.CAMERA) {
            // Camera-relative movement
            double xFactor = Math.sin(yaw * Math.PI / 180.0);
            double zFactor = Math.cos(yaw * Math.PI / 180.0);
            
            double x = (strafe * zFactor - forward * xFactor) * scale;
            double y = up * scale;
            double z = (forward * zFactor + strafe * xFactor) * scale;
            
            this.setVelocity(new Vec3d(x, y, z));
        } else {
            // Axis-aligned movement
            double x = strafe * scale;
            double y = up * scale;
            double z = forward * scale;
            
            this.setVelocity(new Vec3d(x, y, z));
        }
        
        this.move(MovementType.SELF, this.getVelocity());
    }

    private void updateLastTickPosition() {
        this.lastRenderX = this.getX();
        this.lastRenderY = this.getY();
        this.lastRenderZ = this.getZ();

        this.lastX = this.getX();
        this.lastY = this.getY();
        this.lastZ = this.getZ();

        this.lastYaw = this.getYaw();
        this.lastPitch = this.getPitch();

        this.lastHeadYaw = this.headYaw;
    }

    public void setCameraRotations(float yaw, float pitch) {
        this.setYaw(yaw);
        this.setPitch(pitch);
        this.headYaw = yaw;
    }

    public void updateCameraRotations(float yawChange, float pitchChange) {
        float yaw = this.getYaw() + yawChange * 0.15F;
        float pitch = MathHelper.clamp(this.getPitch() + pitchChange * 0.15F, -90F, 90F);

        this.setYaw(yaw);
        this.setPitch(pitch);

        this.setCameraRotations(yaw, pitch);
    }

    private static CameraEntity createCameraEntity(MinecraftClient mc) {
        ClientPlayerEntity player = mc.player;

        if (player == null) {
            throw new RuntimeException("Cannot create CameraEntity from null player!");
        }

        Vec3d entityPos = player.getPos();
        float yaw = player.getYaw();
        float pitch = player.getPitch();

        mc.player.setVelocity(Vec3d.ZERO);

        CameraEntity camera = new CameraEntity(
            mc, 
            mc.world, 
            player.networkHandler, 
            player.getStatHandler(), 
            player.getRecipeBook()
        );
        camera.noClip = true;

        camera.setPos(entityPos.getX(), entityPos.getY() + 0.125f, entityPos.getZ());
        camera.setYaw(yaw);
        camera.setPitch(pitch);
        camera.setVelocity(Vec3d.ZERO);

        return camera;
    }

    @Nullable
    public static CameraEntity getCamera() {
        return camera;
    }

    public static void setCameraState(boolean enabled) {
        MinecraftClient mc = MinecraftClient.getInstance();

        if (mc.world != null && mc.player != null) {
            if (enabled) {
                createAndSetCamera(mc);
            } else {
                removeCamera(mc);
            }

            mc.gameRenderer.setRenderHand(!enabled);
        }
    }

    public static boolean originalCameraWasPlayer() {
        return originalCameraWasPlayer;
    }

    private static void createAndSetCamera(MinecraftClient mc) {
        camera = createCameraEntity(mc);
        originalCameraEntity = mc.getCameraEntity();
        originalCameraWasPlayer = originalCameraEntity == mc.player;
        cullChunksOriginal = mc.chunkCullingEnabled;

        mc.setCameraEntity(camera);
        mc.chunkCullingEnabled = false; // Disable chunk culling
    }

    private static void removeCamera(MinecraftClient mc) {
        if (mc.world != null && camera != null) {
            // Re-fetch the player entity, in case the player died while in Free Camera mode
            mc.setCameraEntity(originalCameraWasPlayer ? mc.player : originalCameraEntity);
            mc.chunkCullingEnabled = cullChunksOriginal;

            final int chunkX = MathHelper.floor(camera.getX() / 16.0) >> 4;
            final int chunkZ = MathHelper.floor(camera.getZ() / 16.0) >> 4;
            CameraUtils.markChunksForRebuildOnDeactivation(chunkX, chunkZ);
        }

        originalCameraEntity = null;
        camera = null;
    }
}

================
File: client/java/ninja/trek/util/CameraUtils.java
================
package ninja.trek.util;

import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.WorldRenderer;
import net.minecraft.client.world.ClientWorld;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.MathHelper;
import net.minecraft.world.chunk.ChunkStatus;

/**
 * Utility class for camera-related functions.
 * Handles camera positioning, rotation, and chunk updating.
 */
public class CameraUtils {
    private static float cameraYaw;
    private static float cameraPitch;
    private static boolean freeCameraActive;

    /**
     * Sets the free camera state.
     * @param isActive true to enable free camera mode
     */
    public static void setFreeCameraActive(boolean isActive) {
        freeCameraActive = isActive;
    }

    /**
     * Checks if free camera is currently active.
     * @return true if free camera mode is active
     */
    public static boolean isFreeCameraActive() {
        return freeCameraActive;
    }

    /**
     * Gets the camera yaw angle.
     * @return camera yaw in degrees
     */
    public static float getCameraYaw() {
        return MathHelper.wrapDegrees(cameraYaw);
    }

    /**
     * Gets the camera pitch angle.
     * @return camera pitch in degrees
     */
    public static float getCameraPitch() {
        return MathHelper.wrapDegrees(cameraPitch);
    }

    /**
     * Sets the camera yaw angle.
     * @param yaw yaw angle in degrees
     */
    public static void setCameraYaw(float yaw) {
        cameraYaw = yaw;
    }

    /**
     * Sets the camera pitch angle.
     * @param pitch pitch angle in degrees
     */
    public static void setCameraPitch(float pitch) {
        cameraPitch = pitch;
    }

    /**
     * Sets both camera rotation angles at once.
     * @param yaw yaw angle in degrees
     * @param pitch pitch angle in degrees
     */
    public static void setCameraRotations(float yaw, float pitch) {
        CameraEntity camera = CameraEntity.getCamera();

        if (camera != null) {
            camera.setCameraRotations(yaw, pitch);
        }
    }

    /**
     * Updates camera rotations based on delta changes.
     * @param yawChange change in yaw
     * @param pitchChange change in pitch
     */
    public static void updateCameraRotations(float yawChange, float pitchChange) {
        CameraEntity camera = CameraEntity.getCamera();

        if (camera != null) {
            camera.updateCameraRotations(yawChange, pitchChange);
        }
    }

    /**
     * Marks chunks for rebuilding when camera moves.
     * @param chunkX current chunk X
     * @param chunkZ current chunk Z
     * @param lastChunkX previous chunk X
     * @param lastChunkZ previous chunk Z
     */
    public static void markChunksForRebuild(int chunkX, int chunkZ, int lastChunkX, int lastChunkZ) {
        MinecraftClient mc = MinecraftClient.getInstance();

        if (mc.world == null || (chunkX == lastChunkX && chunkZ == lastChunkZ)) {
            return;
        }

        final int viewDistance = mc.options.getViewDistance().getValue();

        if (chunkX != lastChunkX) {
            final int minCX = chunkX > lastChunkX ? lastChunkX + viewDistance : chunkX     - viewDistance;
            final int maxCX = chunkX > lastChunkX ? chunkX     + viewDistance : lastChunkX - viewDistance;

            for (int cx = minCX; cx <= maxCX; ++cx) {
                for (int cz = chunkZ - viewDistance; cz <= chunkZ + viewDistance; ++cz) {
                    if (isClientChunkLoaded(mc.world, cx, cz)) {
                        markChunkForReRender(mc.worldRenderer, cx, cz);
                    }
                }
            }
        }

        if (chunkZ != lastChunkZ) {
            final int minCZ = chunkZ > lastChunkZ ? lastChunkZ + viewDistance : chunkZ     - viewDistance;
            final int maxCZ = chunkZ > lastChunkZ ? chunkZ     + viewDistance : lastChunkZ - viewDistance;

            for (int cz = minCZ; cz <= maxCZ; ++cz) {
                for (int cx = chunkX - viewDistance; cx <= chunkX + viewDistance; ++cx) {
                    if (isClientChunkLoaded(mc.world, cx, cz)) {
                        markChunkForReRender(mc.worldRenderer, cx, cz);
                    }
                }
            }
        }
    }

    /**
     * Marks chunks for rebuilding when deactivating camera.
     * @param lastChunkX last camera chunk X
     * @param lastChunkZ last camera chunk Z
     */
    public static void markChunksForRebuildOnDeactivation(int lastChunkX, int lastChunkZ) {
        MinecraftClient mc = MinecraftClient.getInstance();
        final int viewDistance = mc.options.getViewDistance().getValue();
        Entity entity = mc.getCameraEntity();

        if (mc.world == null || entity == null) {
            return;
        }

        final int chunkX = MathHelper.floor(entity.getX() / 16.0) >> 4;
        final int chunkZ = MathHelper.floor(entity.getZ() / 16.0) >> 4;

        final int minCameraCX = lastChunkX - viewDistance;
        final int maxCameraCX = lastChunkX + viewDistance;
        final int minCameraCZ = lastChunkZ - viewDistance;
        final int maxCameraCZ = lastChunkZ + viewDistance;
        final int minCX = chunkX - viewDistance;
        final int maxCX = chunkX + viewDistance;
        final int minCZ = chunkZ - viewDistance;
        final int maxCZ = chunkZ + viewDistance;

        for (int cz = minCZ; cz <= maxCZ; ++cz) {
            for (int cx = minCX; cx <= maxCX; ++cx) {
                // Mark all chunks that were not in free camera range
                if ((cx < minCameraCX || cx > maxCameraCX || cz < minCameraCZ || cz > maxCameraCZ) &&
                    isClientChunkLoaded(mc.world, cx, cz)) {
                    markChunkForReRender(mc.worldRenderer, cx, cz);
                }
            }
        }
    }

    /**
     * Marks a chunk for re-rendering.
     * @param renderer the world renderer
     * @param chunkX chunk X coordinate
     * @param chunkZ chunk Z coordinate
     */
    public static void markChunkForReRender(WorldRenderer renderer, int chunkX, int chunkZ) {
        for (int cy = 0; cy < 16; ++cy) {
            renderer.scheduleChunkRender(chunkX, cy, chunkZ);
        }
    }

    /**
     * Checks if a client chunk is loaded.
     * @param world the client world
     * @param chunkX chunk X coordinate
     * @param chunkZ chunk Z coordinate
     * @return true if the chunk is loaded
     */
    public static boolean isClientChunkLoaded(ClientWorld world, int chunkX, int chunkZ) {
        return world.getChunkManager().getChunk(chunkX, chunkZ, ChunkStatus.FULL, false) != null;
    }
}

================
File: client/resources/craneshot.client.mixins.json
================
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"CameraAccessor",
		"CameraMixin",
		"CameraSubmersionMixin",
		"FovAccessor",
		"FrustumMixin",
		"GameRendererAccessor",
		"GameRendererMixin",
		"KeyboardInputMixin",
		"MinecraftClientMixin",
		"MouseAccessor",
		"MouseMixin",
		"OrthographicGameRendererMixin",
		"WorldRendererChunkMixin",
		"WorldRendererMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}

================
File: main/java/ninja/trek/Craneshot.java
================
package ninja.trek;

import net.fabricmc.api.ModInitializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Craneshot implements ModInitializer {
	public static final String MOD_ID = "craneshot";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);

	@Override
	public void onInitialize() {
		LOGGER.info("CraneShot Camera Mod initialized!");
	}
}

================
File: main/java/ninja/trek/mixin/ExampleMixin.java
================
package ninja.trek.mixin;

import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;

@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}

================
File: main/resources/assets/craneshot/lang/en_us.json
================
{
  "category.craneshot.camera": "CraneShot Camera",
  "category.craneshot.ui": "CraneShot UI",
  "key.craneshot.toggle_menu": "Toggle Menu",
  "key.craneshot.select_movement": "Select Movement Type",
  "key.craneshot.camera1": "Camera Slot 1",
  "key.craneshot.camera2": "Camera Slot 2",
  "key.craneshot.camera3": "Camera Slot 3",
  "key.craneshot.toggle_orthographic": "Toggle Orthographic View",
  "message.craneshot.orthographic.enabled": "Orthographic camera enabled (Hold Shift + Scroll to zoom)",
  "message.craneshot.orthographic.disabled": "Orthographic camera disabled"
}

================
File: main/resources/craneshot.mixins.json
================
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}

================
File: main/resources/fabric.mod.json
================
{
	"schemaVersion": 1,
	"id": "craneshot",
	"version": "${version}",
	"name": "craneshot",
	"description": "Advanced camera controls mod for cinematics",
	"authors": ["Me!"],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/craneshot/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": ["ninja.trek.Craneshot"],
		"client": ["ninja.trek.CraneshotClient"],
		
		"fabric-datagen": ["ninja.trek.CraneshotDataGenerator"]
	},
	"mixins": [
		"craneshot.mixins.json",
		{
			"config": "craneshot.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*",
		"fabric-key-binding-api-v1": "*"
	}
}

================
File: main/resources/orthocam.mixins.json
================
{
  "required": true,
  "minVersion": "0.8",
  "package": "com.example.orthocam.mixin",
  "compatibilityLevel": "JAVA_17",
  "client": [
    "GameRendererMixin"
  ],
  "injectors": {
    "defaultRequire": 1
  }
}
