This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-08T10:23:47.335Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
AbstractMovementSettings.java
CameraMovementType.java
CameraState.java
CameraTarget.java
ICameraMovement.java
move8.txt
movements/BezierMovement.java
movements/LinearMovement.java
MovementState.java
RaycastType.java
RaycastUtil.java
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="AbstractMovementSettings.java">
package ninja.trek.cameramovements;
import net.minecraft.entity.player.PlayerEntity;
import ninja.trek.Craneshot;
import ninja.trek.config.MovementSetting;
import ninja.trek.config.MovementSettingType;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;
public abstract class AbstractMovementSettings {
    private String customName = null;
    @MovementSetting(
            label = "Raycast Type",
            type = MovementSettingType.ENUM,
            description = "Controls how the camera handles collision with blocks"
    )
    private RaycastType raycastType = RaycastType.NEAR;
    public double alpha;
    public enum START_TARGET {PLAYER};
    public enum END_TARGET {BACK, FRONT}
    public enum POST_MOVE_MOUSE {
        NONE,       // Default behavior
        FREE_MOUSE // Allow free mouse control after movement
           // Allow WASD movement after movement
    }
    @MovementSetting(
            label = "Post-Movement Mouse",
            type = MovementSettingType.ENUM,
            description = "Controls camera behavior after movement completes"
    )
    protected POST_MOVE_MOUSE postMoveMouse = POST_MOVE_MOUSE.NONE;
    public POST_MOVE_MOUSE getPostMoveMouse() {
        return postMoveMouse;
    }
    public enum POST_MOVE_KEYS {
        NONE,       // Default behavior
        MOVE_CAMERA_FLAT, // Y-axis locked camera-relative movement
        MOVE_CAMERA_FREE, // Full camera-relative movement including pitch
        MOVE8       // 8-directional player movement relative to camera
    }
    @MovementSetting(
            label = "Post-Movement Keys",
            type = MovementSettingType.ENUM,
            description = "Controls camera behavior after movement completes"
    )
    protected POST_MOVE_KEYS postMoveKeys = POST_MOVE_KEYS.NONE;
    public POST_MOVE_KEYS getPostMoveKeys(){return postMoveKeys;}
    @MovementSetting(
            label = "Camera Position",
            type = MovementSettingType.ENUM,
            description = "Determines if camera follows in front or behind the player"
    )
    protected END_TARGET endTarget = END_TARGET.BACK;
//    @MovementSetting(
//            label = "Head Locked To Camera",
//            type = MovementSettingType.BOOLEAN,
//            description = "If true, player head will follow camera orientation"
//    )
    protected boolean headLockedToCamera = true;
    public boolean isHeadLockedToCamera() {
        return headLockedToCamera;
    }
    protected CameraTarget getEndTarget(PlayerEntity player, double targetDistance) {
        switch (endTarget){
            default:
            case BACK: return CameraTarget.fromDistanceBack(player, targetDistance);
            case FRONT: return CameraTarget.fromDistanceFront(player, targetDistance);
        }
    }
    public RaycastType getRaycastType() {
        return raycastType != null ? raycastType : RaycastType.NONE;
    }
    public void setRaycastType(RaycastType type) {
        this.raycastType = type;
    }
    public String getDisplayName() {
        return customName != null ? customName : getClass().getSimpleName();
    }
    public void setCustomName(String name) {
        this.customName = name;
    }
    public Map<String, Object> getSettings() {
        Map<String, Object> settings = new HashMap<>();
        Stream.concat(
                        Arrays.stream(this.getClass().getDeclaredFields()),
                        Arrays.stream(AbstractMovementSettings.class.getDeclaredFields())
                )
                .filter(field -> field.isAnnotationPresent(MovementSetting.class) || field.getName().equals("customName"))
                .forEach(field -> {
                    field.setAccessible(true);
                    try {
                        Object value = field.get(this);
                        if (value instanceof Enum<?>) {
                            settings.put(field.getName(), ((Enum<?>) value).name());
                        } else {
                            settings.put(field.getName(), value);
                        }
                    } catch (IllegalAccessException e) {
                        Craneshot.LOGGER.error("Error accessing field: " + field.getName(), e);
                    }
                });
        return settings;
    }
    public void updateSetting(String key, Object value) {
        try {
            if (key.equals("customName")) {
                setCustomName((String)value);
                return;
            }
            Field field = findField(key);
            if (field != null && field.isAnnotationPresent(MovementSetting.class)) {
                field.setAccessible(true);
                // Handle different field types
                if (field.getType().isEnum()) {
                    if (value instanceof String) {
                        @SuppressWarnings("unchecked")
                        Enum<?> enumValue = Enum.valueOf(field.getType().asSubclass(Enum.class), (String) value);
                        field.set(this, enumValue);
                        if (key.equals("raycastType")) {
                            setRaycastType((RaycastType)enumValue);
                        }
                    }
                } else if (field.getType() == double.class || field.getType() == Double.class) {
                    double doubleValue;
                    if (value instanceof Number) {
                        doubleValue = ((Number)value).doubleValue();
                    } else if (value instanceof String) {
                        doubleValue = Double.parseDouble((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to double");
                    }
                    field.setDouble(this, doubleValue);
                } else if (field.getType() == float.class || field.getType() == Float.class) {
                    float floatValue;
                    if (value instanceof Number) {
                        floatValue = ((Number)value).floatValue();
                    } else if (value instanceof String) {
                        floatValue = Float.parseFloat((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to float");
                    }
                    field.setFloat(this, floatValue);
                } else if (field.getType() == int.class || field.getType() == Integer.class) {
                    int intValue;
                    if (value instanceof Number) {
                        intValue = ((Number)value).intValue();
                    } else if (value instanceof String) {
                        intValue = Integer.parseInt((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to integer");
                    }
                    field.setInt(this, intValue);
                } else {
                    // Default fallback for other types
                    field.set(this, value);
                }
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Error updating setting {} with value {}: {}", key, value, e.getMessage());
        }
    }
    private Field findField(String key) {
        try {
            return this.getClass().getDeclaredField(key);
        } catch (NoSuchFieldException e) {
            try {
                return AbstractMovementSettings.class.getDeclaredField(key);
            } catch (NoSuchFieldException ex) {
                Craneshot.LOGGER.error("Field not found: {}", key);
                return null;
            }
        }
    }
}
</file>

<file path="CameraMovementType.java">
package ninja.trek.cameramovements;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CameraMovementType {
    String name() default "";
    String description() default "";
    boolean enabled() default true;
}
</file>

<file path="CameraState.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.input.Input;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
public class CameraState {
    private Vec3d position;
    private float yaw;
    private float pitch;
    public CameraState(Vec3d position, float yaw, float pitch) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public static CameraState fromCamera(Camera camera) {
        return new CameraState(camera.getPos(), camera.getYaw(), camera.getPitch());
    }
    public Vec3d getPosition() { return position; }
    public float getYaw() { return yaw; }
    public float getPitch() { return pitch; }
    public CameraState lerp(CameraState other, double t) {
        Vec3d lerpedPos = this.position.lerp(other.position, t);
        float lerpedYaw = lerpAngle(this.yaw, other.yaw, (float)t);
        float lerpedPitch = lerpAngle(this.pitch, other.pitch, (float)t);
        return new CameraState(lerpedPos, lerpedYaw, lerpedPitch);
    }
    private float lerpAngle(float start, float end, float t) {
        float diff = end - start;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return start + diff * t;
    }
}
</file>

<file path="CameraTarget.java">
package ninja.trek.cameramovements;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.Craneshot;
public class CameraTarget {
    private Vec3d position;
    private float yaw;
    private float pitch;
    public CameraTarget(Vec3d position, float yaw, float pitch) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public CameraTarget() {
        position = new Vec3d(0,0,0);
    }
    public static CameraTarget fromCamera(Camera camera) {
        return new CameraTarget(camera.getPos(), camera.getYaw(), camera.getPitch());
    }
    public static CameraTarget fromDistanceBack(PlayerEntity player, double distance) {
        double yaw = Math.toRadians(player.getYaw());// + Math.toRadians((180));
        double pitch = Math.toRadians(player.getPitch());
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * distance;
        double yOffset = Math.sin(pitch) * distance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * distance;
        Vec3d targetPos = player.getEyePos().add(xOffset, yOffset, zOffset);
        return new CameraTarget(targetPos, player.getYaw(), player.getPitch());
    }
    public static CameraTarget fromDistanceFront(PlayerEntity player, double distance) {
        double yaw = Math.toRadians(player.getYaw() + 180); // Add 180 degrees to face front
        double pitch = Math.toRadians(-player.getPitch()); // Invert the pitch angle
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * distance;
        double yOffset = Math.sin(pitch) * distance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * distance;
        Vec3d targetPos = player.getEyePos().add(xOffset, yOffset, zOffset);
        return new CameraTarget(targetPos, player.getYaw() + 180, -player.getPitch());
    }
    public Vec3d getPosition() {
        return position;
    }
    public float getYaw() {
        return yaw;
    }
    public float getPitch() {
        return pitch;
    }
    public CameraTarget withAdjustedPosition(PlayerEntity player, RaycastType raycastType) {
//        Craneshot.LOGGER.info("withAdjustedPosition called with raycastType: {}", this.raycastType);
        Vec3d adjustedPos = RaycastUtil.adjustForCollision(player.getEyePos(), this.position, raycastType);
        return new CameraTarget(adjustedPos, this.yaw, this.pitch);
    }
    public void set(Vec3d v, float yaw, float pitch) {
        position = v;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public void set(CameraTarget t) {
        position = t.position;
        this.pitch = t.pitch;
        this.yaw = t.yaw;
    }
}
</file>

<file path="ICameraMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
public interface ICameraMovement {
    void start(MinecraftClient client, Camera camera);
    MovementState calculateState(MinecraftClient client, Camera camera);
    void queueReset(MinecraftClient client, Camera camera);
    void adjustDistance(boolean increase);
    String getName();
    float getWeight(); // For blending calculations
    boolean isComplete(); // To determine if movement should be removed
    RaycastType getRaycastType();
    default boolean hasCompletedOutPhase() { return false; }
}
</file>

<file path="move8.txt">
Overview: Two Post‑Move Mouse Options with MOVE8
When a movement transition (using either Bézier or linear easing) finishes, the system enters a “post‑move” phase. In this phase you have two distinct modes for handling mouse input:

FREE_MOUSE:
– The mouse controls the camera’s rotation (freeCamYaw/freeCamPitch) independently.
– The “stick” (the camera’s positional anchor, freeCamPosition) stays fixed (or is only updated by the easing logic, not directly by mouse motion).
– The player’s head (or model) is snapped to one of eight directions (MOVE8) based on keyboard input relative to the current freeCamYaw. This lets the player choose one of eight discrete orientations for movement, while the camera can look around freely.

NONE:
– The mouse does not directly update the camera’s rotation. Instead, the system uses keyboard input to “nudge” the camera stick itself.
– In this case, the entire stick (its position and rotation) is moved via the easing logic (using the same positionEasing/rotationEasing and speed limits that govern Bézier/linear movement).
– With MOVE8 enabled, the player’s head still snaps to one of eight directions based on key combinations, but now the overall camera “stick” (freeCamPosition and freeCamYaw/freeCamPitch) is driven by that movement input rather than independent mouse adjustments.

How They Work with MOVE8 Movement
A. MOVE8 with FREE_MOUSE
Independent Camera Rotation:
When post‑move mouse mode is set to FREE_MOUSE, the mouse “nudges” only the freeCamYaw and freeCamPitch values. That is, the camera’s orientation is updated immediately by the mouse (subject to the easing limits already in place) while the camera’s position (the stick) remains unchanged by the mouse.

Discrete Player Orientation:
In MOVE8 mode, the keyboard input calculates a target yaw (by adding a fixed offset to freeCamYaw based on which keys are pressed) and immediately sets the player’s yaw to that target value. The player’s head “snaps” to one of the eight directions relative to the current camera view.

Resulting Behavior:
• The player’s movement (simulated by setting forward movement) is determined by the snapped direction.
• The camera’s stick (its anchored position) stays put while the user can still look around freely with the mouse.
• The overall effect is that even though the player is moving in one of eight preset directions, the view is independently adjustable so the player can look in any direction without moving the camera stick.

B. MOVE8 with NONE
Stick Movement via Keyboard Input:
When the post‑move mouse option is set to NONE, the mouse does not adjust the camera’s rotation independently. Instead, the “stick” itself is moved by the easing logic that responds to keyboard input. In other words, the camera’s freeCamPosition and its rotation are updated by the same interpolation that moves the camera along its Bézier or linear path.

Discrete Player Orientation Remains:
As in FREE_MOUSE mode, MOVE8 logic uses the current freeCamYaw (which in this mode is driven only by keyboard/easing changes) as the basis for computing the target yaw. The player’s head is then snapped to one of eight directions relative to that yaw, and simulated forward movement is applied.

Resulting Behavior:
• The entire camera “stick” is adjusted when the movement keys are pressed.
• There is no separate free mouse–based rotation; the camera’s orientation is changed as part of the eased, stick–based movement.
• Thus, the discrete MOVE8 movement still applies: the player rotates to one of eight directions and moves forward accordingly, with the camera’s state (position/rotation) shifting gradually as determined by the easing logic.

Key Points to Ensure Both Modes Work with MOVE8
For Both Modes:
• The calculation of the target yaw for MOVE8 is always based on the current freeCamYaw.
• When a movement key combination is pressed, the system computes the appropriate offset (e.g., ±45°, ±90°, etc.) from freeCamYaw, snaps the player’s yaw to that value, and simulates forward movement.

Differences in Mouse Handling:
• FREE_MOUSE: The mouse directly modifies freeCamYaw/freeCamPitch independent of the stick’s position; the stick remains fixed while the camera rotates under the mouse’s control.
• NONE: The mouse does not inject independent rotation; instead, the keyboard input causes the stick (the camera’s entire state) to be adjusted via easing. The camera’s rotation is updated as part of that overall stick movement.

User Experience:
– In FREE_MOUSE mode, players can look around without shifting the camera’s position, while still moving discretely in one of eight directions.
– In NONE mode, any adjustment to the camera’s view happens as part of the overall movement (the “stick” moves), so the camera’s position and rotation evolve together as the player commands movement.

Conclusion
By distinguishing the two options—FREE_MOUSE for independent, mouse‑driven camera rotation (with a fixed stick) and NONE for stick movement controlled by keyboard input—you can ensure that MOVE8 movement works seamlessly in both cases. In either mode, the player's eight‑direction snapping is calculated relative to the current freeCamYaw, and simulated forward movement is applied, while the camera’s behavior (whether rotating independently or moving as a unit) follows the respective mouse option’s design.
</file>

<file path="movements/BezierMovement.java">
package ninja.trek.cameramovements.movements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.Craneshot;
import ninja.trek.CraneshotClient;
import ninja.trek.cameramovements.CameraMovementType;
import ninja.trek.cameramovements.CameraTarget;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.MovementState;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.config.MovementSetting;
/**
 * Moves the camera along a quadratic Bézier curve (in canonical space) and then transforms
 * to world space using the player's head rotation.
 *
 * Modified so that:
 * - While “moving out” (Bézier phase), adjustDistance() does not change the current path.
 * - Once the “out” phase completes, the movement switches to linear mode so that any subsequent
 *   distance (or rotation) changes immediately recalc the canonical endpoints.
 * - When resetting, we exit linear mode and return along a Bézier curve that goes back to the
 *   original absolute camera position.
 *
 * To achieve that, we now store the player's original eye position and head rotation (as well as
 * the original canonical start) and use these for converting canonical coordinates back to world space
 * during the reset.
 */
@CameraMovementType(
        name = "Bezier Movement (Canonical Relative)",
        description = "Moves the camera along a quadratic Bézier curve in canonical space then converts to world space using the player's head rotation. (Modified to fix the return path.)"
)
public class BezierMovement extends AbstractMovementSettings implements ICameraMovement {
    // --- Settings ---
    @MovementSetting(label = "Position Easing", min = 0.01, max = 1.0)
    private double positionEasing = 0.1;
    @MovementSetting(label = "Position Speed Limit", min = 0.1, max = 100.0)
    private double positionSpeedLimit = 10;
    @MovementSetting(label = "Rotation Easing", min = 0.01, max = 1.0)
    private double rotationEasing = 0.1;
    @MovementSetting(label = "Rotation Speed Limit", min = 0.1, max = 1000)
    private double rotationSpeedLimit = 500;
    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10.0;
    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0;
    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0;
    @MovementSetting(label = "Control Point Displacement", min = 0.0, max = 30)
    private double controlPointDisplacement = 5;
    @MovementSetting(label = "Displacement Angle", min = -180.0, max = 180.0)
    private double displacementAngle = 0.0;
    @MovementSetting(label = "Displacement Angle Variance", min = 0.0, max = 180.0)
    private double displacementAngleVariance = 0.0;
    // --- Internal fields for the canonical Bézier path ---
    // These vectors are expressed in canonical (local) space.
    private Vec3d canonicalStart;
    private Vec3d canonicalEnd;
    private Vec3d canonicalControl;
    // Store the original canonical start (i.e. the original camera offset relative to the player)
    private Vec3d originalCanonicalStart;
    // --- Store the player's original eye position and orientation ---
    private Vec3d originalPlayerEye;
    private float originalPlayerYaw;
    private float originalPlayerPitch;
    private double progress;
    private boolean resetting = false;
    private boolean linearMode = false;
    private boolean distanceChanged = false;
    private float weight = 1.0f;
    private CameraTarget current;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return;
        // Capture the player's eye position and rotation at the start.
        Vec3d playerEye = player.getEyePos();
        float playerYaw = player.getYaw();
        float playerPitch = player.getPitch();
        // Save these original parameters.
        originalPlayerEye = playerEye;
        originalPlayerYaw = playerYaw;
        originalPlayerPitch = playerPitch;
        // Get the camera's current (absolute) position.
        Vec3d absStart = CameraTarget.fromCamera(camera).getPosition();
        // Determine the desired end target.
        CameraTarget camEndTarget = getEndTarget(player, targetDistance);
        Vec3d absEnd = camEndTarget.getPosition();
        // Convert the offsets (relative to the eye) into canonical space.
        canonicalStart = unrotateVectorByYawPitch(absStart.subtract(playerEye), playerYaw, playerPitch);
        canonicalEnd   = unrotateVectorByYawPitch(absEnd.subtract(playerEye), playerYaw, playerPitch);
        // Save the original canonical start for use in the reset.
        originalCanonicalStart = canonicalStart;
        // Compute the control point for the Bézier curve.
        canonicalControl = generateControlPoint(canonicalStart, canonicalEnd);
        progress = 0.0;
        resetting = false;
        linearMode = false;
        distanceChanged = false;
        // Set the initial camera target.
        Vec3d desiredPos = playerEye.add(rotateVectorByYawPitch(canonicalStart, playerYaw, playerPitch));
        current = new CameraTarget(desiredPos, playerYaw, playerPitch);
        weight = 1.0f;
    }
    /**
     * Computes the quadratic Bézier control point between the given canonical start and end.
     */
    private Vec3d generateControlPoint(Vec3d start, Vec3d end) {
        Vec3d mid = start.add(end).multiply(0.5);
        Vec3d diff = end.subtract(start);
        if (diff.lengthSquared() < 1e-6) {
            return mid.add(new Vec3d(0, controlPointDisplacement, 0));
        } else {
            Vec3d tangent = diff.normalize();
            Vec3d worldUp = new Vec3d(0, 1, 0);
            Vec3d projectedUp = worldUp.subtract(tangent.multiply(worldUp.dotProduct(tangent)));
            if (projectedUp.lengthSquared() < 1e-6) {
                Vec3d arbitrary = new Vec3d(1, 0, 0);
                projectedUp = arbitrary.subtract(tangent.multiply(arbitrary.dotProduct(tangent)));
            }
            projectedUp = projectedUp.normalize();
            if (projectedUp.y > 0) {
                projectedUp = projectedUp.multiply(-1);
            }
            double randomOffset = (Math.random() * 2 - 1) * displacementAngleVariance;
            double angleDegrees = displacementAngle + randomOffset;
            double angleRadians = Math.toRadians(angleDegrees);
            Vec3d rotatedUp = projectedUp.multiply(Math.cos(angleRadians))
                    .add(tangent.crossProduct(projectedUp).multiply(Math.sin(angleRadians)));
            Vec3d offset = rotatedUp.multiply(controlPointDisplacement);
            return mid.add(offset);
        }
    }
    /**
     * Returns the point on a quadratic Bézier curve defined by p0, p1, p2 at parameter t.
     */
    private Vec3d quadraticBezier(Vec3d p0, Vec3d p1, Vec3d p2, double t) {
        double oneMinusT = 1.0 - t;
        return p0.multiply(oneMinusT * oneMinusT)
                .add(p1.multiply(2 * oneMinusT * t))
                .add(p2.multiply(t * t));
    }
    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        if (linearMode) Craneshot.LOGGER.info("linear");
        PlayerEntity player = client.player;
        if (player == null) return new MovementState(current, true);
        // Determine canonical endpoints.
        Vec3d startCanon, endCanon;
        if (!resetting) {
            startCanon = canonicalStart;
            endCanon = canonicalEnd;
        } else {
            // For reset, go from canonicalEnd back to the ORIGINAL canonicalStart.
            startCanon = canonicalEnd;
            endCanon = originalCanonicalStart;
        }
        // Compute the total distance between the endpoints (used later for alpha).
        double totalDistance = startCanon.distanceTo(endCanon);
        Vec3d desiredCanonical;
        if (!linearMode) {
            // --- Bezier movement mode ---
            // Advance the progress along the curve using positionEasing and limiting the delta so that
            // the movement does not exceed positionSpeedLimit per tick.
            double potentialDelta = (1.0 - progress) * positionEasing;
            double maxMove = positionSpeedLimit * (1.0 / 20.0); // maximum allowed movement per tick
            double allowedDelta = totalDistance > 0 ? maxMove / totalDistance : potentialDelta;
            double progressDelta = Math.min(potentialDelta, allowedDelta);
            progress = Math.min(1.0, progress + progressDelta);
            // Get the canonical position along the quadratic Bézier curve.
            desiredCanonical = quadraticBezier(startCanon, canonicalControl, endCanon, progress);
        } else {
            // --- Linear movement mode ---
            // Instead of moving along the Bézier, convert the current camera position into canonical space,
            // then move it directly toward the target endpoint.
            Vec3d playerEye = player.getEyePos();
            float playerYaw = player.getYaw();
            float playerPitch = player.getPitch();
            // Convert current absolute camera position to canonical coordinates.
            Vec3d currentCanon = unrotateVectorByYawPitch(current.getPosition().subtract(playerEye), playerYaw, playerPitch);
            // Compute the difference from the current position to the target.
            Vec3d delta = endCanon.subtract(currentCanon);
            double deltaLength = delta.length();
            double maxMove = positionSpeedLimit * (1.0 / 20.0); // maximum movement per tick
            // Calculate the movement step: scale the delta by positionEasing, but clamp its length to maxMove.
            Vec3d move;
            if (deltaLength > 0) {
                move = delta.multiply(positionEasing);
                if (move.length() > maxMove) {
                    move = move.normalize().multiply(maxMove);
                }
            } else {
                move = Vec3d.ZERO;
            }
            // The new canonical target is the current position plus the clamped move vector.
            desiredCanonical = currentCanon.add(move);
        }
        // Convert the desired canonical position back to absolute world space using the player's current eye position and rotation.
        Vec3d conversionEye = player.getEyePos();
        float conversionYaw = player.getYaw();
        float conversionPitch = player.getPitch();
        Vec3d desiredAbs = conversionEye.add(rotateVectorByYawPitch(desiredCanonical, conversionYaw, conversionPitch));
        // --- Rotation easing (remains the same) ---
        float targetYaw, targetPitch;
        if (!resetting && this.endTarget == END_TARGET.FRONT) {
            targetYaw = conversionYaw + 180f;
            targetPitch = -conversionPitch;
        } else {
            targetYaw = conversionYaw;
            targetPitch = conversionPitch;
        }
        float yawError = targetYaw - current.getYaw();
        float pitchError = targetPitch - current.getPitch();
        while (yawError > 180) yawError -= 360;
        while (yawError < -180) yawError += 360;
        float desiredYawSpeed = (float)(yawError * rotationEasing);
        float desiredPitchSpeed = (float)(pitchError * rotationEasing);
        float maxRotation = (float)(rotationSpeedLimit * (1.0 / 20.0));
        if (Math.abs(desiredYawSpeed) > maxRotation) {
            desiredYawSpeed = Math.signum(desiredYawSpeed) * maxRotation;
        }
        if (Math.abs(desiredPitchSpeed) > maxRotation) {
            desiredPitchSpeed = Math.signum(desiredPitchSpeed) * maxRotation;
        }
        float newYaw = current.getYaw() + desiredYawSpeed;
        float newPitch = current.getPitch() + desiredPitchSpeed;
        current = new CameraTarget(desiredAbs, newYaw, newPitch);
        // Compute a normalized "alpha" value (fraction remaining) for use by other systems if needed.
        double remaining = desiredCanonical.distanceTo(endCanon);
        alpha = totalDistance != 0 ? remaining / totalDistance : 0.0;
        // Once the out phase completes, switch to linear mode and recalc canonical endpoints.
        if (!resetting && progress >= 0.999) {
            linearMode = true;
            Vec3d curEye = player.getEyePos();
            float curYaw = player.getYaw();
            float curPitch = player.getPitch();
            canonicalStart = unrotateVectorByYawPitch(current.getPosition().subtract(curEye), curYaw, curPitch);
            canonicalEnd = unrotateVectorByYawPitch(getEndTarget(player, targetDistance)
                    .getPosition().subtract(curEye), curYaw, curPitch);
        }
        boolean complete = resetting && progress >= 0.999;
        return new MovementState(current, complete);
    }
    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        if (client.player == null) return;
        if (!resetting) {
            resetting = true;
            linearMode = false;
            progress = 1.0 - progress;
            canonicalControl = generateControlPoint(canonicalEnd, originalCanonicalStart);
            if (CraneshotClient.CAMERA_CONTROLLER.getMovementManager() != null) {
                CraneshotClient.CAMERA_CONTROLLER.getMovementManager().resetMovement(this);
            }
        }
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? 1.1 : 0.9;
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
        if (linearMode) {
            distanceChanged = true;
        }
    }
    @Override
    public String getName() {
        return "Bezier (Canonical Relative)";
    }
    @Override
    public float getWeight() {
        return weight;
    }
    @Override
    public boolean isComplete() {
        return resetting && progress >= 0.999;
    }
    /**
     * Converts a canonical (local) vector into world space using the given yaw and pitch.
     * (In canonical space a level, south–facing view has forward = (0,0,1).)
     */
    private Vec3d rotateVectorByYawPitch(Vec3d canonical, float playerYaw, float playerPitch) {
        double yawRad   = Math.toRadians(playerYaw);
        double pitchRad = Math.toRadians(playerPitch);
        // Compute forward vector.
        Vec3d forward = new Vec3d(
                -Math.sin(yawRad) * Math.cos(pitchRad),
                -Math.sin(pitchRad),
                Math.cos(yawRad) * Math.cos(pitchRad)
        );
        // Right vector is independent of pitch.
        Vec3d right = new Vec3d(
                Math.cos(yawRad),
                0,
                Math.sin(yawRad)
        );
        // Up vector computed via cross product.
        Vec3d up = right.crossProduct(forward);
        return right.multiply(canonical.x)
                .add(up.multiply(canonical.y))
                .add(forward.multiply(canonical.z));
    }
    /**
     * Converts a world–space offset (typically relative to the player's eye) into canonical space.
     * This is the inverse of rotateVectorByYawPitch().
     */
    private Vec3d unrotateVectorByYawPitch(Vec3d worldVec, float playerYaw, float playerPitch) {
        double yawRad   = Math.toRadians(playerYaw);
        double pitchRad = Math.toRadians(playerPitch);
        Vec3d forward = new Vec3d(
                -Math.sin(yawRad) * Math.cos(pitchRad),
                -Math.sin(pitchRad),
                Math.cos(yawRad) * Math.cos(pitchRad)
        );
        Vec3d right = new Vec3d(
                Math.cos(yawRad),
                0,
                Math.sin(yawRad)
        );
        Vec3d up = right.crossProduct(forward);
        double xCanonical = worldVec.dotProduct(right);
        double yCanonical = worldVec.dotProduct(up);
        double zCanonical = worldVec.dotProduct(forward);
        return new Vec3d(xCanonical, yCanonical, zCanonical);
    }
    @Override
    public boolean hasCompletedOutPhase() {
        return !resetting && progress >= 0.999;
    }
}
</file>

<file path="movements/LinearMovement.java">
package ninja.trek.cameramovements.movements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.CraneshotClient;
import ninja.trek.cameramovements.CameraMovementType;
import ninja.trek.cameramovements.CameraTarget;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.MovementState;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.config.MovementSetting;
@CameraMovementType(
        name = "Linear Movement",
        description = "Moves the camera with linear interpolation and position controls"
)
public class LinearMovement extends AbstractMovementSettings implements ICameraMovement {
    @MovementSetting(label = "Position Easing", min = 0.01, max = 1.0)
    private double positionEasing = 0.1;
    @MovementSetting(label = "Position Speed Limit", min = 0.1, max = 100.0)
    private double positionSpeedLimit = 2.0;
    @MovementSetting(label = "Rotation Easing", min = 0.01, max = 1.0)
    private double rotationEasing = 0.1;
    @MovementSetting(label = "Rotation Speed Limit", min = 0.1, max = 3600.0)
    private double rotationSpeedLimit = 45.0;
    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10.0;
    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0;
    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0;
    public CameraTarget start = new CameraTarget(), end = new CameraTarget(), current = new CameraTarget();
    private boolean resetting = false;
    private float weight = 1.0f;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return;
        start = CameraTarget.fromCamera(camera);
        current = CameraTarget.fromCamera(camera);
        end = getEndTarget(player, targetDistance);
        resetting = false;
        weight = 1.0f;
    }
    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return new MovementState(current, true);
        start.set(player.getEyePos(),
                player.getYaw(),
                player.getPitch());
        end.set(getEndTarget(player, targetDistance));
        CameraTarget a, b;
        if (!resetting) {
            a = start;
            b = end;
        } else {
            a = end;
            b = start;
        }
        // Position interpolation with speed limit
        Vec3d desired = current.getPosition().lerp(b.getPosition(), positionEasing);
        Vec3d moveVector = desired.subtract(current.getPosition());
        double moveDistance = moveVector.length();
        if (moveDistance > 0.01) {
            double maxMove = positionSpeedLimit * (1.0/20.0); // Convert blocks/second to blocks/tick
            if (moveDistance > maxMove) {
                Vec3d limitedMove = moveVector.normalize().multiply(maxMove);
                desired = current.getPosition().add(limitedMove);
            }
        }
        // Rotation interpolation with speed limit
        float targetYaw = b.getYaw();
        float targetPitch = b.getPitch();
        // Calculate rotation with easing first
        float yawDiff = targetYaw - current.getYaw();
        float pitchDiff = targetPitch - current.getPitch();
// Normalize angles to [-180, 180]
        while (yawDiff > 180) yawDiff -= 360;
        while (yawDiff < -180) yawDiff += 360;
// Apply easing to get desired rotation speed
        float desiredYawSpeed = (float)(yawDiff * rotationEasing);
        float desiredPitchSpeed = (float)(pitchDiff * rotationEasing);
// Apply rotation speed limit
        float maxRotation = (float)(rotationSpeedLimit * (1.0/20.0)); // Convert degrees/second to degrees/tick
        if (Math.abs(desiredYawSpeed) > maxRotation) {
            desiredYawSpeed = Math.signum(desiredYawSpeed) * maxRotation;
        }
        if (Math.abs(desiredPitchSpeed) > maxRotation) {
            desiredPitchSpeed = Math.signum(desiredPitchSpeed) * maxRotation;
        }
        // Apply the final rotation
        float newYaw = current.getYaw() + desiredYawSpeed;
        float newPitch = current.getPitch() + desiredPitchSpeed;
        current = new CameraTarget(
                desired,
                newYaw,
                newPitch
        );
        alpha = current.getPosition().distanceTo(b.getPosition()) / a.getPosition().distanceTo(b.getPosition());
        boolean complete = resetting && moveDistance < 0.01;
        return new MovementState(current, complete);
    }
    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        if (client.player == null) return;
        resetting = true;
        if (CraneshotClient.CAMERA_CONTROLLER.getMovementManager() != null) {
            CraneshotClient.CAMERA_CONTROLLER.getMovementManager().resetMovement(this);
        }
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? 1.1 : 0.9;
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
    }
    @Override
    public String getName() {
        return "Linear";
    }
    @Override
    public float getWeight() {
        return weight;
    }
    @Override
    public boolean isComplete() {
        return resetting && current.getPosition().distanceTo(start.getPosition()) < 0.01;
    }
    @Override
    public boolean hasCompletedOutPhase() {
        return !resetting && current.getPosition().distanceTo(end.getPosition()) < 0.01;
    }
}
</file>

<file path="MovementState.java">
package ninja.trek.cameramovements;
public class MovementState {
    private final CameraTarget target;
    private final boolean isComplete;
    public MovementState(CameraTarget target, boolean isComplete) {
        this.target = target;
        this.isComplete = isComplete;
    }
    public CameraTarget getCameraTarget() {
        return target;
    }
    public boolean isComplete() {
        return isComplete;
    }
}
</file>

<file path="RaycastType.java">
package ninja.trek.cameramovements;
/**
 * Enum defining different raycast behaviors for camera collision handling
 */
public enum RaycastType {
    /**
     * No raycast collision checking - camera can clip through blocks
     */
    NONE,
    /**
     * Raycasts from player to desired camera position.
     * If collision detected, moves camera closer to player.
     * Behaves like default Minecraft third person camera.
     */
    NEAR,
    /**
     * Raycasts from desired camera position towards player.
     * If camera would be inside block, moves it to first non-solid position.
     * Provides more stable distant shots by preferring to keep camera far out.
     */
    FAR
}
</file>

<file path="RaycastUtil.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.RaycastContext;
public class RaycastUtil {
    private static final double CAMERA_OFFSET = 0.5;
    private static final double STEP_SIZE = 0.5;
    private static final double FINE_STEP_SIZE = 0.1;
    public static Vec3d adjustForCollision(Vec3d playerPos, Vec3d targetPos, RaycastType raycastType) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.world == null || raycastType == RaycastType.NONE) {
            return targetPos;
        }
        switch (raycastType) {
            case NEAR:
                return handleNearRaycast(client, playerPos, targetPos);
            case FAR:
                return handleFarRaycast(client, playerPos, targetPos);
            default:
                return targetPos;
        }
    }
    private static Vec3d handleNearRaycast(MinecraftClient client, Vec3d playerPos, Vec3d targetPos) {
        BlockHitResult hit = client.world.raycast(new RaycastContext(
                playerPos,
                targetPos,
                RaycastContext.ShapeType.VISUAL,
                RaycastContext.FluidHandling.NONE,
                client.player
        ));
        if (hit.getType() == HitResult.Type.BLOCK) {
            Vec3d hitPos = hit.getPos();
            Vec3d directionVector = hitPos.subtract(playerPos).normalize();
            return hitPos.subtract(directionVector.multiply(CAMERA_OFFSET));
        }
        return targetPos;
    }
    private static Vec3d handleFarRaycast(MinecraftClient client, Vec3d playerPos, Vec3d targetPos) {
        Vec3d direction = targetPos.subtract(playerPos).normalize();
        double totalDistance = targetPos.distanceTo(playerPos);
        // Start from target position
        Vec3d currentPos = targetPos;
        if (isPositionInAir(client, currentPos)) {
            return refinePosition(client, currentPos, direction);
        }
        // Coarse search
        for (double distance = STEP_SIZE; distance < totalDistance; distance += STEP_SIZE) {
            Vec3d checkPos = targetPos.subtract(direction.multiply(distance));
            if (isPositionInAir(client, checkPos)) {
                return refinePosition(client, checkPos, direction.multiply(-1));
            }
        }
        return playerPos;
    }
    private static Vec3d refinePosition(MinecraftClient client, Vec3d startPos, Vec3d direction) {
        // Raycast forward until we hit something
        BlockHitResult hit = client.world.raycast(new RaycastContext(
                startPos,
                startPos.add(direction.multiply(2.0)), // Look 2 blocks ahead
                RaycastContext.ShapeType.VISUAL,
                RaycastContext.FluidHandling.NONE,
                client.player
        ));
        if (hit.getType() == HitResult.Type.BLOCK) {
            Vec3d hitPos = hit.getPos();
            return hitPos.subtract(direction.multiply(CAMERA_OFFSET));
        }
        return startPos;
    }
    private static boolean isPositionInAir(MinecraftClient client, Vec3d pos) {
        BlockPos blockPos = BlockPos.ofFloored(pos);
        return client.world.getBlockState(blockPos).isAir();
    }
}
</file>

</files>
