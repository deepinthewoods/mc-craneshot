This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-08T15:25:15.878Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/CameraController.java
client/java/ninja/trek/CameraMovementManager.java
client/java/ninja/trek/CameraMovementRegistry.java
client/java/ninja/trek/cameramovements/AbstractMovementSettings.java
client/java/ninja/trek/cameramovements/CameraMovementType.java
client/java/ninja/trek/cameramovements/CameraState.java
client/java/ninja/trek/cameramovements/CameraTarget.java
client/java/ninja/trek/cameramovements/ICameraMovement.java
client/java/ninja/trek/cameramovements/move8.txt
client/java/ninja/trek/cameramovements/movements/BezierMovement.java
client/java/ninja/trek/cameramovements/movements/LinearMovement.java
client/java/ninja/trek/cameramovements/MovementState.java
client/java/ninja/trek/cameramovements/RaycastType.java
client/java/ninja/trek/cameramovements/RaycastUtil.java
client/java/ninja/trek/config/FreeCamSettings.java
client/java/ninja/trek/config/GeneralMenuSettings.java
client/java/ninja/trek/config/GeneralSettingsIO.java
client/java/ninja/trek/config/MenuOverlayScreen.java
client/java/ninja/trek/config/MovementSetting.java
client/java/ninja/trek/config/MovementSettingType.java
client/java/ninja/trek/config/RenameModal.java
client/java/ninja/trek/config/SettingSlider.java
client/java/ninja/trek/config/SettingWidget.java
client/java/ninja/trek/config/SlotMenuSettings.java
client/java/ninja/trek/config/SlotSettingsIO.java
client/java/ninja/trek/config/WrapSettings.java
client/java/ninja/trek/CraneshotClient.java
client/java/ninja/trek/CraneshotDataGenerator.java
client/java/ninja/trek/CraneShotEventHandler.java
client/java/ninja/trek/IKeyboardInputMixin.java
client/java/ninja/trek/IMouseMixin.java
client/java/ninja/trek/mixin/client/CameraAccessor.java
client/java/ninja/trek/mixin/client/CameraMixin.java
client/java/ninja/trek/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/mixin/client/KeyboardInputMixin.java
client/java/ninja/trek/mixin/client/MouseAccessor.java
client/java/ninja/trek/mixin/client/MouseMixin.java
client/java/ninja/trek/mixin/client/TransparencyMixin.java
client/java/ninja/trek/mixin/client/WorldRendererMixin.java
client/java/ninja/trek/MouseInterceptor.java
client/resources/craneshot.client.mixins.json
main/java/ninja/trek/Craneshot.java
main/java/ninja/trek/mixin/ExampleMixin.java
main/resources/craneshot.mixins.json
main/resources/fabric.mod.json
repomixx - cameramovements folder.bat
repomixx - ignore config.bat
repomixx - movements only.bat
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/CameraController.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.option.Perspective;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.BlockView;
import ninja.trek.cameramovements.*;
import ninja.trek.config.SlotMenuSettings;
import ninja.trek.mixin.client.*;
import ninja.trek.cameramovements.AbstractMovementSettings.POST_MOVE_KEYS;
import ninja.trek.cameramovements.AbstractMovementSettings.POST_MOVE_MOUSE;
import java.util.*;
public class CameraController {
    private List<List<ICameraMovement>> slots;
    private final ArrayList<Integer> currentTypes;
    private CameraMovementManager movementManager;
    private Integer activeMovementSlot;
    public static final double FIRST_PERSON_THRESHOLD_MIN = 2.0;
    public static final double FIRST_PERSON_THRESHOLD_MAX = 5.0;
    private String currentMessage = "";
    private long messageTimer = 0;
    private static final long MESSAGE_DURATION = 2000;
    public static POST_MOVE_KEYS currentKeyMoveMode = POST_MOVE_KEYS.NONE;
    public static POST_MOVE_MOUSE currentMouseMoveMode = POST_MOVE_MOUSE.NONE;
    public static Vec3d freeCamPosition;
    public static float freeCamYaw;
    public static float freeCamPitch;
    public static CameraTarget controlStick = new CameraTarget();
    private Map<Integer, Boolean> toggledStates = new HashMap<>();
    public CameraController() {
        slots = new ArrayList<>();
        currentTypes = new ArrayList<>();
        movementManager = new CameraMovementManager();
        activeMovementSlot = null;
        for (int i = 0; i < 3; i++) {
            currentTypes.add(0);
        }
    }
    private void updateControlStick(MinecraftClient client) {
        if (client.player == null) return;
        Camera camera = client.gameRenderer.getCamera();
        if (camera != null) {
            controlStick.set(
                    client.player.getEyePos(),
                    client.player.getYaw(),
                    client.player.getPitch()
            );
        }
    }
    private void handleFreeControl(MinecraftClient client, Camera camera) {
        // Handle keyboard movement if enabled
        if (currentKeyMoveMode != POST_MOVE_KEYS.NONE) {
            handleKeyboardMovement(client, camera);
        }
        // Only handle mouse rotation when FREE_MOUSE is explicitly enabled
        if (currentMouseMoveMode == POST_MOVE_MOUSE.ROTATE_CAMERA && client.mouse instanceof IMouseMixin) {
            IMouseMixin mouseMixin = (IMouseMixin) client.mouse;
            // Get mouse movement deltas
            double deltaX = mouseMixin.getCapturedDeltaX();
            double deltaY = -mouseMixin.getCapturedDeltaY();
            // Apply mouse sensitivity
            Double mouseSensitivity = MinecraftClient.getInstance().options.getMouseSensitivity().getValue();
            double scaledSensitivity = 0.6 * mouseSensitivity * mouseSensitivity + 0.2;
            // Update freeCam orientation
            freeCamYaw += (float)(deltaX * scaledSensitivity);
            freeCamPitch = Math.max(-90, Math.min(90, freeCamPitch - (float)(deltaY * scaledSensitivity)));
            // Apply rotation to camera
            ((CameraAccessor)camera).invokeSetRotation(freeCamYaw, freeCamPitch);
        } else {
            // When FREE_MOUSE is not enabled, sync with current camera orientation
            freeCamYaw = camera.getYaw();
            freeCamPitch = camera.getPitch();
        }
        // Always update camera position regardless of movement mode
        ((CameraAccessor)camera).invokesetPos(freeCamPosition);
    }
    private void updateKeyboardInput(MinecraftClient client) {
        if (client.player != null && client.player.input instanceof IKeyboardInputMixin) {
            boolean shouldDisable = currentKeyMoveMode != POST_MOVE_KEYS.NONE;
            ((IKeyboardInputMixin) client.player.input).setDisabled(shouldDisable);
        }
    }
    public void tick(MinecraftClient client, Camera camera) {
        updateControlStick(client);
        // Check if we're in any kind of post-move control mode
        boolean inPostMoveMode = currentKeyMoveMode != POST_MOVE_KEYS.NONE ||
                currentMouseMoveMode != POST_MOVE_MOUSE.NONE;
        if (!inPostMoveMode) {
            movementManager.update(client, camera);
            // Check for movement completion and post-movement behavior
            if (activeMovementSlot != null) {
                ICameraMovement movement = getMovementAt(activeMovementSlot);
                if (movement instanceof AbstractMovementSettings && movement.hasCompletedOutPhase()) {
                    AbstractMovementSettings settings = (AbstractMovementSettings) movement;
                    // Set the movement modes based on settings
                    currentMouseMoveMode = settings.getPostMoveMouse();
                    currentKeyMoveMode = settings.getPostMoveKeys();
                    if (currentMouseMoveMode != POST_MOVE_MOUSE.NONE ||
                            currentKeyMoveMode != POST_MOVE_KEYS.NONE) {
                        // Initialize free camera with current camera state
                        Vec3d finalPos = movement.calculateState(client, camera).getCameraTarget().getPosition();
                        freeCamPosition = finalPos;
                        freeCamYaw = camera.getYaw();
                        freeCamPitch = camera.getPitch();
                        // Apply initial state to camera
                        ((CameraAccessor)camera).invokesetPos(freeCamPosition);
                        ((CameraAccessor)camera).invokeSetRotation(freeCamYaw, freeCamPitch);
                        // Enable mouse interception if needed
                        if (currentMouseMoveMode == POST_MOVE_MOUSE.ROTATE_CAMERA) {
                            MouseInterceptor.setIntercepting(true);
                        }
                        return;
                    }
                }
            }
        }
        updatePerspective(client, camera);
    }
    public void handleCameraUpdate(BlockView area, Entity focusedEntity, boolean thirdPerson,
                                   boolean inverseView, float tickDelta, Camera camera) {
        if (camera == null || focusedEntity == null) return;
        MinecraftClient client = MinecraftClient.getInstance();
        if (client == null || client.world == null) return;
        boolean inPostMoveMode = currentKeyMoveMode != POST_MOVE_KEYS.NONE ||
                currentMouseMoveMode != POST_MOVE_MOUSE.NONE;
        if (inPostMoveMode) {
            handleFreeControl(client, camera);
        } else {
            tick(client, camera);
        }
        updateKeyboardInput(client);
        updateMessageTimer();
    }
    public void queueFinish(MinecraftClient client, Camera camera) {
        // Clean up any active post-move controls
        if (currentMouseMoveMode == POST_MOVE_MOUSE.ROTATE_CAMERA) {
            MouseInterceptor.setIntercepting(false);
        }
        updateKeyboardInput(client);
        freeCamPosition = camera.getPos();
        freeCamYaw = camera.getYaw();
        freeCamPitch = camera.getPitch();
        // Reset control modes
        currentMouseMoveMode = POST_MOVE_MOUSE.NONE;
        currentKeyMoveMode = POST_MOVE_KEYS.NONE;
        if (activeMovementSlot != null) {
            ICameraMovement movement = getMovementAt(activeMovementSlot);
            if (movement != null) {
                movement.queueReset(client, camera);
            }
            activeMovementSlot = null;
        }
    }
    private void handleKeyboardMovement(MinecraftClient client, Camera camera) {
        float speed = 0.5f; // Base movement speed
        Vec3d movement = Vec3d.ZERO;
        if (currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            // Use current camera orientation for movement calculations
            float yaw = freeCamYaw;   // Current camera yaw
            float pitch = freeCamPitch; // Current camera pitch
            // Calculate view vectors based on current camera orientation
            // Forward vector - where the camera is looking
            Vec3d forward = new Vec3d(
                    -Math.sin(Math.toRadians(yaw)) * Math.cos(Math.toRadians(pitch)),
                    -Math.sin(Math.toRadians(pitch)),
                    Math.cos(Math.toRadians(yaw)) * Math.cos(Math.toRadians(pitch))
            ).normalize();
            // Right vector - perpendicular to forward and world up
            Vec3d worldUp = new Vec3d(0, 1, 0);
            Vec3d right = worldUp.crossProduct(forward).normalize();
            // Up vector - perpendicular to forward and right
            Vec3d up = forward.crossProduct(right).normalize();
            // Apply movement based on key presses
            if (client.options.forwardKey.isPressed()) movement = movement.add(forward);
            if (client.options.backKey.isPressed()) movement = movement.subtract(forward);
            if (client.options.leftKey.isPressed()) movement = movement.add(right);
            if (client.options.rightKey.isPressed()) movement = movement.subtract(right);
            if (client.options.jumpKey.isPressed()) movement = movement.add(up);
            if (client.options.sneakKey.isPressed()) movement = movement.subtract(up);
        }
        else if (currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT) {
            // Y-axis locked camera-relative movement remains unchanged
            float yaw = freeCamYaw;
            Vec3d forward = new Vec3d(
                    -Math.sin(Math.toRadians(yaw)),
                    0,
                    Math.cos(Math.toRadians(yaw))
            );
            Vec3d right = new Vec3d(
                    Math.cos(Math.toRadians(yaw)),
                    0,
                    Math.sin(Math.toRadians(yaw))
            );
            if (client.options.forwardKey.isPressed()) movement = movement.add(forward);
            if (client.options.backKey.isPressed()) movement = movement.subtract(forward);
            if (client.options.leftKey.isPressed()) movement = movement.add(right);
            if (client.options.rightKey.isPressed()) movement = movement.subtract(right);
            if (client.options.jumpKey.isPressed()) movement = movement.add(0, 1, 0);
            if (client.options.sneakKey.isPressed()) movement = movement.add(0, -1, 0);
        }
        else if (currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE8) {
            // MOVE8 logic remains unchanged
            if (client.player != null) {
                float cameraYaw = freeCamYaw;
                boolean moving = false;
                float targetYaw = cameraYaw;
                if (client.options.forwardKey.isPressed()) {
                    if (client.options.leftKey.isPressed()) {
                        targetYaw += 45;
                        moving = true;
                    } else if (client.options.rightKey.isPressed()) {
                        targetYaw -= 45;
                        moving = true;
                    } else {
                        moving = true;
                    }
                } else if (client.options.backKey.isPressed()) {
                    if (client.options.leftKey.isPressed()) {
                        targetYaw += 135;
                        moving = true;
                    } else if (client.options.rightKey.isPressed()) {
                        targetYaw -= 135;
                        moving = true;
                    } else {
                        targetYaw += 180;
                        moving = true;
                    }
                } else if (client.options.leftKey.isPressed()) {
                    targetYaw += 90;
                    moving = true;
                } else if (client.options.rightKey.isPressed()) {
                    targetYaw -= 90;
                    moving = true;
                }
                // Normalize the target yaw
                while (targetYaw > 180) targetYaw -= 360;
                while (targetYaw < -180) targetYaw += 360;
                // Set the player's rotation
                client.player.setYaw(targetYaw);
                // Handle movement
                if (moving) {
                    if (client.player.input instanceof IKeyboardInputMixin) {
                        IKeyboardInputMixin input = (IKeyboardInputMixin) client.player.input;
                        input.setDisabled(false);
                        client.player.input.movementForward = 1.0f;
                        client.player.input.movementSideways = 0.0f;
                    }
                }
                // Handle jumping and sneaking
                if (client.options.jumpKey.isPressed() && client.player.isOnGround()) {
                    client.player.jump();
                }
                client.player.setSneaking(client.options.sneakKey.isPressed());
                return;
            }
        }
        // Apply movement if any
        if (movement.lengthSquared() > 0) {
            movement = movement.normalize().multiply(speed);
            Vec3d newPos = freeCamPosition.add(movement);
            ((CameraAccessor)camera).invokesetPos(newPos);
            freeCamPosition = newPos;
        }
    }
    public void startTransition(MinecraftClient client, Camera camera, int movementIndex) {
        ICameraMovement movement = getMovementAt(movementIndex);
        if (movement == null) return;
        // If this slot is already active, just stop it
        if (activeMovementSlot != null && activeMovementSlot == movementIndex) {
            queueFinish(client, camera);
            return;
        }
        // Clear any existing movement and start the new one
        queueFinish(client, camera);
        activeMovementSlot = movementIndex;
        movement.start(client, camera);
        movementManager.addMovement(movement, client, camera);
    }
    private void updatePerspective(MinecraftClient client, Camera camera) {
        //we do this just to switch the player model rendering on or off
        if (client.player == null) return;
        double distance = camera.getPos().distanceTo(client.player.getEyePos());
        if (distance > FIRST_PERSON_THRESHOLD_MIN &&
                client.options.getPerspective() == Perspective.FIRST_PERSON) {
            Craneshot.LOGGER.info("first person p");
            client.options.setPerspective(Perspective.THIRD_PERSON_BACK);
        } else if (distance < FIRST_PERSON_THRESHOLD_MIN &&
                client.options.getPerspective() != Perspective.FIRST_PERSON) {
            Craneshot.LOGGER.info("threds person p");
            client.options.setPerspective(Perspective.FIRST_PERSON);
        }
    }
    // Message handling methods
    public void showMessage(String message) {
        currentMessage = message;
        messageTimer = System.currentTimeMillis() + MESSAGE_DURATION;
    }
    public String getCurrentMessage() {
        return currentMessage;
    }
    public boolean hasActiveMessage() {
        return System.currentTimeMillis() < messageTimer;
    }
    private void updateMessageTimer() {
        if (System.currentTimeMillis() >= messageTimer) {
            currentMessage = "";
        }
    }
    public void showMovementTypeMessage(int slotIndex) {
        ICameraMovement movement = getMovementAt(slotIndex);
        if (movement != null) {
            showMessage(String.format(
                    "Camera %d: %s Movement",
                    slotIndex + 1,
                    movement.getName()
            ));
        }
    }
    public void cycleMovementType(boolean forward, int slotIndex) {
        if (slotIndex < 0 || slotIndex >= slots.size()) return;
        List<ICameraMovement> slotMovements = slots.get(slotIndex);
        if (slotMovements.isEmpty()) return;
        int currentType = currentTypes.get(slotIndex);
        boolean wrap = SlotMenuSettings.getWrapState(slotIndex);
        // Calculate new index
        int newType;
        if (forward) {
            if (currentType < slotMovements.size() - 1 || wrap) {
                newType = wrap ?
                        (currentType + 1) % slotMovements.size() :
                        Math.min(currentType + 1, slotMovements.size() - 1);
            } else {
                return;
            }
        } else {
            if (currentType > 0 || wrap) {
                newType = wrap ?
                        (currentType - 1 + slotMovements.size()) % slotMovements.size() :
                        Math.max(currentType - 1, 0);
            } else {
                return;
            }
        }
        // Update the type
        currentTypes.set(slotIndex, newType);
        // Show message about the new movement type
        ICameraMovement newMovement = slotMovements.get(newType);
        if (newMovement != null) {
            showMessage(String.format(
                    "Camera %d: %s Movement",
                    slotIndex + 1,
                    newMovement.getName()
            ));
        }
    }
    // Overloaded method for cycling the active slot
    public void cycleMovementType(boolean forward) {
        if (activeMovementSlot != null) {
            cycleMovementType(forward, activeMovementSlot);
        }
    }
    public void adjustDistance(int index, boolean increase) {
        ICameraMovement movement = getMovementAt(index);
        if (movement != null) {
            movement.adjustDistance(increase);
        }
    }
    // Slot management methods
    public void addMovement(int slotIndex, ICameraMovement movement) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            slots.get(slotIndex).add(movement);
        }
    }
    public void removeMovement(int slotIndex, int movementIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (movementIndex >= 0 && movementIndex < slotMovements.size() && slotMovements.size() > 1) {
                slotMovements.remove(movementIndex);
                if (currentTypes.get(slotIndex) >= slotMovements.size()) {
                    currentTypes.set(slotIndex, slotMovements.size() - 1);
                }
            }
        }
    }
    // Getter methods
    public int getMovementCount() {
        return slots.size();
    }
    public ICameraMovement getMovementAt(int index) {
        if (index >= 0 && index < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(index);
            int currentType = currentTypes.get(index);
            if (!slotMovements.isEmpty() && currentType < slotMovements.size()) {
                return slotMovements.get(currentType);
            }
        }
        return null;
    }
    public List<ICameraMovement> getAvailableMovementsForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            return new ArrayList<>(slots.get(slotIndex));
        }
        return new ArrayList<>();
    }
    public void swapMovements(int slotIndex, int index1, int index2) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (index1 >= 0 && index1 < slotMovements.size() &&
                    index2 >= 0 && index2 < slotMovements.size()) {
                Collections.swap(slotMovements, index1, index2);
            }
        }
    }
    public void setAllSlots(List<List<ICameraMovement>> savedSlots) {
        this.slots = savedSlots;
    }
    public void handleKeyStateChange(int keyIndex, boolean pressed, MinecraftClient client, Camera camera) {
        boolean isToggleMode = SlotMenuSettings.getToggleState(keyIndex);
        if (pressed) {
            // If a different movement is active, stop it first
            if (activeMovementSlot != null && activeMovementSlot != keyIndex) {
                // Untoggle the previous movement if it was toggled
                toggledStates.put(activeMovementSlot, false);
                queueFinish(client, camera);
            }
            if (isToggleMode) {
                // Toggle mode: flip the state
                boolean currentToggled = toggledStates.getOrDefault(keyIndex, false);
                boolean newToggled = !currentToggled;
                toggledStates.put(keyIndex, newToggled);
                if (newToggled) {
                    startTransition(client, camera, keyIndex);
                } else {
                    queueFinish(client, camera);
                }
            } else {
                // Momentary mode: just start the movement
                startTransition(client, camera, keyIndex);
            }
        } else if (!isToggleMode) {
            // Key released in momentary mode: stop the movement
            if (activeMovementSlot != null && activeMovementSlot == keyIndex) {
                queueFinish(client, camera);
            }
        }
    }
    public CameraMovementManager getMovementManager() {
        return movementManager;
    }
}
</file>

<file path="client/java/ninja/trek/CameraMovementManager.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import ninja.trek.cameramovements.*;
import ninja.trek.mixin.client.CameraAccessor;
public class CameraMovementManager {
    private ICameraMovement activeMovement = null;
    private CameraTarget originalTarget = null;
    private CameraTarget freeMovementTarget = null;
    public void addMovement(ICameraMovement movement, MinecraftClient client, Camera camera) {
        // Clear any existing movement first
        if (activeMovement != null) {
            activeMovement.queueReset(client, camera);
        }
        // Start the new movement
        movement.start(client, camera);
        activeMovement = movement;
        originalTarget = CameraTarget.fromCamera(camera);
    }
    public void update(MinecraftClient client, Camera camera) {
        if (activeMovement == null || client.player == null) return;
        MovementState state = activeMovement.calculateState(client, camera);
        if (state.isComplete()) {
            activeMovement = null;
            originalTarget = null;
            freeMovementTarget = null;
            return;
        }
        CameraTarget targetToUse;
        if (activeMovement instanceof AbstractMovementSettings &&
                ((ICameraMovement)activeMovement).hasCompletedOutPhase() &&
                ((AbstractMovementSettings)activeMovement).getPostMoveMouse() != AbstractMovementSettings.POST_MOVE_MOUSE.NONE) {
            // Use stored free movement target if it exists, otherwise create one
            if (freeMovementTarget == null) {
                freeMovementTarget = CameraTarget.fromCamera(camera);
            }
            targetToUse = freeMovementTarget;
        } else {
            targetToUse = state.getCameraTarget()
                    .withAdjustedPosition(client.player, activeMovement.getRaycastType());
        }
        // Apply the camera target
        CameraTarget finalTarget = targetToUse
                .withAdjustedPosition(client.player, RaycastType.NONE);
        applyCameraTarget(finalTarget, camera);
        // Update free movement target if needed
        if (activeMovement instanceof AbstractMovementSettings &&
                ((ICameraMovement)activeMovement).hasCompletedOutPhase() &&
                ((AbstractMovementSettings)activeMovement).getPostMoveMouse() != AbstractMovementSettings.POST_MOVE_MOUSE.NONE) {
            freeMovementTarget = CameraTarget.fromCamera(camera);
        }
    }
    public void resetMovement(ICameraMovement movement) {
        if (movement == activeMovement && originalTarget != null) {
            freeMovementTarget = originalTarget;
        }
    }
    private void applyCameraTarget(CameraTarget target, Camera camera) {
        CameraAccessor accessor = (CameraAccessor) camera;
        accessor.invokesetPos(target.getPosition());
        accessor.invokeSetRotation(target.getYaw(), target.getPitch());
    }
}
</file>

<file path="client/java/ninja/trek/CameraMovementRegistry.java">
package ninja.trek;
import ninja.trek.cameramovements.CameraMovementType;
import ninja.trek.cameramovements.ICameraMovement;
import net.fabricmc.loader.api.FabricLoader;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.net.URL;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
public class CameraMovementRegistry {
    private static final List<Class<? extends ICameraMovement>> movementTypes = new ArrayList<>();
    private static int currentTypeIndex = 0;
    private static final String BASE_PACKAGE = "ninja.trek.cameramovements";
    public static void initialize() {
        try {
            scanPackage(BASE_PACKAGE);
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to scan for camera movements", e);
        }
    }
    private static void scanPackage(String packageName) {
        try {
            String path = packageName.replace('.', '/');
            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
            Enumeration<URL> resources = classLoader.getResources(path);
            while (resources.hasMoreElements()) {
                URL resource = resources.nextElement();
                String protocol = resource.getProtocol();
                if (protocol.equals("file")) {
                    scanDirectory(new File(resource.getFile()), packageName);
                } else if (protocol.equals("jar")) {
                    scanJar(resource, path);
                }
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Error scanning package: " + packageName, e);
        }
    }
    private static void scanDirectory(File directory, String packageName) {
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    scanDirectory(file, packageName + "." + file.getName());
                } else if (file.getName().endsWith(".class")) {
                    String className = packageName + "." + file.getName().substring(0, file.getName().length() - 6);
                    processClass(className);
                }
            }
        }
    }
    private static void scanJar(URL resourceUrl, String path) {
        String jarPath = resourceUrl.getPath().substring(5, resourceUrl.getPath().indexOf("!"));
        try (JarFile jarFile = new JarFile(jarPath)) {
            Enumeration<JarEntry> entries = jarFile.entries();
            while (entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String entryName = entry.getName();
                if (entryName.startsWith(path) && entryName.endsWith(".class")) {
                    String className = entryName.substring(0, entryName.length() - 6).replace('/', '.');
                    processClass(className);
                }
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Error scanning JAR file: " + jarPath, e);
        }
    }
    private static void processClass(String className) {
        try {
            Class<?> cls = Class.forName(className);
            if (ICameraMovement.class.isAssignableFrom(cls) &&
                    cls.isAnnotationPresent(CameraMovementType.class)) {
                CameraMovementType annotation = cls.getAnnotation(CameraMovementType.class);
                if (annotation.enabled()) {
                    @SuppressWarnings("unchecked")
                    Class<? extends ICameraMovement> movementClass = (Class<? extends ICameraMovement>) cls;
                    registerMovement(movementClass);
                }
            }
        } catch (ClassNotFoundException e) {
            Craneshot.LOGGER.error("Error loading class: " + className, e);
        }
    }
    public static void registerMovement(Class<? extends ICameraMovement> movementClass) {
        if (!movementTypes.contains(movementClass)) {
            movementTypes.add(movementClass);
        }
    }
    public static ICameraMovement createCurrentMovement() {
        try {
            Constructor<? extends ICameraMovement> constructor = movementTypes.get(currentTypeIndex).getDeclaredConstructor();
            return constructor.newInstance();
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to create movement instance", e);
            return null;
        }
    }
    public static List<MovementInfo> getAllMovements() {
        List<MovementInfo> movements = new ArrayList<>();
        for (Class<? extends ICameraMovement> cls : movementTypes) {
            CameraMovementType annotation = cls.getAnnotation(CameraMovementType.class);
            if (annotation != null) {
                movements.add(new MovementInfo(
                        annotation.name().isEmpty() ? cls.getSimpleName() : annotation.name(),
                        annotation.description(),
                        cls
                ));
            }
        }
        return movements;
    }
    public static void cycleNextMovement() {
        currentTypeIndex = (currentTypeIndex + 1) % movementTypes.size();
    }
    public static String getCurrentMovementName() {
        Class<? extends ICameraMovement> currentClass = movementTypes.get(currentTypeIndex);
        CameraMovementType annotation = currentClass.getAnnotation(CameraMovementType.class);
        return annotation != null && !annotation.name().isEmpty() ?
                annotation.name() : currentClass.getSimpleName();
    }
    public static int getMovementCount() {
        return movementTypes.size();
    }
    // Helper class to hold movement type information
    public static class MovementInfo {
        private final String name;
        private final String description;
        private final Class<? extends ICameraMovement> movementClass;
        public MovementInfo(String name, String description, Class<? extends ICameraMovement> movementClass) {
            this.name = name;
            this.description = description;
            this.movementClass = movementClass;
        }
        public String getName() { return name; }
        public String getDescription() { return description; }
        public Class<? extends ICameraMovement> getMovementClass() { return movementClass; }
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/AbstractMovementSettings.java">
package ninja.trek.cameramovements;
import net.minecraft.entity.player.PlayerEntity;
import ninja.trek.Craneshot;
import ninja.trek.config.MovementSetting;
import ninja.trek.config.MovementSettingType;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;
public abstract class AbstractMovementSettings {
    private String customName = null;
    @MovementSetting(
            label = "Raycast Type",
            type = MovementSettingType.ENUM,
            description = "Controls how the camera handles collision with blocks"
    )
    private RaycastType raycastType = RaycastType.NEAR;
    public double alpha;
    public enum START_TARGET {PLAYER};
    public enum END_TARGET {BACK, FRONT}
    public enum POST_MOVE_MOUSE {
        NONE,       // Default behavior
        ROTATE_CAMERA // Allow free mouse control after movement
           // Allow WASD movement after movement
    }
    @MovementSetting(
            label = "Post-Movement Mouse",
            type = MovementSettingType.ENUM,
            description = "Controls camera behavior after movement completes"
    )
    protected POST_MOVE_MOUSE postMoveMouse = POST_MOVE_MOUSE.NONE;
    public POST_MOVE_MOUSE getPostMoveMouse() {
        return postMoveMouse;
    }
    public enum POST_MOVE_KEYS {
        NONE,       // Default behavior
        MOVE_CAMERA_FLAT, // Y-axis locked camera-relative movement
        MOVE_CAMERA_FREE, // Full camera-relative movement including pitch
        MOVE8       // 8-directional player movement relative to camera
    }
    @MovementSetting(
            label = "Post-Movement Keys",
            type = MovementSettingType.ENUM,
            description = "Controls camera behavior after movement completes"
    )
    protected POST_MOVE_KEYS postMoveKeys = POST_MOVE_KEYS.NONE;
    public POST_MOVE_KEYS getPostMoveKeys(){return postMoveKeys;}
    @MovementSetting(
            label = "Camera Position",
            type = MovementSettingType.ENUM,
            description = "Determines if camera follows in front or behind the player"
    )
    protected END_TARGET endTarget = END_TARGET.BACK;
//    @MovementSetting(
//            label = "Head Locked To Camera",
//            type = MovementSettingType.BOOLEAN,
//            description = "If true, player head will follow camera orientation"
//    )
    protected boolean headLockedToCamera = true;
    public boolean isHeadLockedToCamera() {
        return headLockedToCamera;
    }
    protected CameraTarget getEndTarget(PlayerEntity player, double targetDistance) {
        switch (endTarget){
            default:
            case BACK: return CameraTarget.fromDistanceBack(player, targetDistance);
            case FRONT: return CameraTarget.fromDistanceFront(player, targetDistance);
        }
    }
    public RaycastType getRaycastType() {
        return raycastType != null ? raycastType : RaycastType.NONE;
    }
    public void setRaycastType(RaycastType type) {
        this.raycastType = type;
    }
    public String getDisplayName() {
        return customName != null ? customName : getClass().getSimpleName();
    }
    public void setCustomName(String name) {
        this.customName = name;
    }
    public Map<String, Object> getSettings() {
        Map<String, Object> settings = new HashMap<>();
        Stream.concat(
                        Arrays.stream(this.getClass().getDeclaredFields()),
                        Arrays.stream(AbstractMovementSettings.class.getDeclaredFields())
                )
                .filter(field -> field.isAnnotationPresent(MovementSetting.class) || field.getName().equals("customName"))
                .forEach(field -> {
                    field.setAccessible(true);
                    try {
                        Object value = field.get(this);
                        if (value instanceof Enum<?>) {
                            settings.put(field.getName(), ((Enum<?>) value).name());
                        } else {
                            settings.put(field.getName(), value);
                        }
                    } catch (IllegalAccessException e) {
                        Craneshot.LOGGER.error("Error accessing field: " + field.getName(), e);
                    }
                });
        return settings;
    }
    public void updateSetting(String key, Object value) {
        try {
            if (key.equals("customName")) {
                setCustomName((String)value);
                return;
            }
            Field field = findField(key);
            if (field != null && field.isAnnotationPresent(MovementSetting.class)) {
                field.setAccessible(true);
                // Handle different field types
                if (field.getType().isEnum()) {
                    if (value instanceof String) {
                        @SuppressWarnings("unchecked")
                        Enum<?> enumValue = Enum.valueOf(field.getType().asSubclass(Enum.class), (String) value);
                        field.set(this, enumValue);
                        if (key.equals("raycastType")) {
                            setRaycastType((RaycastType)enumValue);
                        }
                    }
                } else if (field.getType() == double.class || field.getType() == Double.class) {
                    double doubleValue;
                    if (value instanceof Number) {
                        doubleValue = ((Number)value).doubleValue();
                    } else if (value instanceof String) {
                        doubleValue = Double.parseDouble((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to double");
                    }
                    field.setDouble(this, doubleValue);
                } else if (field.getType() == float.class || field.getType() == Float.class) {
                    float floatValue;
                    if (value instanceof Number) {
                        floatValue = ((Number)value).floatValue();
                    } else if (value instanceof String) {
                        floatValue = Float.parseFloat((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to float");
                    }
                    field.setFloat(this, floatValue);
                } else if (field.getType() == int.class || field.getType() == Integer.class) {
                    int intValue;
                    if (value instanceof Number) {
                        intValue = ((Number)value).intValue();
                    } else if (value instanceof String) {
                        intValue = Integer.parseInt((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to integer");
                    }
                    field.setInt(this, intValue);
                } else {
                    // Default fallback for other types
                    field.set(this, value);
                }
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Error updating setting {} with value {}: {}", key, value, e.getMessage());
        }
    }
    private Field findField(String key) {
        try {
            return this.getClass().getDeclaredField(key);
        } catch (NoSuchFieldException e) {
            try {
                return AbstractMovementSettings.class.getDeclaredField(key);
            } catch (NoSuchFieldException ex) {
                Craneshot.LOGGER.error("Field not found: {}", key);
                return null;
            }
        }
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraMovementType.java">
package ninja.trek.cameramovements;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CameraMovementType {
    String name() default "";
    String description() default "";
    boolean enabled() default true;
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraState.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.input.Input;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
public class CameraState {
    private Vec3d position;
    private float yaw;
    private float pitch;
    public CameraState(Vec3d position, float yaw, float pitch) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public static CameraState fromCamera(Camera camera) {
        return new CameraState(camera.getPos(), camera.getYaw(), camera.getPitch());
    }
    public Vec3d getPosition() { return position; }
    public float getYaw() { return yaw; }
    public float getPitch() { return pitch; }
    public CameraState lerp(CameraState other, double t) {
        Vec3d lerpedPos = this.position.lerp(other.position, t);
        float lerpedYaw = lerpAngle(this.yaw, other.yaw, (float)t);
        float lerpedPitch = lerpAngle(this.pitch, other.pitch, (float)t);
        return new CameraState(lerpedPos, lerpedYaw, lerpedPitch);
    }
    private float lerpAngle(float start, float end, float t) {
        float diff = end - start;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return start + diff * t;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraTarget.java">
package ninja.trek.cameramovements;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.Craneshot;
public class CameraTarget {
    private Vec3d position;
    private float yaw;
    private float pitch;
    public CameraTarget(Vec3d position, float yaw, float pitch) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public CameraTarget() {
        position = new Vec3d(0,0,0);
    }
    public static CameraTarget fromCamera(Camera camera) {
        return new CameraTarget(camera.getPos(), camera.getYaw(), camera.getPitch());
    }
    public static CameraTarget fromDistanceBack(PlayerEntity player, double distance) {
        double yaw = Math.toRadians(player.getYaw());// + Math.toRadians((180));
        double pitch = Math.toRadians(player.getPitch());
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * distance;
        double yOffset = Math.sin(pitch) * distance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * distance;
        Vec3d targetPos = player.getEyePos().add(xOffset, yOffset, zOffset);
        return new CameraTarget(targetPos, player.getYaw(), player.getPitch());
    }
    public static CameraTarget fromDistanceFront(PlayerEntity player, double distance) {
        double yaw = Math.toRadians(player.getYaw() + 180); // Add 180 degrees to face front
        double pitch = Math.toRadians(-player.getPitch()); // Invert the pitch angle
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * distance;
        double yOffset = Math.sin(pitch) * distance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * distance;
        Vec3d targetPos = player.getEyePos().add(xOffset, yOffset, zOffset);
        return new CameraTarget(targetPos, player.getYaw() + 180, -player.getPitch());
    }
    public Vec3d getPosition() {
        return position;
    }
    public float getYaw() {
        return yaw;
    }
    public float getPitch() {
        return pitch;
    }
    public CameraTarget withAdjustedPosition(PlayerEntity player, RaycastType raycastType) {
//        Craneshot.LOGGER.info("withAdjustedPosition called with raycastType: {}", this.raycastType);
        Vec3d adjustedPos = RaycastUtil.adjustForCollision(player.getEyePos(), this.position, raycastType);
        return new CameraTarget(adjustedPos, this.yaw, this.pitch);
    }
    public void set(Vec3d v, float yaw, float pitch) {
        position = v;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public void set(CameraTarget t) {
        position = t.position;
        this.pitch = t.pitch;
        this.yaw = t.yaw;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/ICameraMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
public interface ICameraMovement {
    void start(MinecraftClient client, Camera camera);
    MovementState calculateState(MinecraftClient client, Camera camera);
    void queueReset(MinecraftClient client, Camera camera);
    void adjustDistance(boolean increase);
    String getName();
    float getWeight(); // For blending calculations
    boolean isComplete(); // To determine if movement should be removed
    RaycastType getRaycastType();
    default boolean hasCompletedOutPhase() { return false; }
}
</file>

<file path="client/java/ninja/trek/cameramovements/move8.txt">
Overview: Two Post‑Move Mouse Options with MOVE8
When a movement transition (using either Bézier or linear easing) finishes, the system enters a “post‑move” phase. In this phase you have two distinct modes for handling mouse input:

FREE_MOUSE:
– The mouse controls the camera’s rotation (freeCamYaw/freeCamPitch) independently.
– The “stick” (the camera’s positional anchor, freeCamPosition) stays fixed (or is only updated by the easing logic, not directly by mouse motion).
– The player’s head (or model) is snapped to one of eight directions (MOVE8) based on keyboard input relative to the current freeCamYaw. This lets the player choose one of eight discrete orientations for movement, while the camera can look around freely.

NONE:
– The mouse does not directly update the camera’s rotation. Instead, the system uses keyboard input to “nudge” the camera stick itself.
– In this case, the entire stick (its position and rotation) is moved via the easing logic (using the same positionEasing/rotationEasing and speed limits that govern Bézier/linear movement).
– With MOVE8 enabled, the player’s head still snaps to one of eight directions based on key combinations, but now the overall camera “stick” (freeCamPosition and freeCamYaw/freeCamPitch) is driven by that movement input rather than independent mouse adjustments.

How They Work with MOVE8 Movement
A. MOVE8 with FREE_MOUSE
Independent Camera Rotation:
When post‑move mouse mode is set to FREE_MOUSE, the mouse “nudges” only the freeCamYaw and freeCamPitch values. That is, the camera’s orientation is updated immediately by the mouse (subject to the easing limits already in place) while the camera’s position (the stick) remains unchanged by the mouse.

Discrete Player Orientation:
In MOVE8 mode, the keyboard input calculates a target yaw (by adding a fixed offset to freeCamYaw based on which keys are pressed) and immediately sets the player’s yaw to that target value. The player’s head “snaps” to one of the eight directions relative to the current camera view.

Resulting Behavior:
• The player’s movement (simulated by setting forward movement) is determined by the snapped direction.
• The camera’s stick (its anchored position) stays put while the user can still look around freely with the mouse.
• The overall effect is that even though the player is moving in one of eight preset directions, the view is independently adjustable so the player can look in any direction without moving the camera stick.

B. MOVE8 with NONE
Stick Movement via Keyboard Input:
When the post‑move mouse option is set to NONE, the mouse does not adjust the camera’s rotation independently. Instead, the “stick” itself is moved by the easing logic that responds to keyboard input. In other words, the camera’s freeCamPosition and its rotation are updated by the same interpolation that moves the camera along its Bézier or linear path.

Discrete Player Orientation Remains:
As in FREE_MOUSE mode, MOVE8 logic uses the current freeCamYaw (which in this mode is driven only by keyboard/easing changes) as the basis for computing the target yaw. The player’s head is then snapped to one of eight directions relative to that yaw, and simulated forward movement is applied.

Resulting Behavior:
• The entire camera “stick” is adjusted when the movement keys are pressed.
• There is no separate free mouse–based rotation; the camera’s orientation is changed as part of the eased, stick–based movement.
• Thus, the discrete MOVE8 movement still applies: the player rotates to one of eight directions and moves forward accordingly, with the camera’s state (position/rotation) shifting gradually as determined by the easing logic.

Key Points to Ensure Both Modes Work with MOVE8
For Both Modes:
• The calculation of the target yaw for MOVE8 is always based on the current freeCamYaw.
• When a movement key combination is pressed, the system computes the appropriate offset (e.g., ±45°, ±90°, etc.) from freeCamYaw, snaps the player’s yaw to that value, and simulates forward movement.

Differences in Mouse Handling:
• FREE_MOUSE: The mouse directly modifies freeCamYaw/freeCamPitch independent of the stick’s position; the stick remains fixed while the camera rotates under the mouse’s control.
• NONE: The mouse does not inject independent rotation; instead, the keyboard input causes the stick (the camera’s entire state) to be adjusted via easing. The camera’s rotation is updated as part of that overall stick movement.

User Experience:
– In FREE_MOUSE mode, players can look around without shifting the camera’s position, while still moving discretely in one of eight directions.
– In NONE mode, any adjustment to the camera’s view happens as part of the overall movement (the “stick” moves), so the camera’s position and rotation evolve together as the player commands movement.

Conclusion
By distinguishing the two options—FREE_MOUSE for independent, mouse‑driven camera rotation (with a fixed stick) and NONE for stick movement controlled by keyboard input—you can ensure that MOVE8 movement works seamlessly in both cases. In either mode, the player's eight‑direction snapping is calculated relative to the current freeCamYaw, and simulated forward movement is applied, while the camera’s behavior (whether rotating independently or moving as a unit) follows the respective mouse option’s design.
</file>

<file path="client/java/ninja/trek/cameramovements/movements/BezierMovement.java">
package ninja.trek.cameramovements.movements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import ninja.trek.Craneshot;
import ninja.trek.CraneshotClient;
import ninja.trek.CameraController;
import ninja.trek.cameramovements.*;
import ninja.trek.config.MovementSetting;
@CameraMovementType(
        name = "Bezier Movement (Canonical Relative)",
        description = "Moves the camera along a quadratic Bézier curve in canonical space then converts to world space using the control stick's rotation."
)
public class BezierMovement extends AbstractMovementSettings implements ICameraMovement {
    // --- Settings ---
    @MovementSetting(label = "Position Easing", min = 0.01, max = 1.0)
    private double positionEasing = 0.1;
    @MovementSetting(label = "Position Speed Limit", min = 0.1, max = 100.0)
    private double positionSpeedLimit = 10;
    @MovementSetting(label = "Rotation Easing", min = 0.01, max = 1.0)
    private double rotationEasing = 0.1;
    @MovementSetting(label = "Rotation Speed Limit", min = 0.1, max = 1000)
    private double rotationSpeedLimit = 500;
    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10.0;
    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0;
    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0;
    @MovementSetting(label = "Control Point Displacement", min = 0.0, max = 30)
    private double controlPointDisplacement = 5;
    @MovementSetting(label = "Displacement Angle", min = -180.0, max = 180.0)
    private double displacementAngle = 0.0;
    @MovementSetting(label = "Displacement Angle Variance", min = 0.0, max = 180.0)
    private double displacementAngleVariance = 0.0;
    // --- Internal fields for the canonical Bézier path ---
    private Vec3d canonicalStart;
    private Vec3d canonicalEnd;
    private Vec3d canonicalControl;
    private Vec3d originalCanonicalStart;
    // Store the control stick's original position and orientation
    private Vec3d originalStickPosition;
    private float originalStickYaw;
    private float originalStickPitch;
    private double progress;
    private boolean resetting = false;
    private boolean linearMode = false;
    private boolean distanceChanged = false;
    private float weight = 1.0f;
    private CameraTarget current;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        // Capture the control stick's position and rotation at the start
        Vec3d stickPosition = CameraController.controlStick.getPosition();
        float stickYaw = CameraController.controlStick.getYaw();
        float stickPitch = CameraController.controlStick.getPitch();
        // Save these original parameters
        originalStickPosition = stickPosition;
        originalStickYaw = stickYaw;
        originalStickPitch = stickPitch;
        // Get the camera's current (absolute) position
        Vec3d absStart = CameraTarget.fromCamera(camera).getPosition();
        // Determine the desired end target
        CameraTarget camEndTarget = getEndTarget(client.player, targetDistance);
        Vec3d absEnd = camEndTarget.getPosition();
        // Convert the offsets (relative to the stick) into canonical space
        canonicalStart = unrotateVectorByYawPitch(absStart.subtract(stickPosition), stickYaw, stickPitch);
        canonicalEnd = unrotateVectorByYawPitch(absEnd.subtract(stickPosition), stickYaw, stickPitch);
        // Save the original canonical start for use in the reset
        originalCanonicalStart = canonicalStart;
        // Compute the control point for the Bézier curve
        canonicalControl = generateControlPoint(canonicalStart, canonicalEnd);
        progress = 0.0;
        resetting = false;
        linearMode = false;
        distanceChanged = false;
        // Set the initial camera target
        Vec3d desiredPos = stickPosition.add(rotateVectorByYawPitch(canonicalStart, stickYaw, stickPitch));
        current = new CameraTarget(desiredPos, stickYaw, stickPitch);
        weight = 1.0f;
    }
    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        if (linearMode) Craneshot.LOGGER.info("linear");
        // Get current control stick state
        Vec3d stickPosition = CameraController.controlStick.getPosition();
        float stickYaw = CameraController.controlStick.getYaw();
        float stickPitch = CameraController.controlStick.getPitch();
        // Determine canonical endpoints
        Vec3d startCanon, endCanon;
        if (!resetting) {
            startCanon = canonicalStart;
            endCanon = canonicalEnd;
        } else {
            startCanon = canonicalEnd;
            endCanon = originalCanonicalStart;
        }
        double totalDistance = startCanon.distanceTo(endCanon);
        Vec3d desiredCanonical;
        if (!linearMode) {
            // --- Bezier movement mode ---
            double potentialDelta = (1.0 - progress) * positionEasing;
            double maxMove = positionSpeedLimit * (1.0 / 20.0);
            double allowedDelta = totalDistance > 0 ? maxMove / totalDistance : potentialDelta;
            double progressDelta = Math.min(potentialDelta, allowedDelta);
            progress = Math.min(1.0, progress + progressDelta);
            desiredCanonical = quadraticBezier(startCanon, canonicalControl, endCanon, progress);
        } else {
            // --- Linear movement mode ---
            Vec3d currentCanon = unrotateVectorByYawPitch(
                    current.getPosition().subtract(stickPosition),
                    stickYaw,
                    stickPitch
            );
            Vec3d delta = endCanon.subtract(currentCanon);
            double deltaLength = delta.length();
            double maxMove = positionSpeedLimit * (1.0 / 20.0);
            Vec3d move;
            if (deltaLength > 0) {
                move = delta.multiply(positionEasing);
                if (move.length() > maxMove) {
                    move = move.normalize().multiply(maxMove);
                }
            } else {
                move = Vec3d.ZERO;
            }
            desiredCanonical = currentCanon.add(move);
        }
        // Convert back to world space using control stick position and rotation
        Vec3d desiredAbs = stickPosition.add(
                rotateVectorByYawPitch(desiredCanonical, stickYaw, stickPitch)
        );
        // Rotation easing
        float targetYaw, targetPitch;
        if (!resetting && this.endTarget == END_TARGET.FRONT) {
            targetYaw = stickYaw + 180f;
            targetPitch = -stickPitch;
        } else {
            targetYaw = stickYaw;
            targetPitch = stickPitch;
        }
        float yawError = targetYaw - current.getYaw();
        float pitchError = targetPitch - current.getPitch();
        while (yawError > 180) yawError -= 360;
        while (yawError < -180) yawError += 360;
        float desiredYawSpeed = (float)(yawError * rotationEasing);
        float desiredPitchSpeed = (float)(pitchError * rotationEasing);
        float maxRotation = (float)(rotationSpeedLimit * (1.0 / 20.0));
        if (Math.abs(desiredYawSpeed) > maxRotation) {
            desiredYawSpeed = Math.signum(desiredYawSpeed) * maxRotation;
        }
        if (Math.abs(desiredPitchSpeed) > maxRotation) {
            desiredPitchSpeed = Math.signum(desiredPitchSpeed) * maxRotation;
        }
        float newYaw = current.getYaw() + desiredYawSpeed;
        float newPitch = current.getPitch() + desiredPitchSpeed;
        current = new CameraTarget(desiredAbs, newYaw, newPitch);
        // Update alpha for external systems
        double remaining = desiredCanonical.distanceTo(endCanon);
        alpha = totalDistance != 0 ? remaining / totalDistance : 0.0;
        // Switch to linear mode when out phase completes
        if (!resetting && progress >= 0.999) {
            linearMode = true;
            canonicalStart = unrotateVectorByYawPitch(
                    current.getPosition().subtract(stickPosition),
                    stickYaw,
                    stickPitch
            );
            Vec3d endPos = getEndTarget(client.player, targetDistance).getPosition();
            canonicalEnd = unrotateVectorByYawPitch(
                    endPos.subtract(stickPosition),
                    stickYaw,
                    stickPitch
            );
        }
        boolean complete = resetting && progress >= 0.999;
        return new MovementState(current, complete);
    }
    // Rest of the helper methods remain largely unchanged, just updating documentation
    // to reflect that we're using control stick instead of player position
    private Vec3d quadraticBezier(Vec3d p0, Vec3d p1, Vec3d p2, double t) {
        double oneMinusT = 1.0 - t;
        return p0.multiply(oneMinusT * oneMinusT)
                .add(p1.multiply(2 * oneMinusT * t))
                .add(p2.multiply(t * t));
    }
    private Vec3d generateControlPoint(Vec3d start, Vec3d end) {
        Vec3d mid = start.add(end).multiply(0.5);
        Vec3d diff = end.subtract(start);
        if (diff.lengthSquared() < 1e-6) {
            return mid.add(new Vec3d(0, controlPointDisplacement, 0));
        }
        Vec3d tangent = diff.normalize();
        Vec3d worldUp = new Vec3d(0, 1, 0);
        Vec3d projectedUp = worldUp.subtract(tangent.multiply(worldUp.dotProduct(tangent)));
        if (projectedUp.lengthSquared() < 1e-6) {
            Vec3d arbitrary = new Vec3d(1, 0, 0);
            projectedUp = arbitrary.subtract(tangent.multiply(arbitrary.dotProduct(tangent)));
        }
        projectedUp = projectedUp.normalize();
        if (projectedUp.y > 0) {
            projectedUp = projectedUp.multiply(-1);
        }
        double randomOffset = (Math.random() * 2 - 1) * displacementAngleVariance;
        double angleDegrees = displacementAngle + randomOffset;
        double angleRadians = Math.toRadians(angleDegrees);
        Vec3d rotatedUp = projectedUp.multiply(Math.cos(angleRadians))
                .add(tangent.crossProduct(projectedUp).multiply(Math.sin(angleRadians)));
        Vec3d offset = rotatedUp.multiply(controlPointDisplacement);
        return mid.add(offset);
    }
    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        if (!resetting) {
            resetting = true;
            linearMode = false;
            progress = 1.0 - progress;
            canonicalControl = generateControlPoint(canonicalEnd, originalCanonicalStart);
            if (CraneshotClient.CAMERA_CONTROLLER.getMovementManager() != null) {
                CraneshotClient.CAMERA_CONTROLLER.getMovementManager().resetMovement(this);
            }
        }
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? 1.1 : 0.9;
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
        if (linearMode) {
            distanceChanged = true;
        }
    }
    private Vec3d rotateVectorByYawPitch(Vec3d canonical, float yaw, float pitch) {
        double yawRad = Math.toRadians(yaw);
        double pitchRad = Math.toRadians(pitch);
        Vec3d forward = new Vec3d(
                -Math.sin(yawRad) * Math.cos(pitchRad),
                -Math.sin(pitchRad),
                Math.cos(yawRad) * Math.cos(pitchRad)
        );
        Vec3d right = new Vec3d(
                Math.cos(yawRad),
                0,
                Math.sin(yawRad)
        );
        Vec3d up = right.crossProduct(forward);
        return right.multiply(canonical.x)
                .add(up.multiply(canonical.y))
                .add(forward.multiply(canonical.z));
    }
    private Vec3d unrotateVectorByYawPitch(Vec3d worldVec, float yaw, float pitch) {
        double yawRad = Math.toRadians(yaw);
        double pitchRad = Math.toRadians(pitch);
        Vec3d forward = new Vec3d(
                -Math.sin(yawRad) * Math.cos(pitchRad),
                -Math.sin(pitchRad),
                Math.cos(yawRad) * Math.cos(pitchRad)
        );
        Vec3d right = new Vec3d(
                Math.cos(yawRad),
                0,
                Math.sin(yawRad)
        );
        Vec3d up = right.crossProduct(forward);
        double xCanonical = worldVec.dotProduct(right);
        double yCanonical = worldVec.dotProduct(up);
        double zCanonical = worldVec.dotProduct(forward);
        return new Vec3d(xCanonical, yCanonical, zCanonical);
    }
    @Override
    public String getName() {
        return "Bezier";
    }
    @Override
    public float getWeight() {
        return weight;
    }
    @Override
    public boolean isComplete() {
        return resetting && progress >= 0.999;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/movements/LinearMovement.java">
package ninja.trek.cameramovements.movements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import ninja.trek.CameraController;
import ninja.trek.CraneshotClient;
import ninja.trek.cameramovements.*;
import ninja.trek.config.MovementSetting;
public class LinearMovement extends AbstractMovementSettings implements ICameraMovement {
    @MovementSetting(label = "Position Easing", min = 0.01, max = 1.0)
    private double positionEasing = 0.1;
    @MovementSetting(label = "Position Speed Limit", min = 0.1, max = 100.0)
    private double positionSpeedLimit = 2.0;
    @MovementSetting(label = "Rotation Easing", min = 0.01, max = 1.0)
    private double rotationEasing = 0.1;
    @MovementSetting(label = "Rotation Speed Limit", min = 0.1, max = 3600.0)
    private double rotationSpeedLimit = 45.0;
    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10.0;
    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0;
    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0;
    public CameraTarget start = new CameraTarget();
    public CameraTarget end = new CameraTarget();
    public CameraTarget current = new CameraTarget();
    private boolean resetting = false;
    private float weight = 1.0f;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        // Initialize with camera's current state
        start = CameraTarget.fromCamera(camera);
        current = CameraTarget.fromCamera(camera);
        // Calculate end target based on controlStick
        Vec3d targetPos = calculateTargetPosition(CameraController.controlStick);
        end = new CameraTarget(targetPos, CameraController.controlStick.getYaw(), CameraController.controlStick.getPitch());
        resetting = false;
        weight = 1.0f;
    }
    private Vec3d calculateTargetPosition(CameraTarget stick) {
        double yaw = Math.toRadians(stick.getYaw());
        double pitch = Math.toRadians(stick.getPitch());
        // Calculate offset based on target distance
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * targetDistance;
        double yOffset = Math.sin(pitch) * targetDistance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * targetDistance;
        return stick.getPosition().add(xOffset, yOffset, zOffset);
    }
    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        if (client.player == null) return new MovementState(current, true);
        // Update start target with controlStick's current state
        start = new CameraTarget(
                CameraController.controlStick.getPosition(),
                CameraController.controlStick.getYaw(),
                CameraController.controlStick.getPitch()
        );
        // Update end target based on controlStick and target distance
        Vec3d targetPos = calculateTargetPosition(CameraController.controlStick);
        end = new CameraTarget(targetPos, CameraController.controlStick.getYaw(), CameraController.controlStick.getPitch());
        CameraTarget a = resetting ? end : start;
        CameraTarget b = resetting ? start : end;
        // Position interpolation with speed limit
        Vec3d desired = current.getPosition().lerp(b.getPosition(), positionEasing);
        Vec3d moveVector = desired.subtract(current.getPosition());
        double moveDistance = moveVector.length();
        if (moveDistance > 0.01) {
            double maxMove = positionSpeedLimit * (1.0/20.0); // Convert blocks/second to blocks/tick
            if (moveDistance > maxMove) {
                Vec3d limitedMove = moveVector.normalize().multiply(maxMove);
                desired = current.getPosition().add(limitedMove);
            }
        }
        // Rotation interpolation with speed limit
        float targetYaw = b.getYaw();
        float targetPitch = b.getPitch();
        float yawDiff = targetYaw - current.getYaw();
        float pitchDiff = targetPitch - current.getPitch();
        // Normalize angles to [-180, 180]
        while (yawDiff > 180) yawDiff -= 360;
        while (yawDiff < -180) yawDiff += 360;
        // Apply easing to get desired rotation speed
        float desiredYawSpeed = (float)(yawDiff * rotationEasing);
        float desiredPitchSpeed = (float)(pitchDiff * rotationEasing);
        // Apply rotation speed limit
        float maxRotation = (float)(rotationSpeedLimit * (1.0/20.0));
        if (Math.abs(desiredYawSpeed) > maxRotation) {
            desiredYawSpeed = Math.signum(desiredYawSpeed) * maxRotation;
        }
        if (Math.abs(desiredPitchSpeed) > maxRotation) {
            desiredPitchSpeed = Math.signum(desiredPitchSpeed) * maxRotation;
        }
        // Apply the final rotation
        float newYaw = current.getYaw() + desiredYawSpeed;
        float newPitch = current.getPitch() + desiredPitchSpeed;
        current = new CameraTarget(desired, newYaw, newPitch);
        // Calculate progress for blending
        alpha = current.getPosition().distanceTo(b.getPosition()) /
                a.getPosition().distanceTo(b.getPosition());
        boolean complete = resetting && moveDistance < 0.01;
        return new MovementState(current, complete);
    }
    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        if (client.player == null) return;
        resetting = true;
        if (CraneshotClient.CAMERA_CONTROLLER.getMovementManager() != null) {
            CraneshotClient.CAMERA_CONTROLLER.getMovementManager().resetMovement(this);
        }
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? 1.1 : 0.9;
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
    }
    @Override
    public String getName() {
        return "Linear";
    }
    @Override
    public float getWeight() {
        return weight;
    }
    @Override
    public boolean isComplete() {
        return resetting && current.getPosition().distanceTo(start.getPosition()) < 0.01;
    }
    @Override
    public boolean hasCompletedOutPhase() {
        return !resetting && current.getPosition().distanceTo(end.getPosition()) < 0.01;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/MovementState.java">
package ninja.trek.cameramovements;
public class MovementState {
    private final CameraTarget target;
    private final boolean isComplete;
    public MovementState(CameraTarget target, boolean isComplete) {
        this.target = target;
        this.isComplete = isComplete;
    }
    public CameraTarget getCameraTarget() {
        return target;
    }
    public boolean isComplete() {
        return isComplete;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/RaycastType.java">
package ninja.trek.cameramovements;
/**
 * Enum defining different raycast behaviors for camera collision handling
 */
public enum RaycastType {
    /**
     * No raycast collision checking - camera can clip through blocks
     */
    NONE,
    /**
     * Raycasts from player to desired camera position.
     * If collision detected, moves camera closer to player.
     * Behaves like default Minecraft third person camera.
     */
    NEAR,
    /**
     * Raycasts from desired camera position towards player.
     * If camera would be inside block, moves it to first non-solid position.
     * Provides more stable distant shots by preferring to keep camera far out.
     */
    FAR
}
</file>

<file path="client/java/ninja/trek/cameramovements/RaycastUtil.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.RaycastContext;
public class RaycastUtil {
    private static final double CAMERA_OFFSET = 0.5;
    private static final double STEP_SIZE = 0.5;
    private static final double FINE_STEP_SIZE = 0.1;
    public static Vec3d adjustForCollision(Vec3d playerPos, Vec3d targetPos, RaycastType raycastType) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.world == null || raycastType == RaycastType.NONE) {
            return targetPos;
        }
        switch (raycastType) {
            case NEAR:
                return handleNearRaycast(client, playerPos, targetPos);
            case FAR:
                return handleFarRaycast(client, playerPos, targetPos);
            default:
                return targetPos;
        }
    }
    private static Vec3d handleNearRaycast(MinecraftClient client, Vec3d playerPos, Vec3d targetPos) {
        BlockHitResult hit = client.world.raycast(new RaycastContext(
                playerPos,
                targetPos,
                RaycastContext.ShapeType.VISUAL,
                RaycastContext.FluidHandling.NONE,
                client.player
        ));
        if (hit.getType() == HitResult.Type.BLOCK) {
            Vec3d hitPos = hit.getPos();
            Vec3d directionVector = hitPos.subtract(playerPos).normalize();
            return hitPos.subtract(directionVector.multiply(CAMERA_OFFSET));
        }
        return targetPos;
    }
    private static Vec3d handleFarRaycast(MinecraftClient client, Vec3d playerPos, Vec3d targetPos) {
        Vec3d direction = targetPos.subtract(playerPos).normalize();
        double totalDistance = targetPos.distanceTo(playerPos);
        // Start from target position
        Vec3d currentPos = targetPos;
        if (isPositionInAir(client, currentPos)) {
            return refinePosition(client, currentPos, direction);
        }
        // Coarse search
        for (double distance = STEP_SIZE; distance < totalDistance; distance += STEP_SIZE) {
            Vec3d checkPos = targetPos.subtract(direction.multiply(distance));
            if (isPositionInAir(client, checkPos)) {
                return refinePosition(client, checkPos, direction.multiply(-1));
            }
        }
        return playerPos;
    }
    private static Vec3d refinePosition(MinecraftClient client, Vec3d startPos, Vec3d direction) {
        // Raycast forward until we hit something
        BlockHitResult hit = client.world.raycast(new RaycastContext(
                startPos,
                startPos.add(direction.multiply(2.0)), // Look 2 blocks ahead
                RaycastContext.ShapeType.VISUAL,
                RaycastContext.FluidHandling.NONE,
                client.player
        ));
        if (hit.getType() == HitResult.Type.BLOCK) {
            Vec3d hitPos = hit.getPos();
            return hitPos.subtract(direction.multiply(CAMERA_OFFSET));
        }
        return startPos;
    }
    private static boolean isPositionInAir(MinecraftClient client, Vec3d pos) {
        BlockPos blockPos = BlockPos.ofFloored(pos);
        return client.world.getBlockState(blockPos).isAir();
    }
}
</file>

<file path="client/java/ninja/trek/config/FreeCamSettings.java">
package ninja.trek.config;
public class FreeCamSettings {
    public enum MovementMode {
        CAMERA,    // Movement relative to camera direction
        AXIS_ALIGNED  // Movement along world axes
    }
    private static float moveSpeed = 0.2f;
    private static MovementMode movementMode = MovementMode.CAMERA;
    // Getters and setters
    public static float getMoveSpeed() {
        return moveSpeed;
    }
    public static void setMoveSpeed(float speed) {
        moveSpeed = speed;
    }
    public static MovementMode getMovementMode() {
        return movementMode;
    }
    public static void setMovementMode(MovementMode mode) {
        movementMode = mode;
    }
}
</file>

<file path="client/java/ninja/trek/config/GeneralMenuSettings.java">
package ninja.trek.config;
public class GeneralMenuSettings {
}
</file>

<file path="client/java/ninja/trek/config/GeneralSettingsIO.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import net.minecraft.client.MinecraftClient;
import ninja.trek.Craneshot;
import ninja.trek.config.FreeCamSettings;
import ninja.trek.config.SlotMenuSettings;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
// Update GeneralSettingsIO.java
public class GeneralSettingsIO {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_general.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    public static void saveSettings() {
        try {
            if (!CONFIG_FILE.getParentFile().exists()) {
                CONFIG_FILE.getParentFile().mkdirs();
            }
            try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
                JsonObject settingsObj = new JsonObject();
                // Save wrap states and toggle states
                JsonObject wrapStatesObj = new JsonObject();
                JsonObject toggleStatesObj = new JsonObject();
                for (int i = 0; i < 3; i++) {
                    wrapStatesObj.addProperty("slot" + i, SlotMenuSettings.getWrapState(i));
                    toggleStatesObj.addProperty("slot" + i, SlotMenuSettings.getToggleState(i));
                }
                settingsObj.add("wrapStates", wrapStatesObj);
                settingsObj.add("toggleStates", toggleStatesObj);
                // Save FreeCamSettings
                JsonObject freeCamObj = new JsonObject();
                freeCamObj.addProperty("moveSpeed", FreeCamSettings.getMoveSpeed());
                freeCamObj.addProperty("movementMode", FreeCamSettings.getMovementMode().name());
                settingsObj.add("freeCam", freeCamObj);
                GSON.toJson(settingsObj, writer);
                Craneshot.LOGGER.info("Saved general settings configuration");
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Failed to save general settings", e);
        }
    }
    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) {
            Craneshot.LOGGER.info("No general settings file found, using defaults");
            return;
        }
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            JsonObject settingsObj = GSON.fromJson(reader, JsonObject.class);
            // Load wrap states and toggle states
            if (settingsObj.has("wrapStates")) {
                JsonObject wrapStatesObj = settingsObj.getAsJsonObject("wrapStates");
                for (int i = 0; i < 3; i++) {
                    String key = "slot" + i;
                    if (wrapStatesObj.has(key)) {
                        boolean wrapState = wrapStatesObj.get(key).getAsBoolean();
                        SlotMenuSettings.setWrapState(i, wrapState);
                    }
                }
            }
            if (settingsObj.has("toggleStates")) {
                JsonObject toggleStatesObj = settingsObj.getAsJsonObject("toggleStates");
                for (int i = 0; i < 3; i++) {
                    String key = "slot" + i;
                    if (toggleStatesObj.has(key)) {
                        boolean toggleState = toggleStatesObj.get(key).getAsBoolean();
                        SlotMenuSettings.setToggleState(i, toggleState);
                    }
                }
            }
            // Load FreeCamSettings
            if (settingsObj.has("freeCam")) {
                JsonObject freeCamObj = settingsObj.getAsJsonObject("freeCam");
                if (freeCamObj.has("moveSpeed")) {
                    FreeCamSettings.setMoveSpeed(freeCamObj.get("moveSpeed").getAsFloat());
                }
                if (freeCamObj.has("movementMode")) {
                    FreeCamSettings.setMovementMode(
                            FreeCamSettings.MovementMode.valueOf(freeCamObj.get("movementMode").getAsString())
                    );
                }
            }
            Craneshot.LOGGER.info("Loaded general settings configuration");
        } catch (IOException e) {
            Craneshot.LOGGER.error("Failed to load general settings", e);
        }
    }
}
</file>

<file path="client/java/ninja/trek/config/MenuOverlayScreen.java">
package ninja.trek.config;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.tooltip.Tooltip;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.CheckboxWidget;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;
import ninja.trek.CameraMovementRegistry;
import ninja.trek.Craneshot;
import ninja.trek.CraneshotClient;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.cameramovements.ICameraMovement;
import java.lang.reflect.Field;
import java.util.*;
public class MenuOverlayScreen extends Screen {
    private static final Map<Integer, Set<Integer>> expandedMovements = new HashMap<>();
    private static final int MARGIN = 20;
    private static final int TAB_HEIGHT = 30;
    private static final int CONTENT_START_Y = TAB_HEIGHT - 10;
    private static final double SCROLL_SPEED = 10;
    private static boolean isMenuOpen = false;
    private int selectedTab = 0;
    private final List<SettingSlider> settingSliders = new ArrayList<>();
    private int scrollOffset = 0;
    private int maxScroll = 0;
    private int guiWidth;
    private int guiHeight;
    private int centerX;
    private int centerY;
    private int selectedMovementTypeIndex = 0;
    public MenuOverlayScreen() {
        super(Text.literal("CraneShot Settings"));
        isMenuOpen = false;
    }
    @Override
    protected void init() {
        this.guiWidth = this.width - (MARGIN * 2);
        this.guiHeight = this.height - (MARGIN * 2);
        this.centerX = MARGIN;
        this.centerY = MARGIN;
        int visibleStartY = centerY + CONTENT_START_Y;
        int visibleEndY = centerY + guiHeight;
        createTabButtons();
        int BUTTON_HEIGHT = 20;
        int MOVEMENT_SPACING = BUTTON_HEIGHT - 5;
        int MOVEMENT_ROW_HEIGHT = BUTTON_HEIGHT + 5;
        int SETTING_HEIGHT = BUTTON_HEIGHT + 5;
        if (selectedTab > 0) {
            int slotIndex = selectedTab - 1;
            createControlsBar(slotIndex, visibleStartY, BUTTON_HEIGHT);
            createMovementList(slotIndex, visibleStartY, visibleEndY, BUTTON_HEIGHT,
                    MOVEMENT_ROW_HEIGHT, MOVEMENT_SPACING, SETTING_HEIGHT);
        } else if (selectedTab == 0) {
            addGeneralSettings();
        }
    }
    private void createTabButtons() {
        int tabCount = CraneshotClient.CAMERA_CONTROLLER.getMovementCount() + 1;
        int tabWidth = Math.min(100, (guiWidth - 20) / tabCount);
        for (int i = 0; i <= CraneshotClient.CAMERA_CONTROLLER.getMovementCount(); i++) {
            int tabIndex = i;
            String tabName = (i == 0) ? "General" : "Slot " + i;
            Text buttonText = Text.literal(tabName);
            if (i != selectedTab) {
                buttonText = buttonText.copy().formatted(Formatting.GRAY);
            }
            ButtonWidget slotBtn = ButtonWidget.builder(buttonText, button -> switchTab(tabIndex))
                    .dimensions(centerX + (i * (tabWidth + 5)), centerY, tabWidth, 20)
                    .build();
            this.addDrawableChild(slotBtn);
        }
    }
    private void createControlsBar(int slotIndex, int visibleStartY, int BUTTON_HEIGHT) {
        if (visibleStartY <= centerY + CONTENT_START_Y + BUTTON_HEIGHT) {
            int addButtonWidth = 60;
            int typeButtonWidth = 120;
            int clipboardButtonWidth = 40;
            int spacing = 10;
            // Add movement button
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Add"), button -> addMovement(slotIndex))
                    .dimensions(centerX + 10, centerY + CONTENT_START_Y, addButtonWidth, BUTTON_HEIGHT)
                    .build());
            // Paste button
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Paste"), button -> pasteMovement(slotIndex))
                    .dimensions(centerX + addButtonWidth + spacing, centerY + CONTENT_START_Y, clipboardButtonWidth, BUTTON_HEIGHT)
                    .build());
            // Movement type selector
            List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
            String currentTypeName = movements.isEmpty() ? "None" : movements.get(selectedMovementTypeIndex).getName();
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Type: " + currentTypeName),
                            button -> cycleMovementType())
                    .dimensions(centerX + addButtonWidth + clipboardButtonWidth + spacing * 2, centerY + CONTENT_START_Y,
                            typeButtonWidth, BUTTON_HEIGHT)
                    .build());
            // Wrap checkbox
            this.addDrawableChild(CheckboxWidget.builder(Text.literal("Wrap"), this.textRenderer)
                    .pos(centerX + addButtonWidth + clipboardButtonWidth + typeButtonWidth + spacing * 3, centerY + CONTENT_START_Y)
                    .checked(SlotMenuSettings.getWrapState(slotIndex))
                    .callback((checkbox, checked) -> SlotMenuSettings.setWrapState(slotIndex, checked))
                    .build());
            // Toggle checkbox - add right after Wrap checkbox
            this.addDrawableChild(CheckboxWidget.builder(Text.literal("Toggle"), this.textRenderer)
                    .pos(centerX + addButtonWidth + clipboardButtonWidth + typeButtonWidth + spacing * 3 + 100, centerY + CONTENT_START_Y)
                    .checked(SlotMenuSettings.getToggleState(slotIndex))
                    .callback((checkbox, checked) -> SlotMenuSettings.setToggleState(slotIndex, checked))
                    .build());
        }
    }
    private void createMovementControls(int slotIndex, int index, ICameraMovement movement, int rowY, int BUTTON_HEIGHT) {
        int controlX = centerX + 10;
        // Movement control buttons
        if (index > 0) {
            addDrawableChild(ButtonWidget.builder(Text.literal("↑"),
                            button -> moveMovement(slotIndex, index, index - 1))
                    .dimensions(controlX, rowY, 20, BUTTON_HEIGHT).build());
        }
        controlX += 25;
        if (index < CraneshotClient.CAMERA_CONTROLLER.getAvailableMovementsForSlot(slotIndex).size() - 1) {
            addDrawableChild(ButtonWidget.builder(Text.literal("↓"),
                            button -> moveMovement(slotIndex, index, index + 1))
                    .dimensions(controlX, rowY, 20, BUTTON_HEIGHT).build());
        }
        controlX += 25;
        if (CraneshotClient.CAMERA_CONTROLLER.getAvailableMovementsForSlot(slotIndex).size() > 1) {
            addDrawableChild(ButtonWidget.builder(Text.literal("×"),
                            button -> deleteMovement(slotIndex, index))
                    .dimensions(controlX, rowY, 20, BUTTON_HEIGHT).build());
        }
        controlX += 25;
        // Rename button
        if (movement instanceof AbstractMovementSettings settings) {
            addDrawableChild(ButtonWidget.builder(Text.literal("r"), button -> {
                        if (client != null) {
                            client.setScreen(new RenameModal(this, settings, this::reinitialize));
                        }
                    })
                    .dimensions(controlX, rowY, 20, BUTTON_HEIGHT)
                    .build());
            controlX += 25;
        }
        // Movement name/expand button
        int remainingWidth = Math.min(200, guiWidth / 3);
        String displayName = movement instanceof AbstractMovementSettings ?
                ((AbstractMovementSettings)movement).getDisplayName() :
                movement.getName();
        addDrawableChild(ButtonWidget.builder(
                        Text.literal((isMovementExpanded(slotIndex, index) ? "▼ " : "▶ ") + displayName),
                        button -> {
                            toggleMovementExpanded(slotIndex, index);
                            reinitialize();
                        })
                .dimensions(controlX, rowY, remainingWidth, BUTTON_HEIGHT)
                .build());
        // Copy button after the name
        controlX += remainingWidth + 5;
        addDrawableChild(ButtonWidget.builder(Text.literal("Copy"), button -> copyMovement(movement))
                .dimensions(controlX, rowY, 30, BUTTON_HEIGHT)
                .build());
    }
    // Update the addGeneralSettings() method in MenuOverlayScreen.java
    private void addGeneralSettings() {
        int yOffset = CONTENT_START_Y + 20;
        int buttonWidth = 200;
        int buttonX = centerX + (guiWidth - buttonWidth) / 2;
        int spacing = 25;
        // Define the necessary dimensions
        int BUTTON_HEIGHT = 20;
        int totalWidth = guiWidth - 40;
        int labelWidth = Math.min(200, totalWidth / 3);
        int controlWidth = Math.min(200, totalWidth / 2);
        // Move Speed Slider
        float currentSpeed = FreeCamSettings.getMoveSpeed();
        this.addDrawableChild(ButtonWidget.builder(Text.literal("Free Camera Speed"), button -> {})
                .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                .build());
        this.addDrawableChild(SettingWidget.createSlider(
                buttonX + labelWidth + 10,
                centerY + yOffset,
                controlWidth,
                BUTTON_HEIGHT,
                Text.literal("Free Camera Speed"),
                0.1f,
                2.0f,
                currentSpeed,
                "moveSpeed",
                new AbstractMovementSettings() {
                    @Override
                    public void updateSetting(String key, Object value) {
                        if (key.equals("moveSpeed") && value instanceof Number) {
                            FreeCamSettings.setMoveSpeed(((Number)value).floatValue());
                        }
                    }
                }
        ));
        yOffset += spacing;
        // Movement Mode Button
        FreeCamSettings.MovementMode currentMode = FreeCamSettings.getMovementMode();
        this.addDrawableChild(ButtonWidget.builder(
                        Text.literal("Movement Mode: " + currentMode.name()),
                        button -> {
                            FreeCamSettings.MovementMode[] modes = FreeCamSettings.MovementMode.values();
                            int nextOrdinal = (currentMode.ordinal() + 1) % modes.length;
                            FreeCamSettings.setMovementMode(modes[nextOrdinal]);
                            button.setMessage(Text.literal("Movement Mode: " + modes[nextOrdinal].name()));
                        })
                .dimensions(buttonX, centerY + yOffset, buttonWidth, 20)
                .build()
        );
    }
    private void createMovementList(int slotIndex, int visibleStartY, int visibleEndY,
                                    int BUTTON_HEIGHT, int MOVEMENT_ROW_HEIGHT, int MOVEMENT_SPACING, int SETTING_HEIGHT) {
        List<ICameraMovement> movements = CraneshotClient.CAMERA_CONTROLLER.getAvailableMovementsForSlot(slotIndex);
        int yOffset = CONTENT_START_Y + BUTTON_HEIGHT + 10;
        for (int i = 0; i < movements.size(); i++) {
            int index = i;
            ICameraMovement movement = movements.get(i);
            int rowY = centerY + yOffset - scrollOffset;
            if (rowY >= visibleStartY - BUTTON_HEIGHT && rowY <= visibleEndY) {
                createMovementControls(slotIndex, index, movement, rowY, BUTTON_HEIGHT);
            }
            yOffset += MOVEMENT_ROW_HEIGHT;
            if (movement instanceof AbstractMovementSettings settings && isMovementExpanded(slotIndex, index)) {
                yOffset = createSettingsSection(settings, rowY, yOffset, visibleStartY, visibleEndY,
                        BUTTON_HEIGHT, SETTING_HEIGHT, MOVEMENT_SPACING);
            } else {
                yOffset += MOVEMENT_SPACING;
            }
        }
        updateScrollBounds(yOffset);
    }
    private int createSettingsSection(AbstractMovementSettings settings, int rowY, int yOffset,
                                      int visibleStartY, int visibleEndY, int BUTTON_HEIGHT, int SETTING_HEIGHT, int MOVEMENT_SPACING) {
        List<Field> settingFields = new ArrayList<>();
        collectSettingFields(settings, settingFields);
        int totalWidth = guiWidth - 40;
        int labelWidth = Math.min(200, totalWidth / 3);  // Increased from 150 to 200
        int controlWidth = Math.min(200, totalWidth / 2);
        int settingWidth = labelWidth + controlWidth + 10;
        int columnsCount = Math.max(1, Math.min(3, (totalWidth + 20) / (settingWidth + 20)));
        int settingsPerColumn = (int) Math.ceil(settingFields.size() / (double) columnsCount);
        for (int fieldIndex = 0; fieldIndex < settingFields.size(); fieldIndex++) {
            Field field = settingFields.get(fieldIndex);
            MovementSetting annotation = field.getAnnotation(MovementSetting.class);
            field.setAccessible(true);
            try {
                int column = fieldIndex / settingsPerColumn;
                int row = fieldIndex % settingsPerColumn;
                int settingX = centerX + 20 + column * (settingWidth + 20);
                int settingY = centerY + yOffset + (row * SETTING_HEIGHT) - scrollOffset;
                if (settingY >= visibleStartY - BUTTON_HEIGHT && settingY <= visibleEndY) {
                    createSettingControl(settings, field, annotation, settingX, settingY,
                            labelWidth, controlWidth, BUTTON_HEIGHT);
                }
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        return yOffset + (settingsPerColumn * SETTING_HEIGHT) + MOVEMENT_SPACING;
    }
    private void createSettingControl(AbstractMovementSettings settings, Field field,
                                      MovementSetting annotation, int settingX, int settingY,
                                      int labelWidth, int controlWidth, int BUTTON_HEIGHT)
            throws IllegalAccessException {
        if (annotation.type() == MovementSettingType.ENUM) {
            // For enums, create the button
            ButtonWidget enumButton = SettingWidget.createEnumButton(
                    settingX,
                    settingY,
                    labelWidth + controlWidth + 10,
                    BUTTON_HEIGHT,
                    field.getName(),
                    settings,
                    annotation
            );
            addDrawableChild(enumButton);
            // Add warning if needed for postMoveMouse field
            if (field.getName().equals("postMoveMouse")) {
                AbstractMovementSettings.POST_MOVE_MOUSE mouseMode =
                        (AbstractMovementSettings.POST_MOVE_MOUSE) field.get(settings);
                // Get the postMoveKeys field
                try {
                    Field keysField = AbstractMovementSettings.class.getDeclaredField("postMoveKeys");
                    keysField.setAccessible(true);
                    AbstractMovementSettings.POST_MOVE_KEYS keysMode =
                            (AbstractMovementSettings.POST_MOVE_KEYS) keysField.get(settings);
                    // Check warning conditions - only show warning for camera movement modes
                    if (mouseMode == AbstractMovementSettings.POST_MOVE_MOUSE.NONE &&
                            (keysMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
                                    keysMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) &&
                            keysMode != AbstractMovementSettings.POST_MOVE_KEYS.MOVE8 &&
                            keysMode != AbstractMovementSettings.POST_MOVE_KEYS.NONE) {
                        // Create warning button
                        ButtonWidget warningButton = ButtonWidget.builder(
                                        Text.literal("!").formatted(Formatting.GOLD),
                                        button -> {}
                                )
                                .dimensions(settingX + labelWidth + controlWidth + 15, settingY, 20, BUTTON_HEIGHT)
                                .tooltip(Tooltip.of(Text.literal(
                                        "Warning: Camera rotation will be locked, Rotate Camera recommended")))
                                .build();
                        addDrawableChild(warningButton);
                    }
                } catch (Exception e) {
                    Craneshot.LOGGER.error("Error checking warning conditions", e);
                }
            }
        } else {
            // For non-enum settings, keep the original label + control layout
            addDrawableChild(ButtonWidget.builder(Text.literal(annotation.label()), button -> {})
                    .dimensions(settingX, settingY, labelWidth, BUTTON_HEIGHT)
                    .build());
            addDrawableChild(SettingWidget.createSlider(
                    settingX + labelWidth + 10,
                    settingY,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal(annotation.label()),
                    annotation.min(),
                    annotation.max(),
                    ((Number) field.get(settings)).doubleValue(),
                    field.getName(),
                    settings
            ));
        }
    }
    private void collectSettingFields(AbstractMovementSettings settings, List<Field> settingFields) {
        // Get fields from the concrete class
        for (Field field : settings.getClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(MovementSetting.class)) {
                settingFields.add(field);
            }
        }
        // Get fields from AbstractMovementSettings
        for (Field field : AbstractMovementSettings.class.getDeclaredFields()) {
            if (field.isAnnotationPresent(MovementSetting.class)) {
                settingFields.add(field);
            }
        }
    }
    private void updateScrollBounds(int yOffset) {
        int contentHeight = yOffset - (CONTENT_START_Y + 20 + 10);
        int visibleHeight = guiHeight - CONTENT_START_Y - 10;
        maxScroll = Math.max(0, contentHeight - visibleHeight);
    }
    private void cycleMovementType() {
        List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
        if (!movements.isEmpty()) {
            selectedMovementTypeIndex = (selectedMovementTypeIndex + 1) % movements.size();
            reinitialize();
        }
    }
    private void addMovement(int slotIndex) {
        List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
        if (!movements.isEmpty()) {
            try {
                ICameraMovement newMovement = movements.get(selectedMovementTypeIndex)
                        .getMovementClass()
                        .getDeclaredConstructor()
                        .newInstance();
                CraneshotClient.CAMERA_CONTROLLER.addMovement(slotIndex, newMovement);
                reinitialize();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    @Override
    public void resize(MinecraftClient client, int width, int height) {
        super.resize(client, width, height);
        this.scrollOffset = 0;
        this.reinitialize();
    }
    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        context.fill(0, 0, this.width, this.height, 0x80000000);
        context.fill(
                centerX,
                centerY + CONTENT_START_Y,
                centerX + guiWidth,
                centerY + guiHeight,
                0xC0000000
        );
        super.render(context, mouseX, mouseY, delta);
        if (maxScroll > 0) {
            if (scrollOffset > 0) {
                context.drawCenteredTextWithShadow(
                        this.textRenderer,
                        Text.literal("▲"),
                        centerX + guiWidth - 15,
                        centerY + CONTENT_START_Y,
                        0xFFFFFF
                );
            }
            if (scrollOffset < maxScroll) {
                context.drawCenteredTextWithShadow(
                        this.textRenderer,
                        Text.literal("▼"),
                        centerX + guiWidth - 15,
                        centerY + guiHeight - 15,
                        0xFFFFFF
                );
            }
        }
    }
    // Keep existing helper methods
    private boolean isMovementExpanded(int slotIndex, int movementIndex) {
        return expandedMovements.computeIfAbsent(slotIndex, k -> new HashSet<>()).contains(movementIndex);
    }
    private void toggleMovementExpanded(int slotIndex, int movementIndex) {
        Set<Integer> expanded = expandedMovements.computeIfAbsent(slotIndex, k -> new HashSet<>());
        if (!expanded.remove(movementIndex)) {
            expanded.add(movementIndex);
        }
    }
    private void deleteMovement(int slotIndex, int movementIndex) {
        CraneshotClient.CAMERA_CONTROLLER.removeMovement(slotIndex, movementIndex);
        reinitialize();
    }
    private void moveMovement(int slotIndex, int fromIndex, int toIndex) {
        CraneshotClient.CAMERA_CONTROLLER.swapMovements(slotIndex, fromIndex, toIndex);
        reinitialize();
    }
    void reinitialize() {
        this.clearChildren();
        this.init();
    }
    @Override
    public boolean mouseScrolled(double mouseX, double mouseY, double horizontalAmount, double verticalAmount) {
        if (verticalAmount != 0) {
            scroll((int)(-verticalAmount * SCROLL_SPEED));
            return true;
        }
        return super.mouseScrolled(mouseX, mouseY, horizontalAmount, verticalAmount);
    }
    @Override
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        if (keyCode == CraneshotClient.toggleMenuKey.getDefaultKey().getCode()) toggleMenu();
        return true;
    }
    private void scroll(int amount) {
        if (maxScroll > 0) {
            scrollOffset = Math.max(0, Math.min(scrollOffset + amount, maxScroll));
            clearChildren();
            init();
        }
    }
    private void switchTab(int index) {
        selectedTab = index;
        scrollOffset = 0;
        clearChildren();
        init();
    }
    public void toggleMenu() {
        MinecraftClient client = MinecraftClient.getInstance();
        if (isMenuOpen) {
            close();
        } else {
            client.setScreen(this);
            isMenuOpen = true;
        }
    }
    @Override
    public void close() {
        // Save the current slots configuration before closing
        List<List<ICameraMovement>> slots = new ArrayList<>();
        for (int i = 0; i < CraneshotClient.CAMERA_CONTROLLER.getMovementCount(); i++) {
            slots.add(CraneshotClient.CAMERA_CONTROLLER.getAvailableMovementsForSlot(i));
        }
        SlotSettingsIO.saveSlots(slots);
        GeneralSettingsIO.saveSettings();
        if (this.client != null) {
            this.client.setScreen(null);
        }
        isMenuOpen = false;
    }
    private void copyMovement(ICameraMovement movement) {
        SlotSettingsIO.copyMovementToClipboard(movement);
    }
    private void pasteMovement(int slotIndex) {
        try {
            ICameraMovement newMovement = SlotSettingsIO.createMovementFromClipboard();
            if (newMovement != null) {
                CraneshotClient.CAMERA_CONTROLLER.addMovement(slotIndex, newMovement);
                reinitialize();
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to paste movement", e);
        }
    }
    @Override
    public boolean shouldPause() {
        return false;
    }
}
</file>

<file path="client/java/ninja/trek/config/MovementSetting.java">
package ninja.trek.config;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface MovementSetting {
    String label();
    String description() default "";
    double min() default 0;
    double max() default 100;
    MovementSettingType type() default MovementSettingType.SLIDER;
}
</file>

<file path="client/java/ninja/trek/config/MovementSettingType.java">
package ninja.trek.config;
public enum MovementSettingType {
    SLIDER,
    ENUM
}
</file>

<file path="client/java/ninja/trek/config/RenameModal.java">
package ninja.trek.config;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.TextFieldWidget;
import net.minecraft.text.Text;
import net.minecraft.client.gui.DrawContext;
import ninja.trek.cameramovements.AbstractMovementSettings;
public class RenameModal extends Screen {
    private final Screen parent;
    private final AbstractMovementSettings movement;
    private TextFieldWidget nameField;
    private final Runnable onComplete;
    private static final int MODAL_WIDTH = 200;
    private static final int MODAL_HEIGHT = 100;
    public RenameModal(Screen parent, AbstractMovementSettings movement, Runnable onComplete) {
        super(Text.literal("Rename Movement"));
        this.parent = parent;
        this.movement = movement;
        this.onComplete = onComplete;
    }
    @Override
    protected void init() {
        int centerX = width / 2;
        int centerY = height / 2;
        int modalLeft = centerX - MODAL_WIDTH / 2;
        int modalTop = centerY - MODAL_HEIGHT / 2;
        // Create text field
        nameField = new TextFieldWidget(
                textRenderer,
                modalLeft + 10,
                modalTop + 30,
                MODAL_WIDTH - 20,
                20,
                Text.literal("Name")
        );
        nameField.setText(movement.getDisplayName());
        nameField.setMaxLength(32);
        addSelectableChild(nameField);
        setInitialFocus(nameField);
        // Create buttons
        addDrawableChild(ButtonWidget.builder(Text.literal("Save"), button -> {
                    movement.setCustomName(nameField.getText());
                    if (onComplete != null) onComplete.run();
                    close();
                })
                .dimensions(modalLeft + 10, modalTop + MODAL_HEIGHT - 30, 80, 20)
                .build());
        addDrawableChild(ButtonWidget.builder(Text.literal("Cancel"), button -> close())
                .dimensions(modalLeft + MODAL_WIDTH - 90, modalTop + MODAL_HEIGHT - 30, 80, 20)
                .build());
    }
    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        if (parent != null) {
           // parent.render(context, mouseX, mouseY, delta);
        }
        super.render(context, mouseX, mouseY, delta);
        int centerX = width / 2;
        int centerY = height / 2;
        int modalLeft = centerX - MODAL_WIDTH / 2;
        int modalTop = centerY - MODAL_HEIGHT / 2;
        // Draw modal background
        context.fill(modalLeft, modalTop, modalLeft + MODAL_WIDTH, modalTop + MODAL_HEIGHT, 0xF0000000);
        context.fill(modalLeft + 1, modalTop + 1, modalLeft + MODAL_WIDTH - 1, modalTop + MODAL_HEIGHT - 1, 0xFF444444);
        // Draw title
        context.drawCenteredTextWithShadow(textRenderer, "Rename Movement", centerX, modalTop + 10, 0xFFFFFF);
        nameField.render(context, mouseX, mouseY, delta);
    }
    @Override
    public void close() {
        if (this.client != null) {
            this.client.setScreen(parent);
        }
    }
    @Override
    public boolean shouldPause() {
        return false;
    }
}
</file>

<file path="client/java/ninja/trek/config/SettingSlider.java">
package ninja.trek.config;
import net.minecraft.client.gui.widget.SliderWidget;
import net.minecraft.text.Text;
import ninja.trek.cameramovements.AbstractMovementSettings;
class SettingSlider extends SliderWidget {
    private final double min;
    private final double max;
    private final String fieldName;
    private final AbstractMovementSettings settings;
    private final Text label;
    public SettingSlider(int x, int y, int width, int height, Text label,
                         double min, double max, double value, String fieldName, AbstractMovementSettings settings) {
        super(x, y, width, height, label, (value - min) / (max - min));
        this.min = min;
        this.max = max;
        this.fieldName = fieldName;
        this.settings = settings;
        this.label = label;
        updateMessage();
    }
    @Override
    protected void updateMessage() {
        setMessage(Text.literal(String.format("%.2f", getValue())));
    }
    @Override
    protected void applyValue() {
        double value = min + (max - min) * this.value;
        settings.updateSetting(fieldName, value);
    }
    public Text getLabel() {
        return label;
    }
    private double getValue() {
        return min + (max - min) * this.value;
    }
}
</file>

<file path="client/java/ninja/trek/config/SettingWidget.java">
package ninja.trek.config;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.tooltip.Tooltip;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.SliderWidget;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;
import ninja.trek.Craneshot;
import ninja.trek.cameramovements.AbstractMovementSettings;
import java.lang.reflect.Field;
public class SettingWidget {
    // Add this to the SettingWidget class in SettingWidget.java
    private static ButtonWidget createWarningButton(int x, int y) {
        return ButtonWidget.builder(
                        Text.literal("!").formatted(Formatting.GOLD),
                        button -> {}  // Empty click handler since we're just showing tooltip
                )
                .dimensions(x, y, 20, 20)
                .tooltip(Tooltip.of(Text.literal("Warning: This configuration may cause view instability")))
                .build();
    }
    public static ButtonWidget[] createEnumButtonWithWarning(
            int x, int y, int width, int height,
            String fieldName, AbstractMovementSettings settings,
            MovementSetting annotation
    ) {
        ButtonWidget enumButton = createEnumButton(x, y, width, height, fieldName, settings, annotation);
        // Check if we need to show warning
        boolean showWarning = false;
        try {
            if (fieldName.equals("postMoveMouse")) {
                Field mouseField = settings.getClass().getDeclaredField("postMoveMouse");
                Field keysField = settings.getClass().getDeclaredField("postMoveKeys");
                mouseField.setAccessible(true);
                keysField.setAccessible(true);
                AbstractMovementSettings.POST_MOVE_MOUSE mouseMode =
                        (AbstractMovementSettings.POST_MOVE_MOUSE) mouseField.get(settings);
                AbstractMovementSettings.POST_MOVE_KEYS keysMode =
                        (AbstractMovementSettings.POST_MOVE_KEYS) keysField.get(settings);
                if (mouseMode == AbstractMovementSettings.POST_MOVE_MOUSE.NONE &&
                        (keysMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
                                keysMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE)) {
                    showWarning = true;
                }
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Error checking warning conditions", e);
        }
        if (showWarning) {
            ButtonWidget warningButton = createWarningButton(x + width + 5, y);
            return new ButtonWidget[]{enumButton, warningButton};
        } else {
            return new ButtonWidget[]{enumButton};
        }
    }
    public static ButtonWidget createEnumButton(int x, int y, int width, int height,
                                                String fieldName, AbstractMovementSettings settings,
                                                MovementSetting annotation) {
        try {
            Field field = null;
            try {
                field = settings.getClass().getDeclaredField(fieldName);
            } catch (NoSuchFieldException e) {
                try {
                    field = AbstractMovementSettings.class.getDeclaredField(fieldName);
                } catch (NoSuchFieldException ex) {
                    throw new IllegalStateException("Field not found: " + fieldName);
                }
            }
            if (!field.getType().isEnum()) {
                throw new IllegalStateException("Field is not an enum type: " + fieldName);
            }
            field.setAccessible(true);
            Object initialValue = field.get(settings);
            if (!(initialValue instanceof Enum<?>)) {
                throw new IllegalStateException("Field value is not an enum: " + fieldName);
            }
            Class<? extends Enum<?>> enumClass = (Class<? extends Enum<?>>) field.getType().asSubclass(Enum.class);
            Enum<?>[] enumConstants = enumClass.getEnumConstants();
            final Field finalField = field;
            // Create button with current value
            ButtonWidget button = ButtonWidget.builder(
                    Text.literal(formatButtonText(annotation.label(), initialValue.toString())),
                    btn -> {
                        try {
                            Enum<?> currentValue = (Enum<?>) finalField.get(settings);
                            int currentIndex = currentValue.ordinal();
                            int nextIndex = (currentIndex + 1) % enumConstants.length;
                            Enum<?> nextValue = enumConstants[nextIndex];
                            // Set the new value and update the settings
                            finalField.set(settings, nextValue);
                            settings.updateSetting(fieldName, nextValue.name());
                            // Update button text
                            btn.setMessage(Text.literal(formatButtonText(annotation.label(), nextValue.toString())));
                            // If this is either the postMoveMouse or postMoveKeys field, force a menu refresh to update warnings
                            if (fieldName.equals("postMoveMouse") || fieldName.equals("postMoveKeys")) {
                                if (MinecraftClient.getInstance().currentScreen instanceof MenuOverlayScreen menuScreen) {
                                    menuScreen.reinitialize();
                                }
                            }
                        } catch (IllegalAccessException e) {
                            Craneshot.LOGGER.error("Failed to update enum setting", e);
                        }
                    }
            ).dimensions(x, y, width, height).build();
            return button;
        } catch (Exception e) {
            Craneshot.LOGGER.error("Error creating enum button", e);
            return null;
        }
    }
    private static String formatButtonText(String label, String value) {
        // Convert SNAKE_CASE to Title Case and format nicely
        String formattedValue = value.toLowerCase()
                .replace('_', ' ')
                .trim();
        formattedValue = Character.toUpperCase(formattedValue.charAt(0)) +
                formattedValue.substring(1);
        return label + ": " + formattedValue;
    }
    public static SliderWidget createSlider(int x, int y, int width, int height, Text label,
                                            double min, double max, double value, String fieldName, AbstractMovementSettings settings) {
        return new SettingSlider(x, y, width, height, label, min, max, value, fieldName, settings);
    }
}
</file>

<file path="client/java/ninja/trek/config/SlotMenuSettings.java">
package ninja.trek.config;
import java.util.HashMap;
import java.util.Map;
public class SlotMenuSettings {
    private static final Map<Integer, Boolean> wrapStates = new HashMap<>();
    private static final Map<Integer, Boolean> toggleStates = new HashMap<>();
    public static boolean getWrapState(int slotIndex) {
        return wrapStates.getOrDefault(slotIndex, false);
    }
    public static void setWrapState(int slotIndex, boolean state) {
        wrapStates.put(slotIndex, state);
    }
    public static boolean getToggleState(int slotIndex) {
        return toggleStates.getOrDefault(slotIndex, false);
    }
    public static void setToggleState(int slotIndex, boolean state) {
        toggleStates.put(slotIndex, state);
    }
}
</file>

<file path="client/java/ninja/trek/config/SlotSettingsIO.java">
package ninja.trek.config;
import com.google.gson.*;
import net.minecraft.client.MinecraftClient;
import ninja.trek.Craneshot;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.movements.LinearMovement;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
public class SlotSettingsIO {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_slots.json");
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .registerTypeAdapter(ICameraMovement.class, new CameraMovementSerializer())
            .create();
    public static JsonObject movementToJson(ICameraMovement movement) {
        JsonObject movementObj = new JsonObject();
        movementObj.addProperty("type", movement.getClass().getName());
        if (movement instanceof AbstractMovementSettings settings) {
            JsonObject settingsObj = new JsonObject();
            for (Map.Entry<String, Object> entry : settings.getSettings().entrySet()) {
                if (entry.getValue() != null) {
                    settingsObj.addProperty(entry.getKey(), entry.getValue().toString());
                }
            }
            movementObj.add("settings", settingsObj);
        }
        return movementObj;
    }
    public static void saveSlots(List<List<ICameraMovement>> slots) {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            JsonArray slotsArray = new JsonArray();
            for (List<ICameraMovement> slot : slots) {
                JsonArray slotArray = new JsonArray();
                for (ICameraMovement movement : slot) {
                    slotArray.add(movementToJson(movement));
                }
                slotsArray.add(slotArray);
            }
            GSON.toJson(slotsArray, writer);
            Craneshot.LOGGER.info("Saved camera movement slots configuration");
        } catch (IOException e) {
            Craneshot.LOGGER.error("Failed to save camera movement slots", e);
        }
    }
    public static ICameraMovement jsonToMovement(JsonObject movementObj) {
        String type = movementObj.get("type").getAsString();
        try {
            Class<?> movementClass = Class.forName(type);
            Constructor<?> constructor = movementClass.getDeclaredConstructor();
            ICameraMovement movement = (ICameraMovement) constructor.newInstance();
            if (movement instanceof AbstractMovementSettings settings &&
                    movementObj.has("settings")) {
                JsonObject settingsObj = movementObj.getAsJsonObject("settings");
                for (Map.Entry<String, JsonElement> entry : settingsObj.entrySet()) {
                    String value = entry.getValue().getAsString();
                    settings.updateSetting(entry.getKey(), value);
                }
            }
            return movement;
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to load movement: " + type, e);
            // Return default movement if loading fails
            return new LinearMovement();
        }
    }
    public static List<List<ICameraMovement>> loadSlots() {
        List<List<ICameraMovement>> slots = new ArrayList<>();
        if (!CONFIG_FILE.exists()) {
            // Return default configuration with one EasingMovement per slot
            for (int i = 0; i < 3; i++) {
                List<ICameraMovement> slot = new ArrayList<>();
                slot.add(new LinearMovement());
                slots.add(slot);
            }
            return slots;
        }
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            JsonArray slotsArray = JsonParser.parseReader(reader).getAsJsonArray();
            for (JsonElement slotElement : slotsArray) {
                List<ICameraMovement> slot = new ArrayList<>();
                JsonArray slotArray = slotElement.getAsJsonArray();
                for (JsonElement movementElement : slotArray) {
                    JsonObject movementObj = movementElement.getAsJsonObject();
                    slot.add(jsonToMovement(movementObj));
                }
                slots.add(slot);
            }
            Craneshot.LOGGER.info("Loaded camera movement slots configuration");
        } catch (IOException e) {
            Craneshot.LOGGER.error("Failed to load camera movement slots", e);
            // Return default configuration on error
            for (int i = 0; i < 3; i++) {
                List<ICameraMovement> slot = new ArrayList<>();
                slot.add(new LinearMovement());
                slots.add(slot);
            }
        }
        return slots;
    }
    public static void copyMovementToClipboard(ICameraMovement movement) {
        try {
            JsonObject movementJson = movementToJson(movement);
            String jsonStr = GSON.toJson(movementJson);
            // Use Minecraft's clipboard handling
            MinecraftClient.getInstance().keyboard.setClipboard(jsonStr);
            Craneshot.LOGGER.info("Copied movement settings to clipboard");
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to copy movement settings", e);
        }
    }
    public static ICameraMovement createMovementFromClipboard() {
        try {
            // Use Minecraft's clipboard handling
            String clipboardText = MinecraftClient.getInstance().keyboard.getClipboard();
            JsonObject movementObj = JsonParser.parseString(clipboardText).getAsJsonObject();
            return jsonToMovement(movementObj);
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to create movement from clipboard", e);
            return new LinearMovement(); // Return default movement if parsing fails
        }
    }
    private static class CameraMovementSerializer implements JsonSerializer<ICameraMovement> {
        @Override
        public JsonElement serialize(ICameraMovement movement, java.lang.reflect.Type typeOfSrc, JsonSerializationContext context) {
            return movementToJson(movement);
        }
    }
}
</file>

<file path="client/java/ninja/trek/config/WrapSettings.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.client.MinecraftClient;
import java.io.*;
import java.util.HashMap;
import java.util.Map;
public class WrapSettings {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_wrap.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static Map<Integer, Boolean> wrapStates = new HashMap<>();
    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) return;
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            wrapStates = GSON.fromJson(reader, Map.class);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static void saveSettings() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(wrapStates, writer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static boolean getWrapState(int slotIndex) {
        return wrapStates.getOrDefault(slotIndex, false);
    }
    public static void setWrapState(int slotIndex, boolean state) {
        wrapStates.put(slotIndex, state);
        saveSettings();
    }
}
</file>

<file path="client/java/ninja/trek/CraneshotClient.java">
package ninja.trek;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.client.util.InputUtil;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.config.GeneralSettingsIO;
import ninja.trek.config.MenuOverlayScreen;
import ninja.trek.config.SlotSettingsIO;
import org.lwjgl.glfw.GLFW;
import java.util.List;
public class CraneshotClient implements ClientModInitializer {
	public static KeyBinding[] cameraKeyBinds;
	public static KeyBinding selectMovementType;
	public static final CameraController CAMERA_CONTROLLER = new CameraController();
	public static KeyBinding toggleMenuKey;
	private static boolean isMenuOpen = false;
	public static MenuOverlayScreen MENU = new MenuOverlayScreen();
	@Override
	public void onInitializeClient() {
		toggleMenuKey = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.toggle_menu",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_Z,
				"category.craneshot.ui"
		));
		selectMovementType = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.select_movement",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_X,
				"category.craneshot.camera"
		));
		cameraKeyBinds = new KeyBinding[]{
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera1",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_C,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera2",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_V,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera3",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_B,
						"category.craneshot.camera"
				))
		};
		CameraMovementRegistry.initialize();
		GeneralSettingsIO.loadSettings();
		List<List<ICameraMovement>> savedSlots = SlotSettingsIO.loadSlots();
		CAMERA_CONTROLLER.setAllSlots(savedSlots);
		CraneShotEventHandler.register();
	}
	public static void checkKeybinds() {
		if (toggleMenuKey.wasPressed()) {
			MENU.toggleMenu();
		}
	}
}
</file>

<file path="client/java/ninja/trek/CraneshotDataGenerator.java">
package ninja.trek;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class CraneshotDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/java/ninja/trek/CraneShotEventHandler.java">
package ninja.trek;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;
import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.text.Text;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.config.SlotMenuSettings;
import ninja.trek.mixin.client.MouseAccessor;
import java.util.HashMap;
import java.util.Map;
public class CraneShotEventHandler {
    private static final double SCROLL_COOLDOWN = 0.1;
    private static double lastScrollTime = 0;
    private static final Map<Integer, Boolean> keyStates = new HashMap<>();
    private static final Map<Integer, Boolean> toggledStates = new HashMap<>();
    public static void register() {
        // Register client tick event for input handling
        ClientTickEvents.END_CLIENT_TICK.register(client -> {
            handleScrollInput(client);
            CraneshotClient.checkKeybinds();
        });
        // Register HUD rendering for messages
        HudRenderCallback.EVENT.register((context, tickDelta) -> {
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.player != null && CraneshotClient.CAMERA_CONTROLLER.hasActiveMessage()) {
                String message = CraneshotClient.CAMERA_CONTROLLER.getCurrentMessage();
                int width = client.getWindow().getScaledWidth();
                context.drawTextWithShadow(
                        client.textRenderer,
                        Text.literal(message),
                        width / 2 - client.textRenderer.getWidth(message) / 2,
                        60,
                        0xFFFFFF
                );
            }
        });
        // Register world render event for camera updates
        WorldRenderEvents.START.register(context -> {
            MinecraftClient client = MinecraftClient.getInstance();
            Camera camera = client.gameRenderer.getCamera();
            // Collect current key states
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                boolean currentlyPressed = CraneshotClient.cameraKeyBinds[i].isPressed();
                boolean wasPressed = keyStates.getOrDefault(i, false);
                // Only notify on state changes
                if (currentlyPressed != wasPressed) {
                    CraneshotClient.CAMERA_CONTROLLER.handleKeyStateChange(i, currentlyPressed, client, camera);
                }
                keyStates.put(i, currentlyPressed);
            }
        });
    }
    private static void handleScrollInput(MinecraftClient client) {
        double currentTime = System.currentTimeMillis() / 1000.0;
        if (currentTime - lastScrollTime < SCROLL_COOLDOWN) {
            return;
        }
        MouseAccessor mouseAccessor = (MouseAccessor)client.mouse;
        double scrollDelta = mouseAccessor.getEventDeltaVerticalWheel();
        if (scrollDelta == 0) {
            return;
        }
        boolean scrollUp = scrollDelta > 0;
        // Handle movement type cycling
        if (CraneshotClient.selectMovementType.isPressed()) {
            CraneshotClient.CAMERA_CONTROLLER.cycleMovementType(scrollUp);
            // Find the active movement to display its type
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    CraneshotClient.CAMERA_CONTROLLER.showMovementTypeMessage(i);
                    break;
                }
            }
            lastScrollTime = currentTime;
            mouseAccessor.setEventDeltaVerticalWheel(0);
        }
        // Handle distance adjustment
        else {
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    CraneshotClient.CAMERA_CONTROLLER.adjustDistance(i, !scrollUp);
                    lastScrollTime = currentTime;
                    mouseAccessor.setEventDeltaVerticalWheel(0);
                    break;
                }
            }
        }
    }
}
</file>

<file path="client/java/ninja/trek/IKeyboardInputMixin.java">
package ninja.trek;
public interface IKeyboardInputMixin {
    void setDisabled(boolean disabled);
}
</file>

<file path="client/java/ninja/trek/IMouseMixin.java">
package ninja.trek;
public interface IMouseMixin {
    double getCapturedDeltaX();
    double getCapturedDeltaY();
}
</file>

<file path="client/java/ninja/trek/mixin/client/CameraAccessor.java">
package ninja.trek.mixin.client;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.BlockView;
import ninja.trek.CraneshotClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import org.spongepowered.asm.mixin.gen.Invoker;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
// CameraAccessor.java
@Mixin(Camera.class)
public interface CameraAccessor {
    @Accessor("pos")
    void invokesetPos(Vec3d pos);
    @Accessor("pos")
    Vec3d getPos();
    @Invoker("setRotation")
    void invokeSetRotation(float yaw, float pitch);
}
</file>

<file path="client/java/ninja/trek/mixin/client/CameraMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.Entity;
import net.minecraft.world.BlockView;
import ninja.trek.CraneshotClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
// CameraMixin.java
@Mixin(Camera.class)
public class CameraMixin {
    @Inject(method = "update", at = @At("TAIL"))
    private void onCameraUpdate(BlockView area, Entity focusedEntity, boolean thirdPerson,
                                boolean inverseView, float tickDelta, CallbackInfo ci) {
        CraneshotClient.CAMERA_CONTROLLER.handleCameraUpdate(area, focusedEntity, thirdPerson, inverseView, tickDelta, (Camera)(Object)this);
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/ExampleClientMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/mixin/client/KeyboardInputMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.input.Input;
import net.minecraft.client.input.KeyboardInput;
import ninja.trek.IKeyboardInputMixin;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(KeyboardInput.class)
public abstract class KeyboardInputMixin extends Input implements IKeyboardInputMixin {
    private boolean disabled = false;
    private float savedForward, savedSideways;
    private boolean savedJumping, savedSneaking;
    private boolean savedSprinting;  // Add sprinting state
    @Override
    public void setDisabled(boolean disabled) {
        if (this.disabled != disabled) {
            if (disabled) {
                // Store current state when disabling
                this.savedForward = this.movementForward;
                this.savedSideways = this.movementSideways;
                this.savedJumping = this.jumping;
                this.savedSneaking = this.sneaking;
                // Immediately clear all movement
                this.movementForward = 0;
                this.movementSideways = 0;
                this.jumping = false;
                this.sneaking = false;
            }
            this.disabled = disabled;
        }
    }
    @Inject(method = "tick", at = @At("HEAD"), cancellable = true)
    private void onTick(boolean slowDown, float slowDownFactor, CallbackInfo ci) {
        if (disabled) {
            // Force all movement values to zero
            this.movementForward = 0;
            this.movementSideways = 0;
            this.jumping = false;
            this.sneaking = false;
            ci.cancel();
        } else {
            // Restore saved state when not disabled
            this.movementForward = savedForward;
            this.movementSideways = savedSideways;
            this.jumping = savedJumping;
            this.sneaking = savedSneaking;
        }
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseAccessor.java">
package ninja.trek.mixin.client;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import net.minecraft.client.Mouse;
@Mixin(Mouse.class)
public interface MouseAccessor {
    @Accessor("cursorDeltaX")
    double getCursorDeltaX();
    @Accessor("cursorDeltaY")
    double getCursorDeltaY();
    @Accessor("cursorDeltaX")
    void setCursorDeltaX(double value);
    @Accessor("cursorDeltaY")
    void setCursorDeltaY(double value);
    @Accessor("eventDeltaVerticalWheel")
    double getEventDeltaVerticalWheel();
    @Accessor("eventDeltaVerticalWheel")
    void setEventDeltaVerticalWheel(double value);
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.Mouse;
import ninja.trek.IMouseMixin;
import ninja.trek.MouseInterceptor;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(Mouse.class)
public class MouseMixin implements IMouseMixin {
    @Shadow private double cursorDeltaX;
    @Shadow private double cursorDeltaY;
    private double capturedDeltaX;
    private double capturedDeltaY;
    @Inject(method = "updateMouse", at = @At("HEAD"), cancellable = true)
    private void onUpdateMouse(CallbackInfo ci) {
        MinecraftClient client = MinecraftClient.getInstance();
        // Only intercept mouse movement if we're intercepting AND not in a screen
        if (MouseInterceptor.isIntercepting() && client.currentScreen == null) {
            capturedDeltaX = cursorDeltaX;
            capturedDeltaY = cursorDeltaY;
            cursorDeltaX = 0;
            cursorDeltaY = 0;
            ci.cancel();
        }
    }
    @Inject(method = "onMouseButton", at = @At("HEAD"), cancellable = true)
    private void onMouseButton(long window, int button, int action, int mods, CallbackInfo ci) {
        MinecraftClient client = MinecraftClient.getInstance();
        // Only intercept mouse clicks if we're intercepting AND not in a screen
        if (MouseInterceptor.isIntercepting() && client.currentScreen == null) {
            ci.cancel();
        }
    }
    @Override
    public double getCapturedDeltaX() {
        return capturedDeltaX;
    }
    @Override
    public double getCapturedDeltaY() {
        return capturedDeltaY;
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/TransparencyMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.network.AbstractClientPlayerEntity;
import net.minecraft.client.render.RenderLayer;
import net.minecraft.client.render.VertexConsumer;
import net.minecraft.client.render.VertexConsumerProvider;
import net.minecraft.client.render.entity.PlayerEntityRenderer;
import net.minecraft.client.render.item.HeldItemRenderer;
import net.minecraft.client.render.model.json.ModelTransformationMode;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.entity.LivingEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.util.Arm;
import ninja.trek.CameraController;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.ModifyVariable;
public class TransparencyMixin {
    @Mixin(PlayerEntityRenderer.class)
    public static class PlayerMixin {
        @ModifyVariable(method = "render", at = @At("HEAD"), ordinal = 0)
        private VertexConsumerProvider modifyVertexConsumer(VertexConsumerProvider vertexConsumers,
                                                            AbstractClientPlayerEntity player, float yaw, float tickDelta,
                                                            MatrixStack matrices, VertexConsumerProvider originalVertexConsumers, int light) {
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.gameRenderer.getCamera() == null) return originalVertexConsumers;
            double distance = client.gameRenderer.getCamera().getPos().distanceTo(player.getEyePos());
            float alpha;
            if (distance <= CameraController.FIRST_PERSON_THRESHOLD_MIN) {
                alpha = 0.0f;
            } else if (distance >= CameraController.FIRST_PERSON_THRESHOLD_MAX) {
                alpha = 1.0f;
            } else {
                alpha = (float) ((distance - CameraController.FIRST_PERSON_THRESHOLD_MIN) /
                        (CameraController.FIRST_PERSON_THRESHOLD_MAX - CameraController.FIRST_PERSON_THRESHOLD_MIN));
            }
            return new VertexConsumerProvider() {
                @Override
                public VertexConsumer getBuffer(RenderLayer renderLayer) {
                    if (renderLayer.equals(RenderLayer.getEntitySolid(player.getSkinTextures().texture()))) {
                        RenderLayer translucentLayer = RenderLayer.getEntityTranslucent(
                                player.getSkinTextures().texture(), true);
                        return new TranslucentVertexConsumer(originalVertexConsumers.getBuffer(translucentLayer), alpha);
                    }
                    return originalVertexConsumers.getBuffer(renderLayer);
                }
            };
        }
    }
    @Mixin(HeldItemRenderer.class)
    public static class ItemMixin {
        @ModifyVariable(method = "renderArm", at = @At("HEAD"), ordinal = 0)
        private VertexConsumerProvider modifyArmVertexConsumer(VertexConsumerProvider vertexConsumers,
                                                               MatrixStack matrices, VertexConsumerProvider originalVertexConsumers, int light, Arm arm) {
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.gameRenderer.getCamera() == null || client.player == null) return originalVertexConsumers;
            double distance = client.gameRenderer.getCamera().getPos().distanceTo(client.player.getEyePos());
            float alpha = Math.max(0.0f, Math.min(1.0f,
                    (float) (distance / CameraController.FIRST_PERSON_THRESHOLD_MIN)));
            return new VertexConsumerProvider() {
                @Override
                public VertexConsumer getBuffer(RenderLayer renderLayer) {
                    if (client.player != null &&
                            renderLayer.equals(RenderLayer.getEntitySolid(client.player.getSkinTextures().texture()))) {
                        RenderLayer translucentLayer = RenderLayer.getEntityTranslucent(
                                client.player.getSkinTextures().texture(), true);
                        return new TranslucentVertexConsumer(originalVertexConsumers.getBuffer(translucentLayer), alpha);
                    }
                    return originalVertexConsumers.getBuffer(renderLayer);
                }
            };
        }
        @ModifyVariable(method = "renderItem", at = @At("HEAD"), ordinal = 0)
        private VertexConsumerProvider modifyItemVertexConsumer(VertexConsumerProvider vertexConsumers,
                                                                LivingEntity entity, ItemStack stack, ModelTransformationMode renderMode,
                                                                boolean leftHanded, MatrixStack matrices, VertexConsumerProvider originalVertexConsumers, int light) {
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.gameRenderer.getCamera() == null || client.player == null) return originalVertexConsumers;
            double distance = client.gameRenderer.getCamera().getPos().distanceTo(client.player.getEyePos());
            float alpha = Math.max(0.0f, Math.min(1.0f,
                    (float) (distance / CameraController.FIRST_PERSON_THRESHOLD_MIN)));
            return new VertexConsumerProvider() {
                @Override
                public VertexConsumer getBuffer(RenderLayer renderLayer) {
                    if (!renderLayer.toString().contains("entity")) {
                        return new TranslucentVertexConsumer(originalVertexConsumers.getBuffer(renderLayer), alpha);
                    }
                    return originalVertexConsumers.getBuffer(renderLayer);
                }
            };
        }
        @ModifyVariable(method = "renderFirstPersonItem", at = @At("HEAD"), ordinal = 0)
        private VertexConsumerProvider modifyFirstPersonItemVertexConsumer(VertexConsumerProvider vertexConsumers) {
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.gameRenderer.getCamera() == null || client.player == null) return vertexConsumers;
            double distance = client.gameRenderer.getCamera().getPos().distanceTo(client.player.getEyePos());
            float alpha = Math.max(0.0f, Math.min(1.0f,
                    (float) (distance / CameraController.FIRST_PERSON_THRESHOLD_MIN)));
            return new VertexConsumerProvider() {
                @Override
                public VertexConsumer getBuffer(RenderLayer renderLayer) {
                    if (!renderLayer.toString().contains("entity")) {
                        return new TranslucentVertexConsumer(vertexConsumers.getBuffer(renderLayer), alpha);
                    }
                    return vertexConsumers.getBuffer(renderLayer);
                }
            };
        }
    }
    private static class TranslucentVertexConsumer implements VertexConsumer {
        private final VertexConsumer parent;
        private final float alpha;
        public TranslucentVertexConsumer(VertexConsumer parent, float alpha) {
            this.parent = parent;
            this.alpha = alpha;
        }
        @Override
        public VertexConsumer vertex(float x, float y, float z) {
            return parent.vertex(x, y, z);
        }
        @Override
        public VertexConsumer color(int red, int green, int blue, int alpha) {
            return parent.color(red, green, blue, (int)(this.alpha * alpha));
        }
        @Override
        public VertexConsumer texture(float u, float v) {
            return parent.texture(u, v);
        }
        @Override
        public VertexConsumer overlay(int u, int v) {
            return parent.overlay(u, v);
        }
        @Override
        public VertexConsumer light(int u, int v) {
            return parent.light(u, v);
        }
        @Override
        public VertexConsumer normal(float x, float y, float z) {
            return parent.normal(x, y, z);
        }
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/WorldRendererMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.client.render.WorldRenderer;
import net.minecraft.client.render.Camera;
import net.minecraft.client.render.Frustum;
import net.minecraft.client.render.chunk.ChunkBuilder;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.math.ChunkSectionPos;
import ninja.trek.CameraController;
import ninja.trek.cameramovements.AbstractMovementSettings;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.*;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(WorldRenderer.class)
public abstract class WorldRendererMixin {
    @Shadow private int viewDistance;
    @Shadow private double lastCameraX;
    @Shadow private double lastCameraY;
    @Shadow private double lastCameraZ;
    private long lastUpdateTime = 0;
    private static final long UPDATE_INTERVAL = 1000; // 1 second in milliseconds
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 0
    )
    private double modifyPlayerX(double d) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            return CameraController.freeCamPosition.x;
        }
        return d;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 1
    )
    private double modifyPlayerY(double e) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            return CameraController.freeCamPosition.y;
        }
        return e;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 2
    )
    private double modifyPlayerZ(double f) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            return CameraController.freeCamPosition.z;
        }
        return f;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 3
    )
    private double modifyCameraX(double g) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            lastCameraX = CameraController.freeCamPosition.x;
            return CameraController.freeCamPosition.x;
        }
        return g;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 4
    )
    private double modifyCameraY(double h) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            lastCameraY = CameraController.freeCamPosition.y;
            return CameraController.freeCamPosition.y;
        }
        return h;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 5
    )
    private double modifyCameraZ(double l) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            lastCameraZ = CameraController.freeCamPosition.z;
            return CameraController.freeCamPosition.z;
        }
        return l;
    }
    @Inject(
            method = "setupTerrain",
            at = @At("HEAD")
    )
    private void onSetupTerrainStart(Camera camera, Frustum frustum, boolean hasForcedFrustum, boolean spectator, CallbackInfo ci) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            Vec3d freeCamPos = CameraController.freeCamPosition;
            ((CameraAccessor)camera).invokesetPos(freeCamPos);
            // Update the frustum to use the freecam position so that chunks aren't culled incorrectly.
            frustum.setPosition(freeCamPos.x, freeCamPos.y, freeCamPos.z);
            // Check if enough time has passed since last update
            long currentTime = System.currentTimeMillis();
            if (currentTime - lastUpdateTime > UPDATE_INTERVAL) {
                // Force chunk updates when camera moves significantly
                double movementThreshold = 12.0;
                double dx = Math.abs(freeCamPos.x - lastCameraX);
                double dy = Math.abs(freeCamPos.y - lastCameraY);
                double dz = Math.abs(freeCamPos.z - lastCameraZ);
                if (dx > movementThreshold || dy > movementThreshold || dz > movementThreshold) {
                    WorldRenderer worldRenderer = (WorldRenderer)(Object)this;
                    //worldRenderer.reload();
                    lastUpdateTime = currentTime;
                }
            }
        }
    }
    @Inject(
            method = "setupTerrain",
            at = @At("RETURN")
    )
    private void onSetupTerrainEnd(Camera camera, Frustum frustum, boolean hasForcedFrustum, boolean spectator, CallbackInfo ci) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            WorldRenderer worldRenderer = (WorldRenderer)(Object)this;
            worldRenderer.getChunkBuilder().setCameraPosition(CameraController.freeCamPosition);
        }
    }
    @ModifyArg(
            method = "setupTerrain",
            at = @At(
                    value = "INVOKE",
                    target = "Lnet/minecraft/client/render/chunk/ChunkBuilder;setCameraPosition(Lnet/minecraft/util/math/Vec3d;)V"
            ),
            index = 0
    )
    private Vec3d modifyChunkBuilderCameraPosition(Vec3d original) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            return CameraController.freeCamPosition;
        }
        return original;
    }
//    // Redirect the call to ClientPlayerEntity#getX() in setupTerrain
//    @Redirect(
//            method = "setupTerrain",
//            at = @At(
//                    value = "INVOKE",
//                    target = "Lnet/minecraft/client/network/ClientPlayerEntity;getX()D"
//            )
//    )
//    private double redirectPlayerX(ClientPlayerEntity player) {
//        if (CameraController.inFreeControlMode) {
//            return CameraController.freeCamPosition.x;
//        }
//        return player.getX();
//    }
//
//    // Redirect the call to ClientPlayerEntity#getY() in setupTerrain
//    @Redirect(
//            method = "setupTerrain",
//            at = @At(
//                    value = "INVOKE",
//                    target = "Lnet/minecraft/client/network/ClientPlayerEntity;getY()D"
//            )
//    )
//    private double redirectPlayerY(ClientPlayerEntity player) {
//        if (CameraController.inFreeControlMode) {
//            return CameraController.freeCamPosition.y;
//        }
//        return player.getY();
//    }
//
//    // Redirect the call to ClientPlayerEntity#getZ() in setupTerrain
//    @Redirect(
//            method = "setupTerrain",
//            at = @At(
//                    value = "INVOKE",
//                    target = "Lnet/minecraft/client/network/ClientPlayerEntity;getZ()D"
//            )
//    )
//    private double redirectPlayerZ(ClientPlayerEntity player) {
//        if (CameraController.inFreeControlMode) {
//            return CameraController.freeCamPosition.z;
//        }
//        return player.getZ();
//    }
//
//    // Redirect the call to Camera#getPitch() in setupTerrain so that it uses freecam pitch
//    @Redirect(
//            method = "setupTerrain",
//            at = @At(
//                    value = "INVOKE",
//                    target = "Lnet/minecraft/client/render/Camera;getPitch()F"
//            )
//    )
//    private float redirectCameraPitch(Camera camera) {
//        if (CameraController.inFreeControlMode) {
//            return CameraController.freeCamPitch;
//        }
//        return camera.getPitch();
//    }
//
//    // Redirect the call to Camera#getYaw() in setupTerrain so that it uses freecam yaw
//    @Redirect(
//            method = "setupTerrain",
//            at = @At(
//                    value = "INVOKE",
//                    target = "Lnet/minecraft/client/render/Camera;getYaw()F"
//            )
//    )
//    private float redirectCameraYaw(Camera camera) {
//        if (CameraController.inFreeControlMode) {
//            return CameraController.freeCamYaw;
//        }
//        return camera.getYaw();
//    }
}
</file>

<file path="client/java/ninja/trek/MouseInterceptor.java">
package ninja.trek;
public class MouseInterceptor {
    private static boolean intercepting = false;
    public static void setIntercepting(boolean intercept) {
        intercepting = intercept;
    }
    public static boolean isIntercepting() {
        return intercepting;
    }
}
</file>

<file path="client/resources/craneshot.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"MouseMixin",
		"CameraAccessor",
		"CameraMixin",
		"MouseAccessor",
		"KeyboardInputMixin",
		"WorldRendererMixin"

	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/Craneshot.java">
package ninja.trek;
import net.fabricmc.api.ModInitializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Craneshot implements ModInitializer {
	public static final String MOD_ID = "craneshot";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	@Override
	public void onInitialize() {
		LOGGER.info("CraneShot Camera Mod initialized!");
	}
}
</file>

<file path="main/java/ninja/trek/mixin/ExampleMixin.java">
package ninja.trek.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/resources/craneshot.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "craneshot",
	"version": "${version}",
	"name": "craneshot",
	"description": "Advanced camera controls mod for cinematics",
	"authors": ["Me!"],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/craneshot/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": ["ninja.trek.Craneshot"],
		"client": ["ninja.trek.CraneshotClient"],
		
		"fabric-datagen": ["ninja.trek.CraneshotDataGenerator"]
	},
	"mixins": [
		"craneshot.mixins.json",
		{
			"config": "craneshot.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*",
		"fabric-key-binding-api-v1": "*"
	}
}
</file>

<file path="repomixx - cameramovements folder.bat">
repomix client/java/ninja/trek/cameraMovements --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

<file path="repomixx - ignore config.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**" --ignore **/config/**
</file>

<file path="repomixx - movements only.bat">
repomix client/java/ninja/trek/cameraMovements/movements --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
