This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-04T21:22:33.347Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/CameraController.java
client/java/ninja/trek/cameramovements/AbstractMovementSettings.java
client/java/ninja/trek/cameramovements/ICameraMovement.java
client/java/ninja/trek/cameramovements/LinearMovement.java
client/java/ninja/trek/cameramovements/MovementSetting.java
client/java/ninja/trek/config/MenuOverlayScreen.java
client/java/ninja/trek/config/MovementConfigManager.java
client/java/ninja/trek/CraneshotClient.java
client/java/ninja/trek/CraneshotDataGenerator.java
client/java/ninja/trek/CraneShotEventHandler.java
client/java/ninja/trek/mixin/client/CameraAccessor.java
client/java/ninja/trek/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/mixin/client/MouseAccessor.java
client/java/ninja/trek/mixin/client/MouseMixin.java
client/resources/craneshot.client.mixins.json
main/java/ninja/trek/Craneshot.java
main/java/ninja/trek/mixin/ExampleMixin.java
main/resources/craneshot.mixins.json
main/resources/fabric.mod.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/CameraController.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import ninja.trek.cameramovements.*;
import java.util.ArrayList;
import java.util.List;
public class CameraController {
    private final List<List<ICameraMovement>> movements;
    private final ArrayList<Integer> currentTypes;
    private int currentMovement = -1;
    public CameraController() {
        movements = new ArrayList<>();
        currentTypes = new ArrayList<>();
        // Initialize slots with saved or default configurations
        for (int i = 0; i < 3; i++) {
            ArrayList arr = new ArrayList<ICameraMovement>();
            arr.add(new LinearMovement());
            arr.add(new LinearMovement());
            movements.add(
                   arr
                    );
            currentTypes.add(0);
        }
    }
    // Modified existing methods to work with Lists
    public int getMovementCount() {
        return movements.size();
    }
    public ICameraMovement getMovementAt(int index) {
        if (index >= 0 && index < movements.size()) {
            List<ICameraMovement> slotMovements = movements.get(index);
            int currentType = currentTypes.get(index);
            if (!slotMovements.isEmpty() && currentType < slotMovements.size()) {
                return slotMovements.get(currentType);
            }
        }
        return null;
    }
    public int getCurrentTypeForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < currentTypes.size()) {
            return currentTypes.get(slotIndex);
        }
        return 0;
    }
    public List<ICameraMovement> getAvailableMovementsForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < movements.size()) {
            return new ArrayList<>(movements.get(slotIndex));
        }
        return new ArrayList<>();
    }
    public void startTransition(MinecraftClient client, Camera camera, int movementIndex) {
        if (currentMovement != -1) {
            ICameraMovement current = getMovementAt(currentMovement);
            if (current != null) {
                current.reset(client, camera);
            }
        }
        currentMovement = movementIndex;
        ICameraMovement newMovement = getMovementAt(movementIndex);
        if (newMovement != null) {
            newMovement.start(client, camera);
        }
    }
    public void updateTransition(MinecraftClient client, Camera camera) {
        if (currentMovement != -1) {
            ICameraMovement movement = getMovementAt(currentMovement);
            if (movement != null && movement.update(client, camera)) {
                currentMovement = -1;
            }
        }
    }
    public void reset(MinecraftClient client, Camera camera) {
        if (currentMovement != -1) {
            ICameraMovement movement = getMovementAt(currentMovement);
            if (movement != null) {
                movement.reset(client, camera);
            }
            currentMovement = -1;
        }
    }
    public void cycleMovementType(boolean forward) {
        if (currentMovement != -1) {
            List<ICameraMovement> slotMovements = movements.get(currentMovement);
            int currentType = currentTypes.get(currentMovement);
            int newType = forward ?
                    (currentType + 1) % slotMovements.size() :
                    (currentType - 1 + slotMovements.size()) % slotMovements.size();
            currentTypes.set(currentMovement, newType);
        }
    }
    public ICameraMovement getCurrentMovement() {
        if (currentMovement >= 0) {
            return getMovementAt(currentMovement);
        }
        return null;
    }
    public void adjustDistance(int index, boolean increase) {
        ICameraMovement movement = getMovementAt(index);
        if (movement != null) {
            movement.adjustDistance(increase);
        }
    }
    public int getCurrentMovementIndex() {
        return currentMovement;
    }
    public void swapMovements(int slotIndex, int index1, int index2) {
        if (slotIndex >= 0 && slotIndex < movements.size()) {
            List<ICameraMovement> slotMovements = movements.get(slotIndex);
            if (index1 >= 0 && index1 < slotMovements.size() && index2 >= 0 && index2 < slotMovements.size()) {
                ICameraMovement temp = slotMovements.get(index1);
                slotMovements.set(index1, slotMovements.get(index2));
                slotMovements.set(index2, temp);
            }
        }
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/AbstractMovementSettings.java">
package ninja.trek.cameramovements;
import ninja.trek.config.MovementConfigManager;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;
public abstract class AbstractMovementSettings {
    public AbstractMovementSettings() {
        loadSettings();
    }
    public Map<String, Object> getSettings() {
        Map<String, Object> settings = new HashMap<>();
        for (Field field : this.getClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(MovementSetting.class)) {
                field.setAccessible(true);
                try {
                    settings.put(field.getName(), field.get(this));
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
            }
        }
        return settings;
    }
    public void updateSetting(String key, Object value) {
        try {
            Field field = this.getClass().getDeclaredField(key);
            if (field.isAnnotationPresent(MovementSetting.class)) {
                field.setAccessible(true);
                field.set(this, value);
                saveSettings();
            }
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }
    private void saveSettings() {
        MovementConfigManager.updateMovementSettings(this.getClass().getSimpleName(), getSettings());
    }
    private void loadSettings() {
        Map<String, Object> savedSettings = MovementConfigManager.getSettingsForMovement(this.getClass().getSimpleName());
        for (Map.Entry<String, Object> entry : savedSettings.entrySet()) {
            updateSetting(entry.getKey(), entry.getValue());
        }
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/ICameraMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
public interface ICameraMovement {
    void start(MinecraftClient client, Camera camera);
    boolean update(MinecraftClient client, Camera camera);
    void reset(MinecraftClient client, Camera camera);
    void adjustDistance(boolean increase);
    String getName();
}
</file>

<file path="client/java/ninja/trek/cameramovements/LinearMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.client.option.Perspective;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.mixin.client.CameraAccessor;
public class LinearMovement extends AbstractMovementSettings implements ICameraMovement {
    @MovementSetting(label = "Position Easing Factor", min = 0.01, max = 1.0)
    private double positionEasingFactor = 0.1f;
    @MovementSetting(label = "Rotation Easing Factor", min = 0.01, max = 1.0)
    private double rotationEasingFactor = 0.1f;
    @MovementSetting(label = "Distance Easing Factor", min = 0.01, max = 1.0)
    private double distanceEasingFactor = 0.1f;
    @MovementSetting(label = "Scroll Sensitivity", min = 0.1, max = 5.0)
    private double scrollSensitivity = 0.5f;
    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0f;
    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0f;
    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10;
    private double currentDistance = 0;
    private Vec3d smoothedPlayerEyePos = new Vec3d(0, 0, 0);
    private double smoothedYaw = 0;
    private double smoothedPitch = 0;
    private boolean resetting = false;
    private boolean wasFirstPerson = true;
    private double firstPersonDistanceThreshold = 2;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return;
        smoothedPlayerEyePos = player.getEyePos();
        smoothedYaw = player.getYaw();
        smoothedPitch = player.getPitch();
        currentDistance = 0;
        resetting = false;
        wasFirstPerson = client.options.getPerspective() == Perspective.FIRST_PERSON;
    }
    @Override
    public boolean update(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return true;
        // Smooth eye position interpolation
        Vec3d playerEyePos = player.getEyePos();
        smoothedPlayerEyePos = interpolateVec3d(smoothedPlayerEyePos, playerEyePos, positionEasingFactor);
        // Smooth rotation interpolation
        smoothedYaw = lerpAngle(smoothedYaw, player.getYaw(), rotationEasingFactor);
        smoothedPitch = lerpAngle(smoothedPitch, player.getPitch(), rotationEasingFactor);
        // Calculate desired distance based on whether we're resetting
        double desiredDistance = resetting ? 0 : targetDistance;
        currentDistance += (desiredDistance - currentDistance) * distanceEasingFactor;
        // Handle perspective changes
        if (currentDistance > firstPersonDistanceThreshold &&
                client.options.getPerspective() == Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.THIRD_PERSON_BACK);
        } else if (currentDistance < firstPersonDistanceThreshold &&
                client.options.getPerspective() != Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.FIRST_PERSON);
        }
        // Calculate camera position
        double yaw = Math.toRadians(smoothedYaw);
        double pitch = Math.toRadians(smoothedPitch);
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * currentDistance;
        double yOffset = Math.sin(pitch) * currentDistance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * currentDistance;
        Vec3d cameraPos = smoothedPlayerEyePos.add(xOffset, yOffset, zOffset);
        ((CameraAccessor)camera).invokesetPos(cameraPos);
        ((CameraAccessor)camera).invokeSetRotation((float) smoothedYaw, (float) smoothedPitch);
        return resetting && currentDistance < 0.01;
    }
    @Override
    public void reset(MinecraftClient client, Camera camera) {
        resetting = true;
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? (1.0 / (1.0 + scrollSensitivity)) : (1.0 + scrollSensitivity);
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
    }
    @Override
    public String getName() {
        return "Linear";
    }
    private Vec3d interpolateVec3d(Vec3d current, Vec3d target, double factor) {
        double x = current.x + (target.x - current.x) * factor;
        double y = current.y + (target.y - current.y) * factor;
        double z = current.z + (target.z - current.z) * factor;
        return new Vec3d(x, y, z);
    }
    private double lerpAngle(double current, double target, double factor) {
        double diff = target - current;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return current + diff * factor;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/MovementSetting.java">
package ninja.trek.cameramovements;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface MovementSetting {
    String label();
    double min() default 0;
    double max() default 100;
}
</file>

<file path="client/java/ninja/trek/config/MenuOverlayScreen.java">
package ninja.trek.config;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.SliderWidget;
import net.minecraft.text.Text;
import ninja.trek.CraneshotClient;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.MovementSetting;
import java.lang.reflect.Field;
import java.util.ArrayList;
import java.util.List;
public class MenuOverlayScreen extends Screen {
    private static final int GUI_WIDTH = 280;
    private static final int GUI_HEIGHT = 180;
    private static boolean isMenuOpen = false;
    private int selectedTab = 0;
    private final List<SettingSlider> settingSliders = new ArrayList<>();
    private int scrollOffset = 0;
    private static final int SCROLL_AMOUNT = 20;
    public MenuOverlayScreen() {
        super(Text.literal("CraneShot Settings"));
        isMenuOpen = true;
    }
    @Override
    protected void init() {
        int centerX = (this.width - GUI_WIDTH) / 2;
        int centerY = (this.height - GUI_HEIGHT) / 2;
        // Tab buttons
        for (int i = 0; i <= CraneshotClient.CAMERA_CONTROLLER.getMovementCount(); i++) {
            int tabIndex = i;
            String tabName = (i == 0) ? "General" : "Slot " + i;
            this.addDrawableChild(ButtonWidget.builder(Text.literal(tabName), button -> switchTab(tabIndex))
                    .dimensions(centerX + (i * 70), centerY - 30, 65, 20)
                    .build());
        }
        // Create sliders for the current tab's settings
        updateSliders(centerX, centerY);
        // Add scroll buttons if content exceeds view
        this.addDrawableChild(ButtonWidget.builder(Text.literal("▲"), button -> scroll(-SCROLL_AMOUNT))
                .dimensions(this.width - 30, centerY, 20, 20)
                .build());
        this.addDrawableChild(ButtonWidget.builder(Text.literal("▼"), button -> scroll(SCROLL_AMOUNT))
                .dimensions(this.width - 30, centerY + GUI_HEIGHT - 40, 20, 20)
                .build());
//        // Close button
//        this.addDrawableChild(ButtonWidget.builder(Text.literal("Save & Close"), button -> closeMenu())
//                .dimensions(centerX + GUI_WIDTH - 100, centerY + GUI_HEIGHT - 30, 90, 20)
//                .build());
    }
    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        // Fill with a semi-transparent background without blur
//        context.fill(0, 0, this.width, this.height, 0xC0000000);
        int centerX = (this.width - GUI_WIDTH) / 2;
        int centerY = (this.height - GUI_HEIGHT) / 2;
        // Draw main panel background
//        context.fill(
//                centerX,
//                centerY - 40,
//                centerX + GUI_WIDTH,
//                centerY + GUI_HEIGHT,
//                0xE0000000
//        );
        // Draw panel border
//        context.drawBorder(
//                centerX,
//                centerY - 40,
//                GUI_WIDTH,
//                GUI_HEIGHT + 40,
//                0xFFFFFFFF
//        );
        super.render(context, mouseX, mouseY, delta);
        // Draw slider labels
        for (SettingSlider slider : settingSliders) {
            String label = slider.getLabel().getString();
            int textX = centerX + 10;
            int textY = slider.getY() + 5;
            // Draw text with shadow for better visibility
            context.drawTextWithShadow(
                    this.textRenderer,
                    label,
                    textX,
                    textY,
                    0xFFFFFF
            );
        }
    }
    private void updateSliders(int centerX, int centerY) {
        settingSliders.clear();
        if (selectedTab > 0) {
            int slotIndex = selectedTab - 1;
            ICameraMovement movement = CraneshotClient.CAMERA_CONTROLLER.getMovementAt(slotIndex);
            if (movement instanceof AbstractMovementSettings settings) {
                int yOffset = 0;
                for (Field field : settings.getClass().getDeclaredFields()) {
                    if (field.isAnnotationPresent(MovementSetting.class)) {
                        MovementSetting annotation = field.getAnnotation(MovementSetting.class);
                        field.setAccessible(true);
                        try {
                            double value = ((Number) field.get(settings)).doubleValue();
                            SettingSlider slider = new SettingSlider(
                                    centerX + 110,
                                    centerY + 20 + yOffset - scrollOffset,
                                    150,
                                    20,
                                    Text.literal(annotation.label()),
                                    annotation.min(),
                                    annotation.max(),
                                    value,
                                    field.getName(),
                                    settings
                            );
                            settingSliders.add(slider);
                            this.addDrawableChild(slider);
                            yOffset += 30;
                        } catch (IllegalAccessException e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
        }
    }
    private void scroll(int amount) {
        int maxScroll = Math.max(0, (settingSliders.size() * 30) - GUI_HEIGHT + 60);
        scrollOffset = Math.max(0, Math.min(scrollOffset + amount, maxScroll));
        clearChildren();
        init();
    }
    private static class SettingSlider extends SliderWidget {
        private final double min;
        private final double max;
        private final String fieldName;
        private final AbstractMovementSettings settings;
        private final Text label;
        public SettingSlider(int x, int y, int width, int height, Text label,
                             double min, double max, double value,
                             String fieldName, AbstractMovementSettings settings) {
            super(x, y, width, height, label, (value - min) / (max - min));
            this.min = min;
            this.max = max;
            this.fieldName = fieldName;
            this.settings = settings;
            this.label = label;
            updateMessage();
        }
        @Override
        protected void updateMessage() {
            setMessage(Text.literal(String.format("%.2f", getValue())));
        }
        @Override
        protected void applyValue() {
            double value = min + (max - min) * this.value;
            settings.updateSetting(fieldName, value);
        }
        public Text getLabel() {
            return label;
        }
        private double getValue() {
            return min + (max - min) * this.value;
        }
    }
    private void switchTab(int index) {
        selectedTab = index;
        scrollOffset = 0;
        clearChildren();
        init();
    }
    private void closeMenu() {
        isMenuOpen = false;
        MinecraftClient.getInstance().setScreen(null);
    }
    public static void toggleMenu() {
        MinecraftClient client = MinecraftClient.getInstance();
        if (isMenuOpen) {
            client.setScreen(null);
            isMenuOpen = false;
        } else {
            client.setScreen(new MenuOverlayScreen());
            isMenuOpen = true;
        }
    }
    @Override
    public boolean shouldPause() {
        return false;
    }
}
</file>

<file path="client/java/ninja/trek/config/MovementConfigManager.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import net.minecraft.client.MinecraftClient;
import ninja.trek.cameramovements.ICameraMovement;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
public class MovementConfigManager {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_movements.json");
    private static Map<String, Map<String, Object>> movementSettings = new HashMap<>();
    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) return;
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            Type type = new TypeToken<Map<String, Map<String, Object>>>() {}.getType();
            movementSettings = GSON.fromJson(reader, type);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static void saveSettings() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(movementSettings, writer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static Map<String, Object> getSettingsForMovement(String movementName) {
        return movementSettings.getOrDefault(movementName, new HashMap<>());
    }
    public static void updateMovementSettings(String movementName, Map<String, Object> settings) {
        movementSettings.put(movementName, settings);
        saveSettings();
    }
}
</file>

<file path="client/java/ninja/trek/CraneshotClient.java">
package ninja.trek;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.client.util.InputUtil;
import ninja.trek.config.MenuOverlayScreen;
import org.lwjgl.glfw.GLFW;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
public class CraneshotClient implements ClientModInitializer {
	public static KeyBinding[] cameraKeyBinds;
	public static KeyBinding selectMovementType;
	public static final CameraController CAMERA_CONTROLLER = new CameraController();
	public static KeyBinding toggleMenuKey;
	private static boolean isMenuOpen = false;
	@Override
	public void onInitializeClient() {
		toggleMenuKey = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.toggle_menu",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_Z,
				"category.craneshot.ui"
		));
		selectMovementType = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.select_movement",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_X,
				"category.craneshot.camera"
		));
		cameraKeyBinds = new KeyBinding[]{
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera1",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_C,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera2",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_V,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera3",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_B,
						"category.craneshot.camera"
				))
		};
		CraneShotEventHandler.register();
	}
	public static void checkKeybinds() {
		if (toggleMenuKey.wasPressed()) {
			MenuOverlayScreen.toggleMenu();
		}
	}
}
</file>

<file path="client/java/ninja/trek/CraneshotDataGenerator.java">
package ninja.trek;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class CraneshotDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/java/ninja/trek/CraneShotEventHandler.java">
package ninja.trek;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;
import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.text.Text;
import ninja.trek.mixin.client.MouseAccessor;
public class CraneShotEventHandler {
    private static boolean[] wasPressed = new boolean[3];
    private static double lastScrollTime = 0;
    private static final double SCROLL_COOLDOWN = 0.1;
    private static String currentMessage = "";
    private static long messageTimer = 0;
    private static final long MESSAGE_DURATION = 2000;
    private static boolean showToast;
    public static void register() {
        ClientTickEvents.END_CLIENT_TICK.register(client -> {
            handleScrollInput(client);
            updateMessageTimer();
            CraneshotClient.checkKeybinds();
        });
        HudRenderCallback.EVENT.register((context, tickDelta) -> {
            if (!currentMessage.isEmpty() && System.currentTimeMillis() < messageTimer) {
                MinecraftClient client = MinecraftClient.getInstance();
                if (client.player != null) {
                    int width = client.getWindow().getScaledWidth();
                    context.drawTextWithShadow(client.textRenderer, Text.literal(currentMessage),
                            width / 2 - client.textRenderer.getWidth(currentMessage) / 2,
                            60, 0xFFFFFF);
                }
            }
        });
        WorldRenderEvents.START.register((context) -> {
            MinecraftClient client = MinecraftClient.getInstance();
            Camera camera = client.gameRenderer.getCamera();
            boolean anyPressed = false;
            for (int i = 0; i < 3; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    if (!wasPressed[i]) {
                        CraneshotClient.CAMERA_CONTROLLER.startTransition(client, camera, i);
                    }
                    wasPressed[i] = true;
                    anyPressed = true;
                } else {
                    wasPressed[i] = false;
                }
            }
            if (!anyPressed) {
                CraneshotClient.CAMERA_CONTROLLER.reset(client, camera);
            }
            if (client.player != null) {
                CraneshotClient.CAMERA_CONTROLLER.updateTransition(client, camera);
            }
        });
    }
    private static void handleScrollInput(MinecraftClient client) {
        double currentTime = System.currentTimeMillis() / 1000.0;
        if (currentTime - lastScrollTime < SCROLL_COOLDOWN) return;
        double scrollDelta = ((MouseAccessor)client.mouse).getEventDeltaVerticalWheel();
        if (scrollDelta == 0) return;
        boolean scrollUp = scrollDelta > 0;
        if (CraneshotClient.selectMovementType.isPressed()) {
            CraneshotClient.CAMERA_CONTROLLER.cycleMovementType(scrollUp);
            String movementType = CraneshotClient.CAMERA_CONTROLLER.getCurrentMovement().getName();
            currentMessage = String.format("Camera %d: %s Movement", CraneshotClient.CAMERA_CONTROLLER.getCurrentMovementIndex() + 1, movementType);
            showMovementTypeMessage(currentMessage);
            lastScrollTime = currentTime;
            ((MouseAccessor)client.mouse).setEventDeltaVerticalWheel(0);
        } else {
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    CraneshotClient.CAMERA_CONTROLLER.adjustDistance(i, scrollUp);
                    lastScrollTime = currentTime;
                    ((MouseAccessor)client.mouse).setEventDeltaVerticalWheel(0);
                    break;
                }
            }
        }
    }
    private static void showMovementTypeMessage(String message) {
        showToast = true;
        messageTimer = System.currentTimeMillis() + MESSAGE_DURATION;
    }
    private static void updateMessageTimer() {
        if (System.currentTimeMillis() >= messageTimer) {
            showToast = false;
        }
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/CameraAccessor.java">
package ninja.trek.mixin.client;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import org.spongepowered.asm.mixin.gen.Invoker;
@Mixin(Camera.class)
public interface CameraAccessor {
    @Accessor("pos")
    void invokesetPos(Vec3d pos);
    @Accessor("pos")
    Vec3d getPos();
    @Invoker("setRotation")
    void invokeSetRotation(float yaw, float pitch);
}
</file>

<file path="client/java/ninja/trek/mixin/client/ExampleClientMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseAccessor.java">
package ninja.trek.mixin.client;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import net.minecraft.client.Mouse;
@Mixin(Mouse.class)
public interface MouseAccessor {
    @Accessor("eventDeltaVerticalWheel")
    double getEventDeltaVerticalWheel();
    @Accessor("eventDeltaVerticalWheel")
    void setEventDeltaVerticalWheel(double value);
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.Mouse;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import ninja.trek.CraneshotClient;
@Mixin(Mouse.class)
public class MouseMixin {
    @Shadow private double eventDeltaVerticalWheel;
    @Inject(method = "onMouseScroll", at = @At("HEAD"), cancellable = true)
    private void onScroll(long window, double horizontal, double vertical, CallbackInfo ci) {
        if (CraneshotClient.selectMovementType.isPressed() ||
                CraneshotClient.cameraKeyBinds[0].isPressed() ||
                CraneshotClient.cameraKeyBinds[1].isPressed() ||
                CraneshotClient.cameraKeyBinds[2].isPressed()) {
            eventDeltaVerticalWheel = vertical;
            ci.cancel();
        }
    }
}
</file>

<file path="client/resources/craneshot.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"MouseMixin",
		"CameraAccessor",
		"MouseAccessor"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/Craneshot.java">
package ninja.trek;
import net.fabricmc.api.ModInitializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Craneshot implements ModInitializer {
	public static final String MOD_ID = "craneshot";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	@Override
	public void onInitialize() {
		LOGGER.info("CraneShot Camera Mod initialized!");
	}
}
</file>

<file path="main/java/ninja/trek/mixin/ExampleMixin.java">
package ninja.trek.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/resources/craneshot.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "craneshot",
	"version": "${version}",
	"name": "craneshot",
	"description": "Advanced camera controls mod for cinematics",
	"authors": ["Me!"],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/craneshot/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": ["ninja.trek.Craneshot"],
		"client": ["ninja.trek.CraneshotClient"],
		
		"fabric-datagen": ["ninja.trek.CraneshotDataGenerator"]
	},
	"mixins": [
		"craneshot.mixins.json",
		{
			"config": "craneshot.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*",
		"fabric-key-binding-api-v1": "*"
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
