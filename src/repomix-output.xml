This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-05T07:02:42.211Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/CameraController.java
client/java/ninja/trek/cameramovements/ICameraMovement.java
client/java/ninja/trek/cameramovements/LinearMovement.java
client/java/ninja/trek/config/AbstractMovementSettings.java
client/java/ninja/trek/config/MenuOverlayScreen.java
client/java/ninja/trek/config/MovementConfigManager.java
client/java/ninja/trek/config/MovementSetting.java
client/java/ninja/trek/config/SettingSlider.java
client/java/ninja/trek/config/TransitionMode.java
client/java/ninja/trek/config/TransitionModeManager.java
client/java/ninja/trek/config/WrapSettings.java
client/java/ninja/trek/CraneshotClient.java
client/java/ninja/trek/CraneshotDataGenerator.java
client/java/ninja/trek/CraneShotEventHandler.java
client/java/ninja/trek/mixin/client/CameraAccessor.java
client/java/ninja/trek/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/mixin/client/MouseAccessor.java
client/java/ninja/trek/mixin/client/MouseMixin.java
client/resources/craneshot.client.mixins.json
main/java/ninja/trek/Craneshot.java
main/java/ninja/trek/mixin/ExampleMixin.java
main/resources/craneshot.mixins.json
main/resources/fabric.mod.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/CameraController.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import ninja.trek.cameramovements.*;
import ninja.trek.config.TransitionMode;
import ninja.trek.config.TransitionModeManager;
import ninja.trek.config.WrapSettings;
import java.util.*;
public class CameraController {
    private final List<List<ICameraMovement>> slots;
    private final ArrayList<Integer> currentTypes;
    private int currentMovement = -1;
    private Queue<MovementRequest> movementQueue = new LinkedList<>();
    private static class MovementRequest {
        final int movementIndex;
        final MinecraftClient client;
        final Camera camera;
        MovementRequest(int movementIndex, MinecraftClient client, Camera camera) {
            this.movementIndex = movementIndex;
            this.client = client;
            this.camera = camera;
        }
    }
    public CameraController() {
        slots = new ArrayList<>();
        currentTypes = new ArrayList<>();
        // Initialize slots with saved or default configurations
        for (int i = 0; i < 3; i++) {
            ArrayList arr = new ArrayList<ICameraMovement>();
            arr.add(new LinearMovement());
            arr.add(new LinearMovement());
            slots.add(
                   arr
                    );
            currentTypes.add(0);
        }
    }
    public void addMovement(int slotIndex, ICameraMovement movement) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            slots.get(slotIndex).add(movement);
        }
    }
    public void removeMovement(int slotIndex, int movementIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (movementIndex >= 0 && movementIndex < slotMovements.size() && slotMovements.size() > 1) {
                slotMovements.remove(movementIndex);
                // Update current type if needed
                if (currentTypes.get(slotIndex) >= slotMovements.size()) {
                    currentTypes.set(slotIndex, slotMovements.size() - 1);
                }
            }
        }
    }
    public void cycleMovementType(boolean forward) {
        if (currentMovement != -1) {
            List<ICameraMovement> slotMovements = slots.get(currentMovement);
            int currentType = currentTypes.get(currentMovement);
            boolean wrap = WrapSettings.getWrapState(currentMovement);
            if (forward) {
                if (currentType < slotMovements.size() - 1 || wrap) {
                    int newType = wrap ?
                            (currentType + 1) % slotMovements.size() :
                            Math.min(currentType + 1, slotMovements.size() - 1);
                    currentTypes.set(currentMovement, newType);
                }
            } else {
                if (currentType > 0 || wrap) {
                    int newType = wrap ?
                            (currentType - 1 + slotMovements.size()) % slotMovements.size() :
                            Math.max(currentType - 1, 0);
                    currentTypes.set(currentMovement, newType);
                }
            }
        }
    }
    // Modified existing methods to work with Lists
    public int getMovementCount() {
        return slots.size();
    }
    public ICameraMovement getMovementAt(int index) {
        if (index >= 0 && index < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(index);
            int currentType = currentTypes.get(index);
            if (!slotMovements.isEmpty() && currentType < slotMovements.size()) {
                return slotMovements.get(currentType);
            }
        }
        return null;
    }
    public int getCurrentTypeForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < currentTypes.size()) {
            return currentTypes.get(slotIndex);
        }
        return 0;
    }
    public List<ICameraMovement> getAvailableMovementsForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            return new ArrayList<>(slots.get(slotIndex));
        }
        return new ArrayList<>();
    }
    public ICameraMovement getCurrentMovement() {
        if (currentMovement >= 0) {
            return getMovementAt(currentMovement);
        }
        return null;
    }
    public void adjustDistance(int index, boolean increase) {
        ICameraMovement movement = getMovementAt(index);
        if (movement != null) {
            movement.adjustDistance(increase);
        }
    }
    public int getCurrentMovementIndex() {
        return currentMovement;
    }
    public void swapMovements(int slotIndex, int index1, int index2) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (index1 >= 0 && index1 < slotMovements.size() && index2 >= 0 && index2 < slotMovements.size()) {
                ICameraMovement temp = slotMovements.get(index1);
                slotMovements.set(index1, slotMovements.get(index2));
                slotMovements.set(index2, temp);
            }
        }
    }
    public void startTransition(MinecraftClient client, Camera camera, int movementIndex) {
        switch (TransitionModeManager.getCurrentMode()) {
            case QUEUE:
                if (currentMovement == -1) {
                    // If no movement is active, start immediately
                    startMovementImmediate(client, camera, movementIndex);
                } else {
                    // Otherwise, queue the movement
                    movementQueue.offer(new MovementRequest(movementIndex, client, camera));
                }
                break;
            case INTERPOLATE:
                // Placeholder for future interpolation implementation
                startMovementImmediate(client, camera, movementIndex);
                break;
            case IMMEDIATE:
            default:
                startMovementImmediate(client, camera, movementIndex);
                break;
        }
    }
    private void startMovementImmediate(MinecraftClient client, Camera camera, int movementIndex) {
        if (currentMovement != -1) {
            ICameraMovement current = getMovementAt(currentMovement);
            if (current != null) {
                current.reset(client, camera);
            }
        }
        currentMovement = movementIndex;
        ICameraMovement newMovement = getMovementAt(movementIndex);
        if (newMovement != null) {
            newMovement.start(client, camera);
        }
    }
    public void tick(MinecraftClient client, Camera camera) {
        if (currentMovement != -1) {
            ICameraMovement movement = getMovementAt(currentMovement);
            if (movement != null && movement.update(client, camera)) {
                // Movement is complete
                currentMovement = -1;
                // If there are queued movements and we're in queue mode, start the next one
                if (TransitionModeManager.getCurrentMode() == TransitionMode.QUEUE && !movementQueue.isEmpty()) {
                    MovementRequest next = movementQueue.poll();
                    startMovementImmediate(next.client, next.camera, next.movementIndex);
                }
            }
        }
    }
    public void queueFinish(MinecraftClient client, Camera camera) {
        if (currentMovement != -1) {
            ICameraMovement movement = getMovementAt(currentMovement);
            if (movement != null) {
                movement.reset(client, camera);
            }
        }
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/ICameraMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
public interface ICameraMovement {
    void start(MinecraftClient client, Camera camera);
    boolean update(MinecraftClient client, Camera camera);
    void reset(MinecraftClient client, Camera camera);
    void adjustDistance(boolean increase);
    String getName();
}
</file>

<file path="client/java/ninja/trek/cameramovements/LinearMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.client.option.Perspective;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.config.AbstractMovementSettings;
import ninja.trek.config.MovementSetting;
import ninja.trek.mixin.client.CameraAccessor;
public class LinearMovement extends AbstractMovementSettings implements ICameraMovement {
    @MovementSetting(label = "Position Easing Factor", min = 0.01, max = 1.0)
    private double positionEasingFactor = 0.1f;
    @MovementSetting(label = "Rotation Easing Factor", min = 0.01, max = 1.0)
    private double rotationEasingFactor = 0.1f;
    @MovementSetting(label = "Distance Easing Factor", min = 0.01, max = 1.0)
    private double distanceEasingFactor = 0.1f;
    @MovementSetting(label = "Scroll Sensitivity", min = 0.1, max = 5.0)
    private double scrollSensitivity = 0.5f;
    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0f;
    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0f;
    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10;
    private double currentDistance = 0;
    private Vec3d smoothedPlayerEyePos = new Vec3d(0, 0, 0);
    private double smoothedYaw = 0;
    private double smoothedPitch = 0;
    private boolean resetting = false;
    private boolean wasFirstPerson = true;
    private double firstPersonDistanceThreshold = 2;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return;
        smoothedPlayerEyePos = player.getEyePos();
        smoothedYaw = player.getYaw();
        smoothedPitch = player.getPitch();
        currentDistance = 0;
        resetting = false;
        wasFirstPerson = client.options.getPerspective() == Perspective.FIRST_PERSON;
    }
    @Override
    public boolean update(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return true;
        // Smooth eye position interpolation
        Vec3d playerEyePos = player.getEyePos();
        smoothedPlayerEyePos = interpolateVec3d(smoothedPlayerEyePos, playerEyePos, positionEasingFactor);
        // Smooth rotation interpolation
        smoothedYaw = lerpAngle(smoothedYaw, player.getYaw(), rotationEasingFactor);
        smoothedPitch = lerpAngle(smoothedPitch, player.getPitch(), rotationEasingFactor);
        // Calculate desired distance based on whether we're resetting
        double desiredDistance = resetting ? 0 : targetDistance;
        currentDistance += (desiredDistance - currentDistance) * distanceEasingFactor;
        // Handle perspective changes
        if (currentDistance > firstPersonDistanceThreshold &&
                client.options.getPerspective() == Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.THIRD_PERSON_BACK);
        } else if (currentDistance < firstPersonDistanceThreshold &&
                client.options.getPerspective() != Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.FIRST_PERSON);
        }
        // Calculate camera position
        double yaw = Math.toRadians(smoothedYaw);
        double pitch = Math.toRadians(smoothedPitch);
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * currentDistance;
        double yOffset = Math.sin(pitch) * currentDistance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * currentDistance;
        Vec3d cameraPos = smoothedPlayerEyePos.add(xOffset, yOffset, zOffset);
        ((CameraAccessor)camera).invokesetPos(cameraPos);
        ((CameraAccessor)camera).invokeSetRotation((float) smoothedYaw, (float) smoothedPitch);
//        Craneshot.LOGGER.info("dist "+currentDistance);
        return resetting && currentDistance < 0.01;
    }
    @Override
    public void reset(MinecraftClient client, Camera camera) {
        resetting = true;
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? (1.0 / (1.0 + scrollSensitivity)) : (1.0 + scrollSensitivity);
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
    }
    @Override
    public String getName() {
        return "Linear";
    }
    private Vec3d interpolateVec3d(Vec3d current, Vec3d target, double factor) {
        double x = current.x + (target.x - current.x) * factor;
        double y = current.y + (target.y - current.y) * factor;
        double z = current.z + (target.z - current.z) * factor;
        return new Vec3d(x, y, z);
    }
    private double lerpAngle(double current, double target, double factor) {
        double diff = target - current;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return current + diff * factor;
    }
}
</file>

<file path="client/java/ninja/trek/config/AbstractMovementSettings.java">
package ninja.trek.config;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;
public abstract class AbstractMovementSettings {
    public AbstractMovementSettings() {
        loadSettings();
    }
    public Map<String, Object> getSettings() {
        Map<String, Object> settings = new HashMap<>();
        for (Field field : this.getClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(MovementSetting.class)) {
                field.setAccessible(true);
                try {
                    settings.put(field.getName(), field.get(this));
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
            }
        }
        return settings;
    }
    public void updateSetting(String key, Object value) {
        try {
            Field field = this.getClass().getDeclaredField(key);
            if (field.isAnnotationPresent(MovementSetting.class)) {
                field.setAccessible(true);
                field.set(this, value);
                saveSettings();
            }
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }
    private void saveSettings() {
        MovementConfigManager.updateMovementSettings(this.getClass().getSimpleName(), getSettings());
    }
    private void loadSettings() {
        Map<String, Object> savedSettings = MovementConfigManager.getSettingsForMovement(this.getClass().getSimpleName());
        for (Map.Entry<String, Object> entry : savedSettings.entrySet()) {
            updateSetting(entry.getKey(), entry.getValue());
        }
    }
}
</file>

<file path="client/java/ninja/trek/config/MenuOverlayScreen.java">
package ninja.trek.config;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.CheckboxWidget;
import net.minecraft.text.Text;
import ninja.trek.CraneshotClient;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.LinearMovement;
import java.lang.reflect.Field;
import java.util.*;
public class MenuOverlayScreen extends Screen {
    private static final Map<Integer, Set<Integer>> expandedMovements = new HashMap<>();
    private static final int MARGIN = 20;
    private static final int TAB_HEIGHT = 30;
    private static final int CONTENT_START_Y = TAB_HEIGHT - 10;
    private static final double SCROLL_SPEED = 10;
    private static boolean isMenuOpen = false;
    private int selectedTab = 0;
    private final List<SettingSlider> settingSliders = new ArrayList<>();
    private int scrollOffset = 0;
    private int maxScroll = 0;
    private int guiWidth;
    private int guiHeight;
    private int centerX;
    private int centerY;
    public MenuOverlayScreen() {
        super(Text.literal("CraneShot Settings"));
        isMenuOpen = true;
    }
    @Override
    protected void init() {
        this.guiWidth = this.width - (MARGIN * 2);
        this.guiHeight = this.height - (MARGIN * 2);
        this.centerX = MARGIN;
        this.centerY = MARGIN;
        int visibleStartY = centerY + CONTENT_START_Y;
        int visibleEndY = centerY + guiHeight;
        int height = 0;
        int tabCount = CraneshotClient.CAMERA_CONTROLLER.getMovementCount() + 1;
        int tabWidth = Math.min(100, (guiWidth - 20) / tabCount);
        // Tab buttons
        for (int i = 0; i <= CraneshotClient.CAMERA_CONTROLLER.getMovementCount(); i++) {
            int tabIndex = i;
            String tabName = (i == 0) ? "General" : "Slot " + i;
            ButtonWidget slotBtn = ButtonWidget.builder(Text.literal(tabName), button -> switchTab(tabIndex))
                    .dimensions(centerX + (i * (tabWidth + 5)), centerY, tabWidth, 20)
                    .build();
            height = slotBtn.getHeight();
            this.addDrawableChild(slotBtn);
        }
        int BUTTON_HEIGHT = height;
        int MOVEMENT_SPACING = BUTTON_HEIGHT - 5;
        int MOVEMENT_ROW_HEIGHT = BUTTON_HEIGHT + 5;
        int SETTING_HEIGHT = BUTTON_HEIGHT + 5;
        if (selectedTab > 0) {
            int slotIndex = selectedTab - 1;
            if (visibleStartY <= centerY + CONTENT_START_Y + BUTTON_HEIGHT) {
                this.addDrawableChild(ButtonWidget.builder(Text.literal("+"), button -> addMovement(slotIndex))
                        .dimensions(centerX + 10, centerY + CONTENT_START_Y, 20, BUTTON_HEIGHT)
                        .build());
                this.addDrawableChild(CheckboxWidget.builder(Text.literal("Wrap"), this.textRenderer)
                        .pos(centerX + 40, centerY + CONTENT_START_Y)
                        .checked(WrapSettings.getWrapState(slotIndex))
                        .callback((checkbox, checked) -> WrapSettings.setWrapState(slotIndex, checked))
                        .build());
            }
            List<ICameraMovement> movements = CraneshotClient.CAMERA_CONTROLLER.getAvailableMovementsForSlot(slotIndex);
            int yOffset = CONTENT_START_Y + BUTTON_HEIGHT + 10;
            for (int i = 0; i < movements.size(); i++) {
                int index = i;
                ICameraMovement movement = movements.get(i);
                int rowY = centerY + yOffset - scrollOffset;
                if (rowY >= visibleStartY - BUTTON_HEIGHT && rowY <= visibleEndY) {
                    // Control buttons now on the left
                    int controlX = centerX + 10;
                    if (i > 0) {
                        this.addDrawableChild(ButtonWidget.builder(Text.literal("↑"), button -> moveMovement(slotIndex, index, index - 1))
                                .dimensions(controlX, rowY, 20, BUTTON_HEIGHT)
                                .build());
                    }
                    controlX += 25;
                    if (i < movements.size() - 1) {
                        this.addDrawableChild(ButtonWidget.builder(Text.literal("↓"), button -> moveMovement(slotIndex, index, index + 1))
                                .dimensions(controlX, rowY, 20, BUTTON_HEIGHT)
                                .build());
                    }
                    controlX += 25;
                    if (movements.size() > 1) {
                        this.addDrawableChild(ButtonWidget.builder(Text.literal("×"), button -> deleteMovement(slotIndex, index))
                                .dimensions(controlX, rowY, 20, BUTTON_HEIGHT)
                                .build());
                    }
                    controlX += 25;
                    // Movement name button
                    int movementButtonWidth = Math.min(200, guiWidth / 3);
                    this.addDrawableChild(ButtonWidget.builder(
                                    Text.literal((isMovementExpanded(slotIndex, index) ? "▼ " : "▶ ") + movement.getName()),
                                    button -> {
                                        toggleMovementExpanded(slotIndex, index);
                                        reinitialize();
                                    })
                            .dimensions(controlX, rowY, movementButtonWidth, BUTTON_HEIGHT)
                            .build());
                }
                yOffset += MOVEMENT_ROW_HEIGHT;
                // Settings layout in multiple columns
                if (movement instanceof AbstractMovementSettings settings && isMovementExpanded(slotIndex, index)) {
                    List<Field> settingFields = new ArrayList<>();
                    for (Field field : settings.getClass().getDeclaredFields()) {
                        if (field.isAnnotationPresent(MovementSetting.class)) {
                            settingFields.add(field);
                        }
                    }
                    // Calculate number of columns and widths
                    int totalWidth = guiWidth - 40;  // Available width minus margins
                    int labelWidth = Math.min(150, totalWidth / 4);  // Original label width
                    int sliderWidth = Math.min(200, totalWidth / 2);  // Original slider width
                    int settingWidth = labelWidth + sliderWidth + 10;  // Total width for one setting
                    int columnsCount = Math.max(1, Math.min(3, (totalWidth + 20) / (settingWidth + 20)));
                    int settingsPerColumn = (int) Math.ceil(settingFields.size() / (double) columnsCount);
                    for (int fieldIndex = 0; fieldIndex < settingFields.size(); fieldIndex++) {
                        Field field = settingFields.get(fieldIndex);
                        MovementSetting annotation = field.getAnnotation(MovementSetting.class);
                        field.setAccessible(true);
                        try {
                            double value = ((Number) field.get(settings)).doubleValue();
                            // Calculate position in grid
                            int column = fieldIndex / settingsPerColumn;
                            int row = fieldIndex % settingsPerColumn;
                            int settingX = centerX + 20 + column * (settingWidth + 20);
                            int settingY = centerY + yOffset + (row * SETTING_HEIGHT) - scrollOffset;
                            if (settingY >= visibleStartY - BUTTON_HEIGHT && settingY <= visibleEndY) {
                                // Add setting label as a text-like button
                                ButtonWidget labelButton = ButtonWidget.builder(
                                                Text.literal(annotation.label()),
                                                button -> {}
                                        )
                                        .dimensions(settingX, settingY, labelWidth, BUTTON_HEIGHT)
                                        .build();
                                // Custom renderer for text-like appearance
                                this.addDrawableChild(labelButton);
                                // Add slider with original width
                                SettingSlider slider = new SettingSlider(
                                        settingX + labelWidth + 10,
                                        settingY,
                                        sliderWidth,
                                        BUTTON_HEIGHT,
                                        Text.literal(annotation.label()),
                                        annotation.min(),
                                        annotation.max(),
                                        value,
                                        field.getName(),
                                        settings
                                );
                                settingSliders.add(slider);
                                this.addDrawableChild(slider);
                            }
                        } catch (IllegalAccessException e) {
                            e.printStackTrace();
                        }
                    }
                    // Adjust yOffset based on the height of all settings
                    yOffset += (settingsPerColumn * SETTING_HEIGHT) + MOVEMENT_SPACING;
                } else {
                    yOffset += MOVEMENT_SPACING;
                }
            }
            int contentHeight = yOffset - (CONTENT_START_Y + BUTTON_HEIGHT + 10);
            int visibleHeight = guiHeight - CONTENT_START_Y - 10;
            maxScroll = Math.max(0, contentHeight - visibleHeight);
        } else if (selectedTab == 0) {
            addGeneralSettings();
        }
    }
    @Override
    public void resize(MinecraftClient client, int width, int height) {
        super.resize(client, width, height);
        this.scrollOffset = 0; // Reset scroll position on resize
        this.reinitialize();
    }
    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        // Draw semi-transparent background for entire screen
        context.fill(0, 0, this.width, this.height, 0x80000000);
        // Draw content area
        context.fill(
                centerX,
                centerY + CONTENT_START_Y,
                centerX + guiWidth,
                centerY + guiHeight,
                0xC0000000
        );
        // Render all widgets
        super.render(context, mouseX, mouseY, delta);
        // Draw scroll indicators if needed
        if (maxScroll > 0) {
            if (scrollOffset > 0) {
                context.drawCenteredTextWithShadow(
                        this.textRenderer,
                        Text.literal("▲"),
                        centerX + guiWidth - 15,
                        centerY + CONTENT_START_Y,
                        0xFFFFFF
                );
            }
            if (scrollOffset < maxScroll) {
                context.drawCenteredTextWithShadow(
                        this.textRenderer,
                        Text.literal("▼"),
                        centerX + guiWidth - 15,
                        centerY + guiHeight - 15,
                        0xFFFFFF
                );
            }
        }
    }
    private void addGeneralSettings() {
        int yOffset = CONTENT_START_Y + 20;
        int buttonWidth = 200;
        int buttonX = centerX + (guiWidth - buttonWidth) / 2;
        // Add Transition Mode selection
        this.addDrawableChild(ButtonWidget.builder(
                        Text.literal("Transition Mode: " + TransitionModeManager.getCurrentMode().getDisplayName()),
                        button -> {
                            // Cycle through transition modes
                            TransitionMode[] modes = TransitionMode.values();
                            int currentIndex = Arrays.asList(modes).indexOf(TransitionModeManager.getCurrentMode());
                            int nextIndex = (currentIndex + 1) % modes.length;
                            TransitionModeManager.setCurrentMode(modes[nextIndex]);
                            button.setMessage(Text.literal("Transition Mode: " + modes[nextIndex].getDisplayName()));
                        })
                .dimensions(buttonX, centerY + yOffset, buttonWidth, 20)
                .build());
    }
    // Keep existing helper methods
    private boolean isMovementExpanded(int slotIndex, int movementIndex) {
        return expandedMovements.computeIfAbsent(slotIndex, k -> new HashSet<>()).contains(movementIndex);
    }
    private void toggleMovementExpanded(int slotIndex, int movementIndex) {
        Set<Integer> expanded = expandedMovements.computeIfAbsent(slotIndex, k -> new HashSet<>());
        if (!expanded.remove(movementIndex)) {
            expanded.add(movementIndex);
        }
    }
    private void addMovement(int slotIndex) {
        CraneshotClient.CAMERA_CONTROLLER.addMovement(slotIndex, new LinearMovement());
        reinitialize();
    }
    private void deleteMovement(int slotIndex, int movementIndex) {
        CraneshotClient.CAMERA_CONTROLLER.removeMovement(slotIndex, movementIndex);
        reinitialize();
    }
    private void moveMovement(int slotIndex, int fromIndex, int toIndex) {
        CraneshotClient.CAMERA_CONTROLLER.swapMovements(slotIndex, fromIndex, toIndex);
        reinitialize();
    }
    private void reinitialize() {
        this.clearChildren();
        this.init();
    }
    @Override
    public boolean mouseScrolled(double mouseX, double mouseY, double horizontalAmount, double verticalAmount) {
        if (verticalAmount != 0) {
            scroll((int)(-verticalAmount * SCROLL_SPEED));
            return true;
        }
        return super.mouseScrolled(mouseX, mouseY, horizontalAmount, verticalAmount);
    }
    @Override
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        if (keyCode == CraneshotClient.toggleMenuKey.getDefaultKey().getCode()) toggleMenu();
        return true;
    }
    private void scroll(int amount) {
        if (maxScroll > 0) {
            scrollOffset = Math.max(0, Math.min(scrollOffset + amount, maxScroll));
            clearChildren();
            init();
        }
    }
    private void switchTab(int index) {
        selectedTab = index;
        scrollOffset = 0;
        clearChildren();
        init();
    }
    public static void toggleMenu() {
        MinecraftClient client = MinecraftClient.getInstance();
        if (isMenuOpen) {
            client.setScreen(null);
            isMenuOpen = false;
        } else {
            client.setScreen(new MenuOverlayScreen());
            isMenuOpen = true;
        }
    }
    @Override
    public boolean shouldPause() {
        return false;
    }
}
</file>

<file path="client/java/ninja/trek/config/MovementConfigManager.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import net.minecraft.client.MinecraftClient;
import ninja.trek.cameramovements.ICameraMovement;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
public class MovementConfigManager {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_movements.json");
    private static Map<String, Map<String, Object>> movementSettings = new HashMap<>();
    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) return;
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            Type type = new TypeToken<Map<String, Map<String, Object>>>() {}.getType();
            movementSettings = GSON.fromJson(reader, type);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static void saveSettings() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(movementSettings, writer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static Map<String, Object> getSettingsForMovement(String movementName) {
        return movementSettings.getOrDefault(movementName, new HashMap<>());
    }
    public static void updateMovementSettings(String movementName, Map<String, Object> settings) {
        movementSettings.put(movementName, settings);
        saveSettings();
    }
}
</file>

<file path="client/java/ninja/trek/config/MovementSetting.java">
package ninja.trek.config;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface MovementSetting {
    String label();
    double min() default 0;
    double max() default 100;
}
</file>

<file path="client/java/ninja/trek/config/SettingSlider.java">
package ninja.trek.config;
import net.minecraft.client.gui.widget.SliderWidget;
import net.minecraft.text.Text;
public class SettingSlider extends SliderWidget {
    private final double min;
    private final double max;
    private final String fieldName;
    private final AbstractMovementSettings settings;
    private final Text label;
    public SettingSlider(int x, int y, int width, int height, Text label,
                         double min, double max, double value,
                         String fieldName, AbstractMovementSettings settings) {
        super(x, y, width, height, label, (value - min) / (max - min));
        this.min = min;
        this.max = max;
        this.fieldName = fieldName;
        this.settings = settings;
        this.label = label;
        updateMessage();
    }
    @Override
    protected void updateMessage() {
        setMessage(Text.literal(String.format("%.2f", getValue())));
    }
    @Override
    protected void applyValue() {
        double value = min + (max - min) * this.value;
        settings.updateSetting(fieldName, value);
    }
    public Text getLabel() {
        return label;
    }
    private double getValue() {
        return min + (max - min) * this.value;
    }
}
</file>

<file path="client/java/ninja/trek/config/TransitionMode.java">
// TransitionMode.java
package ninja.trek.config;
import net.minecraft.client.MinecraftClient;
import java.io.FileReader;
import java.io.FileWriter;
public enum TransitionMode {
    IMMEDIATE("Immediate Switch"),
    INTERPOLATE("Interpolate (Coming Soon)"),
    QUEUE("Queue");
    private final String displayName;
    TransitionMode(String displayName) {
        this.displayName = displayName;
    }
    public String getDisplayName() {
        return displayName;
    }
}
</file>

<file path="client/java/ninja/trek/config/TransitionModeManager.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.client.MinecraftClient;
import java.io.*;
public class TransitionModeManager {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_transition.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static TransitionMode currentMode = TransitionMode.IMMEDIATE;
    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) return;
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            String modeName = GSON.fromJson(reader, String.class);
            currentMode = TransitionMode.valueOf(modeName);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static void saveSettings() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(currentMode.name(), writer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static TransitionMode getCurrentMode() {
        return currentMode;
    }
    public static void setCurrentMode(TransitionMode mode) {
        currentMode = mode;
        saveSettings();
    }
}
</file>

<file path="client/java/ninja/trek/config/WrapSettings.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.client.MinecraftClient;
import java.io.*;
import java.util.HashMap;
import java.util.Map;
public class WrapSettings {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_wrap.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static Map<Integer, Boolean> wrapStates = new HashMap<>();
    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) return;
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            wrapStates = GSON.fromJson(reader, Map.class);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static void saveSettings() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(wrapStates, writer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static boolean getWrapState(int slotIndex) {
        return wrapStates.getOrDefault(slotIndex, false);
    }
    public static void setWrapState(int slotIndex, boolean state) {
        wrapStates.put(slotIndex, state);
        saveSettings();
    }
}
</file>

<file path="client/java/ninja/trek/CraneshotClient.java">
package ninja.trek;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.client.util.InputUtil;
import ninja.trek.config.MenuOverlayScreen;
import org.lwjgl.glfw.GLFW;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
public class CraneshotClient implements ClientModInitializer {
	public static KeyBinding[] cameraKeyBinds;
	public static KeyBinding selectMovementType;
	public static final CameraController CAMERA_CONTROLLER = new CameraController();
	public static KeyBinding toggleMenuKey;
	private static boolean isMenuOpen = false;
	@Override
	public void onInitializeClient() {
		toggleMenuKey = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.toggle_menu",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_Z,
				"category.craneshot.ui"
		));
		selectMovementType = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.select_movement",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_X,
				"category.craneshot.camera"
		));
		cameraKeyBinds = new KeyBinding[]{
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera1",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_C,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera2",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_V,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera3",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_B,
						"category.craneshot.camera"
				))
		};
		CraneShotEventHandler.register();
	}
	public static void checkKeybinds() {
		if (toggleMenuKey.wasPressed()) {
			MenuOverlayScreen.toggleMenu();
		}
	}
}
</file>

<file path="client/java/ninja/trek/CraneshotDataGenerator.java">
package ninja.trek;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class CraneshotDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/java/ninja/trek/CraneShotEventHandler.java">
package ninja.trek;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;
import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.text.Text;
import ninja.trek.mixin.client.MouseAccessor;
public class CraneShotEventHandler {
    private static boolean[] wasPressed = new boolean[3];
    private static double lastScrollTime = 0;
    private static final double SCROLL_COOLDOWN = 0.1;
    private static String currentMessage = "";
    private static long messageTimer = 0;
    private static final long MESSAGE_DURATION = 2000;
    private static boolean showToast;
    public static void register() {
        ClientTickEvents.END_CLIENT_TICK.register(client -> {
            handleScrollInput(client);
            updateMessageTimer();
            CraneshotClient.checkKeybinds();
        });
        HudRenderCallback.EVENT.register((context, tickDelta) -> {
            if (!currentMessage.isEmpty() && System.currentTimeMillis() < messageTimer) {
                MinecraftClient client = MinecraftClient.getInstance();
                if (client.player != null) {
                    int width = client.getWindow().getScaledWidth();
                    context.drawTextWithShadow(client.textRenderer, Text.literal(currentMessage),
                            width / 2 - client.textRenderer.getWidth(currentMessage) / 2,
                            60, 0xFFFFFF);
                }
            }
        });
        WorldRenderEvents.START.register((context) -> {
            MinecraftClient client = MinecraftClient.getInstance();
            Camera camera = client.gameRenderer.getCamera();
            boolean anyPressed = false;
            for (int i = 0; i < 3; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    if (!wasPressed[i]) {
                        CraneshotClient.CAMERA_CONTROLLER.startTransition(client, camera, i);
                    }
                    wasPressed[i] = true;
                    anyPressed = true;
                } else {
                    wasPressed[i] = false;
                }
            }
            if (!anyPressed) {
                CraneshotClient.CAMERA_CONTROLLER.queueFinish(client, camera);
            }
            if (client.player != null) {
                CraneshotClient.CAMERA_CONTROLLER.tick(client, camera);
            }
        });
    }
    private static void handleScrollInput(MinecraftClient client) {
        double currentTime = System.currentTimeMillis() / 1000.0;
        if (currentTime - lastScrollTime < SCROLL_COOLDOWN) return;
        double scrollDelta = ((MouseAccessor)client.mouse).getEventDeltaVerticalWheel();
        if (scrollDelta == 0) return;
        boolean scrollUp = scrollDelta > 0;
        if (CraneshotClient.selectMovementType.isPressed()) {
            CraneshotClient.CAMERA_CONTROLLER.cycleMovementType(scrollUp);
            String movementType = CraneshotClient.CAMERA_CONTROLLER.getCurrentMovement().getName();
            currentMessage = String.format("Camera %d: %s Movement", CraneshotClient.CAMERA_CONTROLLER.getCurrentMovementIndex() + 1, movementType);
            showMovementTypeMessage(currentMessage);
            lastScrollTime = currentTime;
            ((MouseAccessor)client.mouse).setEventDeltaVerticalWheel(0);
        } else {
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    CraneshotClient.CAMERA_CONTROLLER.adjustDistance(i, scrollUp);
                    lastScrollTime = currentTime;
                    ((MouseAccessor)client.mouse).setEventDeltaVerticalWheel(0);
                    break;
                }
            }
        }
    }
    private static void showMovementTypeMessage(String message) {
        showToast = true;
        messageTimer = System.currentTimeMillis() + MESSAGE_DURATION;
    }
    private static void updateMessageTimer() {
        if (System.currentTimeMillis() >= messageTimer) {
            showToast = false;
        }
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/CameraAccessor.java">
package ninja.trek.mixin.client;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import org.spongepowered.asm.mixin.gen.Invoker;
@Mixin(Camera.class)
public interface CameraAccessor {
    @Accessor("pos")
    void invokesetPos(Vec3d pos);
    @Accessor("pos")
    Vec3d getPos();
    @Invoker("setRotation")
    void invokeSetRotation(float yaw, float pitch);
}
</file>

<file path="client/java/ninja/trek/mixin/client/ExampleClientMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseAccessor.java">
package ninja.trek.mixin.client;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import net.minecraft.client.Mouse;
@Mixin(Mouse.class)
public interface MouseAccessor {
    @Accessor("eventDeltaVerticalWheel")
    double getEventDeltaVerticalWheel();
    @Accessor("eventDeltaVerticalWheel")
    void setEventDeltaVerticalWheel(double value);
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.Mouse;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import ninja.trek.CraneshotClient;
@Mixin(Mouse.class)
public class MouseMixin {
    @Shadow private double eventDeltaVerticalWheel;
    @Inject(method = "onMouseScroll", at = @At("HEAD"), cancellable = true)
    private void onScroll(long window, double horizontal, double vertical, CallbackInfo ci) {
        if (CraneshotClient.selectMovementType.isPressed() ||
                CraneshotClient.cameraKeyBinds[0].isPressed() ||
                CraneshotClient.cameraKeyBinds[1].isPressed() ||
                CraneshotClient.cameraKeyBinds[2].isPressed()) {
            eventDeltaVerticalWheel = vertical;
            ci.cancel();
        }
    }
}
</file>

<file path="client/resources/craneshot.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"MouseMixin",
		"CameraAccessor",
		"MouseAccessor"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/Craneshot.java">
package ninja.trek;
import net.fabricmc.api.ModInitializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Craneshot implements ModInitializer {
	public static final String MOD_ID = "craneshot";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	@Override
	public void onInitialize() {
		LOGGER.info("CraneShot Camera Mod initialized!");
	}
}
</file>

<file path="main/java/ninja/trek/mixin/ExampleMixin.java">
package ninja.trek.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/resources/craneshot.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "craneshot",
	"version": "${version}",
	"name": "craneshot",
	"description": "Advanced camera controls mod for cinematics",
	"authors": ["Me!"],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/craneshot/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": ["ninja.trek.Craneshot"],
		"client": ["ninja.trek.CraneshotClient"],
		
		"fabric-datagen": ["ninja.trek.CraneshotDataGenerator"]
	},
	"mixins": [
		"craneshot.mixins.json",
		{
			"config": "craneshot.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*",
		"fabric-key-binding-api-v1": "*"
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
