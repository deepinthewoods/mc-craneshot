This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-04T11:55:02.642Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/CameraController.java
client/java/ninja/trek/cameramovements/ICameraMovement.java
client/java/ninja/trek/cameramovements/LinearMovement.java
client/java/ninja/trek/config/ConfigField.java
client/java/ninja/trek/config/MovementConfigManager.java
client/java/ninja/trek/CraneshotClient.java
client/java/ninja/trek/CraneShotConfigMenu.java
client/java/ninja/trek/CraneshotDataGenerator.java
client/java/ninja/trek/CraneShotEventHandler.java
client/java/ninja/trek/mixin/client/CameraAccessor.java
client/java/ninja/trek/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/mixin/client/MouseAccessor.java
client/java/ninja/trek/mixin/client/MouseMixin.java
client/resources/craneshot.client.mixins.json
main/java/ninja/trek/Craneshot.java
main/java/ninja/trek/CraneShotConfig.java
main/java/ninja/trek/mixin/ExampleMixin.java
main/resources/craneshot.mixins.json
main/resources/fabric.mod.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/CameraController.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import ninja.trek.cameramovements.*;
import ninja.trek.config.MovementConfigManager;
public class CameraController {
    private final ICameraMovement[][] movements;
    private int currentMovement = -1;
    private final int[] currentTypes;
    public CameraController() {
        movements = new ICameraMovement[][] {
                {new LinearMovement()},
                {new LinearMovement()},
                {new LinearMovement()}
        };
        currentTypes = new int[] {0, 0, 0};
        // Load saved configurations
        for (int i = 0; i < movements.length; i++) {
            for (ICameraMovement movement : movements[i]) {
                MovementConfigManager.getInstance().loadMovementConfig(movement, i);
            }
        }
    }
    // Config access methods
    public int getMovementCount() {
        return movements.length;
    }
    public ICameraMovement getMovementAt(int index) {
        if (index >= 0 && index < movements.length) {
            return movements[index][currentTypes[index]];
        }
        return null;
    }
    public int getCurrentTypeForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < currentTypes.length) {
            return currentTypes[slotIndex];
        }
        return 0;
    }
    public ICameraMovement[] getAvailableMovementsForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < movements.length) {
            return movements[slotIndex];
        }
        return new ICameraMovement[0];
    }
    // Existing methods remain unchanged
    public void startTransition(MinecraftClient client, Camera camera, int movementIndex) {
        if (currentMovement != -1) {
            movements[currentMovement][currentTypes[currentMovement]].reset(client, camera);
        }
        currentMovement = movementIndex;
        movements[movementIndex][currentTypes[movementIndex]].start(client, camera);
    }
    public void updateTransition(MinecraftClient client, Camera camera) {
        if (currentMovement != -1) {
            ICameraMovement movement = movements[currentMovement][currentTypes[currentMovement]];
            if (movement.update(client, camera))
                currentMovement = -1;
        }
    }
    public void reset(MinecraftClient client, Camera camera) {
        if (currentMovement != -1) {
            movements[currentMovement][currentTypes[currentMovement]].reset(client, camera);
        }
    }
    public void cycleMovementType(boolean forward) {
        if (currentMovement != -1) {
            int currentType = currentTypes[currentMovement];
            currentTypes[currentMovement] = forward ?
                    (currentType + 1) % movements[currentMovement].length :
                    (currentType - 1 + movements[currentMovement].length) % movements[currentMovement].length;
        }
    }
    public ICameraMovement getCurrentMovement() {
        if (currentMovement >= 0) {
            return movements[currentMovement][currentTypes[currentMovement]];
        }
        return null;
    }
    public void adjustDistance(int index, boolean increase) {
        if (index >= 0 && index < movements.length) {
            movements[index][currentTypes[index]].adjustDistance(increase);
        }
    }
    public int getCurrentMovementIndex() {
        return currentMovement;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/ICameraMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
public interface ICameraMovement {
    void start(MinecraftClient client, Camera camera);
    boolean update(MinecraftClient client, Camera camera);
    void reset(MinecraftClient client, Camera camera);
    void adjustDistance(boolean increase);
    String getName();
}
</file>

<file path="client/java/ninja/trek/cameramovements/LinearMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.client.option.Perspective;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.config.ConfigField;
import ninja.trek.mixin.client.CameraAccessor;
public class LinearMovement implements ICameraMovement {
    @ConfigField(
            name = "Position Easing",
            description = "How smoothly the camera follows position changes",
            min = 0.01,
            max = 1.0,
            sliderControl = true
    )
    private float positionEasingFactor = 0.1f;
    @ConfigField(
            name = "Rotation Easing",
            description = "How smoothly the camera follows rotation changes",
            min = 0.01,
            max = 1.0,
            sliderControl = true
    )
    private float rotationEasingFactor = 0.1f;
    @ConfigField(
            name = "Distance Easing",
            description = "How smoothly the camera transitions between distances",
            min = 0.01,
            max = 1.0,
            sliderControl = true
    )
    private float distanceEasingFactor = 0.1f;
    @ConfigField(
            name = "Scroll Sensitivity",
            description = "How quickly the distance changes when scrolling",
            min = 0.1,
            max = 2.0,
            sliderControl = true
    )
    private double scrollSensitivity = 0.5;
    @ConfigField(
            name = "Minimum Distance",
            description = "Closest the camera can get to the player",
            min = 0.5,
            max = 10.0
    )
    private double minDistance = 2.0;
    @ConfigField(
            name = "Maximum Distance",
            description = "Furthest the camera can get from the player",
            min = 5.0,
            max = 50.0
    )
    private double maxDistance = 20.0;
    @ConfigField(
            name = "First Person Threshold",
            description = "Distance at which camera switches to first person",
            min = 0.5,
            max = 5.0
    )
    private double firstPersonDistanceThreshold = 1.5;
    private double targetDistance = 10;
    private double currentDistance = 0;
    private Vec3d smoothedPlayerEyePos = new Vec3d(0, 0, 0);
    private double smoothedYaw = 0;
    private double smoothedPitch = 0;
    private boolean resetting = false;
    private boolean wasFirstPerson = true;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return;
        smoothedPlayerEyePos = player.getEyePos();
        smoothedYaw = player.getYaw();
        smoothedPitch = player.getPitch();
        currentDistance = 0;
        resetting = false;
        wasFirstPerson = client.options.getPerspective() == Perspective.FIRST_PERSON;
    }
    @Override
    public boolean update(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return true;
        // Smooth eye position interpolation
        Vec3d playerEyePos = player.getEyePos();
        smoothedPlayerEyePos = interpolateVec3d(smoothedPlayerEyePos, playerEyePos, positionEasingFactor);
        // Smooth rotation interpolation
        smoothedYaw = lerpAngle(smoothedYaw, player.getYaw(), rotationEasingFactor);
        smoothedPitch = lerpAngle(smoothedPitch, player.getPitch(), rotationEasingFactor);
        // Calculate desired distance based on whether we're resetting
        double desiredDistance = resetting ? 0 : targetDistance;
        currentDistance += (desiredDistance - currentDistance) * distanceEasingFactor;
        // Handle perspective changes
        if (currentDistance > firstPersonDistanceThreshold &&
                client.options.getPerspective() == Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.THIRD_PERSON_BACK);
        } else if (currentDistance < firstPersonDistanceThreshold &&
                client.options.getPerspective() != Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.FIRST_PERSON);
        }
        // Calculate camera position
        double yaw = Math.toRadians(smoothedYaw);
        double pitch = Math.toRadians(smoothedPitch);
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * currentDistance;
        double yOffset = Math.sin(pitch) * currentDistance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * currentDistance;
        Vec3d cameraPos = smoothedPlayerEyePos.add(xOffset, yOffset, zOffset);
        ((CameraAccessor)camera).invokesetPos(cameraPos);
        ((CameraAccessor)camera).invokeSetRotation((float)smoothedYaw, (float)smoothedPitch);
        return resetting && currentDistance < 0.01;
    }
    @Override
    public void reset(MinecraftClient client, Camera camera) {
        resetting = true;
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? (1.0 / (1.0 + scrollSensitivity)) : (1.0 + scrollSensitivity);
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
    }
    @Override
    public String getName() {
        return "Linear";
    }
    private Vec3d interpolateVec3d(Vec3d current, Vec3d target, float factor) {
        double x = current.x + (target.x - current.x) * factor;
        double y = current.y + (target.y - current.y) * factor;
        double z = current.z + (target.z - current.z) * factor;
        return new Vec3d(x, y, z);
    }
    private double lerpAngle(double current, double target, float factor) {
        double diff = target - current;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return current + diff * factor;
    }
}
</file>

<file path="client/java/ninja/trek/config/ConfigField.java">
package ninja.trek.config;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface ConfigField {
    String name() default "";  // Display name in config UI
    String description() default ""; // Optional description/tooltip
    double min() default Double.NEGATIVE_INFINITY;  // Min value for numbers
    double max() default Double.POSITIVE_INFINITY;  // Max value for numbers
    boolean sliderControl() default false;  // Use slider instead of text input for numbers
    // Special value to indicate this field should not be configurable at runtime
    boolean readonly() default false;
}
</file>

<file path="client/java/ninja/trek/config/MovementConfigManager.java">
package ninja.trek.config;
import com.google.gson.*;
import net.fabricmc.loader.api.FabricLoader;
import ninja.trek.Craneshot;
import ninja.trek.cameramovements.ICameraMovement;
import java.lang.reflect.Field;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
public class MovementConfigManager {
    private static final Path CONFIG_DIR = FabricLoader.getInstance().getConfigDir().resolve("craneshot");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static MovementConfigManager INSTANCE;
    private final Map<String, JsonObject> savedConfigs = new HashMap<>();
    public static MovementConfigManager getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new MovementConfigManager();
            INSTANCE.load();
        }
        return INSTANCE;
    }
    private MovementConfigManager() {
        try {
            Files.createDirectories(CONFIG_DIR);
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to create config directory", e);
        }
    }
    public void saveMovementConfig(ICameraMovement movement, int slot) {
        try {
            JsonObject config = new JsonObject();
            Class<?> clazz = movement.getClass();
            // Save class type for loading
            config.addProperty("_type", clazz.getName());
            // Save all annotated fields
            for (Field field : clazz.getDeclaredFields()) {
                ConfigField annotation = field.getAnnotation(ConfigField.class);
                if (annotation == null || annotation.readonly()) continue;
                field.setAccessible(true);
                JsonElement value = null;
                if (field.getType() == double.class || field.getType() == Double.class) {
                    value = new JsonPrimitive(field.getDouble(movement));
                } else if (field.getType() == float.class || field.getType() == Float.class) {
                    value = new JsonPrimitive(field.getFloat(movement));
                } else if (field.getType() == boolean.class || field.getType() == Boolean.class) {
                    value = new JsonPrimitive(field.getBoolean(movement));
                } else if (field.getType() == int.class || field.getType() == Integer.class) {
                    value = new JsonPrimitive(field.getInt(movement));
                } else if (field.getType() == String.class) {
                    value = new JsonPrimitive((String)field.get(movement));
                }
                if (value != null) {
                    config.add(field.getName(), value);
                }
            }
            savedConfigs.put(getConfigKey(movement, slot), config);
            save();
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to save movement config for slot " + slot, e);
        }
    }
    public void loadMovementConfig(ICameraMovement movement, int slot) {
        try {
            JsonObject config = savedConfigs.get(getConfigKey(movement, slot));
            if (config == null) return;
            Class<?> clazz = movement.getClass();
            for (Field field : clazz.getDeclaredFields()) {
                ConfigField annotation = field.getAnnotation(ConfigField.class);
                if (annotation == null || annotation.readonly()) continue;
                JsonElement element = config.get(field.getName());
                if (element == null) continue;
                field.setAccessible(true);
                if (field.getType() == double.class || field.getType() == Double.class) {
                    field.setDouble(movement, element.getAsDouble());
                } else if (field.getType() == float.class || field.getType() == Float.class) {
                    field.setFloat(movement, element.getAsFloat());
                } else if (field.getType() == boolean.class || field.getType() == Boolean.class) {
                    field.setBoolean(movement, element.getAsBoolean());
                } else if (field.getType() == int.class || field.getType() == Integer.class) {
                    field.setInt(movement, element.getAsInt());
                } else if (field.getType() == String.class) {
                    field.set(movement, element.getAsString());
                }
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to load movement config for slot " + slot, e);
        }
    }
    private void save() {
        try {
            Path configFile = CONFIG_DIR.resolve("movement_configs.json");
            Files.writeString(configFile, GSON.toJson(savedConfigs));
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to save movement configs", e);
        }
    }
    private void load() {
        try {
            Path configFile = CONFIG_DIR.resolve("movement_configs.json");
            if (Files.exists(configFile)) {
                String json = Files.readString(configFile);
                JsonObject configs = GSON.fromJson(json, JsonObject.class);
                configs.entrySet().forEach(entry ->
                        savedConfigs.put(entry.getKey(), entry.getValue().getAsJsonObject()));
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to load movement configs", e);
        }
    }
    private String getConfigKey(ICameraMovement movement, int slot) {
        return movement.getClass().getName() + "#" + slot;
    }
}
</file>

<file path="client/java/ninja/trek/CraneshotClient.java">
package ninja.trek;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.client.util.InputUtil;
import org.lwjgl.glfw.GLFW;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
public class CraneshotClient implements ClientModInitializer {
	public static KeyBinding[] cameraKeyBinds;
	public static KeyBinding selectMovementType;
	public static final CameraController CAMERA_CONTROLLER = new CameraController();
	@Override
	public void onInitializeClient() {
		selectMovementType = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.select_movement",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_X,
				"category.craneshot.camera"
		));
		cameraKeyBinds = new KeyBinding[]{
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera1",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_C,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera2",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_V,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera3",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_B,
						"category.craneshot.camera"
				))
		};
		CraneShotEventHandler.register();
	}
}
</file>

<file path="client/java/ninja/trek/CraneShotConfigMenu.java">
package ninja.trek;
import com.terraformersmc.modmenu.api.ConfigScreenFactory;
import com.terraformersmc.modmenu.api.ModMenuApi;
import me.shedaniel.clothconfig2.api.ConfigBuilder;
import me.shedaniel.clothconfig2.api.ConfigCategory;
import me.shedaniel.clothconfig2.api.ConfigEntryBuilder;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.text.Text;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.config.ConfigField;
import ninja.trek.config.MovementConfigManager;
import java.lang.reflect.Field;
import java.util.Arrays;
public class CraneShotConfigMenu implements ModMenuApi {
    @Override
    public ConfigScreenFactory<?> getModConfigScreenFactory() {
        return parent -> {
            ConfigBuilder builder = ConfigBuilder.create()
                    .setParentScreen(parent)
                    .setTitle(Text.translatable("config.craneshot.title"));
            // Add global settings tab
            ConfigCategory globalCategory = builder.getOrCreateCategory(
                    Text.translatable("config.craneshot.category.global"));
            addGlobalSettings(globalCategory, builder.entryBuilder());
            // Add tabs for each camera slot
            CameraController controller = CraneshotClient.CAMERA_CONTROLLER;
            for (int i = 0; i < controller.getMovementCount(); i++) {
                ICameraMovement movement = controller.getMovementAt(i);
                if (movement != null) {
                    ConfigCategory slotCategory = builder.getOrCreateCategory(
                            Text.translatable("config.craneshot.category.slot", i + 1));
                    addMovementSettings(slotCategory, builder.entryBuilder(), movement, i);
                }
            }
            return builder.build();
        };
    }
    private void addGlobalSettings(ConfigCategory category, ConfigEntryBuilder entryBuilder) {
        // Add any global settings from CraneShotConfig
        CraneShotConfig config = CraneShotConfig.get();
        category.addEntry(entryBuilder.startBooleanToggle(
                        Text.translatable("config.craneshot.option.example_toggle"),
                        config.exampleToggle)
                .setDefaultValue(true)
                .setSaveConsumer(newValue -> {
                    config.exampleToggle = newValue;
                    CraneShotConfig.save();
                })
                .build());
    }
    private void addMovementSettings(ConfigCategory category, ConfigEntryBuilder entryBuilder,
                                     ICameraMovement movement, int slot) {
        // Use reflection to find all fields with @ConfigField annotation
        for (Field field : movement.getClass().getDeclaredFields()) {
            ConfigField annotation = field.getAnnotation(ConfigField.class);
            if (annotation == null) continue;
            field.setAccessible(true);
            String translationKey = "config.craneshot.movement." + field.getName().toLowerCase();
            try {
                if (field.getType() == double.class || field.getType() == Double.class) {
                    addDoubleField(category, entryBuilder, movement, field, annotation, translationKey);
                } else if (field.getType() == float.class || field.getType() == Float.class) {
                    addFloatField(category, entryBuilder, movement, field, annotation, translationKey);
                } else if (field.getType() == boolean.class || field.getType() == Boolean.class) {
                    addBooleanField(category, entryBuilder, movement, field, annotation, translationKey);
                }
                // Add other types as needed
            } catch (Exception e) {
                Craneshot.LOGGER.error("Failed to add config field: " + field.getName(), e);
            }
        }
    }
    private void addDoubleField(ConfigCategory category, ConfigEntryBuilder entryBuilder,
                                ICameraMovement movement, Field field, ConfigField annotation,
                                String translationKey) throws IllegalAccessException {
        double currentValue = field.getDouble(movement);
        var entry = annotation.sliderControl()
                ? entryBuilder.startDoubleSlider(
                Text.translatable(translationKey),
                currentValue,
                annotation.min(),
                annotation.max())
                : entryBuilder.startDoubleField(
                Text.translatable(translationKey),
                currentValue);
        if (!annotation.description().isEmpty()) {
            entry.setTooltip(Text.translatable(translationKey + ".tooltip"));
        }
        entry.setDefaultValue(currentValue)
                .setSaveConsumer(newValue -> {
                    try {
                        field.setDouble(movement, newValue);
                        MovementConfigManager.getInstance().saveMovementConfig(movement, slot);
                    } catch (IllegalAccessException e) {
                        Craneshot.LOGGER.error("Failed to save config value", e);
                    }
                });
        category.addEntry(entry.build());
    }
    private void addFloatField(ConfigCategory category, ConfigEntryBuilder entryBuilder,
                               ICameraMovement movement, Field field, ConfigField annotation,
                               String translationKey) throws IllegalAccessException {
        float currentValue = field.getFloat(movement);
        var entry = annotation.sliderControl()
                ? entryBuilder.startFloatSlider(
                Text.translatable(translationKey),
                currentValue,
                (float)annotation.min(),
                (float)annotation.max())
                : entryBuilder.startFloatField(
                Text.translatable(translationKey),
                currentValue);
        if (!annotation.description().isEmpty()) {
            entry.setTooltip(Text.translatable(translationKey + ".tooltip"));
        }
        entry.setDefaultValue(currentValue)
                .setSaveConsumer(newValue -> {
                    try {
                        field.setFloat(movement, newValue);
                        MovementConfigManager.getInstance().saveMovementConfig(movement, slot);
                    } catch (IllegalAccessException e) {
                        Craneshot.LOGGER.error("Failed to save config value", e);
                    }
                });
        category.addEntry(entry.build());
    }
    private void addBooleanField(ConfigCategory category, ConfigEntryBuilder entryBuilder,
                                 ICameraMovement movement, Field field, ConfigField annotation,
                                 String translationKey) throws IllegalAccessException {
        boolean currentValue = field.getBoolean(movement);
        var entry = entryBuilder.startBooleanToggle(
                Text.translatable(translationKey),
                currentValue);
        if (!annotation.description().isEmpty()) {
            entry.setTooltip(Text.translatable(translationKey + ".tooltip"));
        }
        entry.setDefaultValue(currentValue)
                .setSaveConsumer(newValue -> {
                    try {
                        field.setBoolean(movement, newValue);
                        MovementConfigManager.getInstance().saveMovementConfig(movement, slot);
                    } catch (IllegalAccessException e) {
                        Craneshot.LOGGER.error("Failed to save config value", e);
                    }
                });
        category.addEntry(entry.build());
    }
}
</file>

<file path="client/java/ninja/trek/CraneshotDataGenerator.java">
package ninja.trek;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class CraneshotDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/java/ninja/trek/CraneShotEventHandler.java">
package ninja.trek;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;
import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.text.Text;
import ninja.trek.mixin.client.MouseAccessor;
public class CraneShotEventHandler {
    private static boolean[] wasPressed = new boolean[3];
    private static double lastScrollTime = 0;
    private static final double SCROLL_COOLDOWN = 0.1;
    private static String currentMessage = "";
    private static long messageTimer = 0;
    private static final long MESSAGE_DURATION = 2000;
    private static boolean showToast;
    public static void register() {
        ClientTickEvents.END_CLIENT_TICK.register(client -> {
            handleScrollInput(client);
            updateMessageTimer();
        });
        HudRenderCallback.EVENT.register((context, tickDelta) -> {
            if (!currentMessage.isEmpty() && System.currentTimeMillis() < messageTimer) {
                MinecraftClient client = MinecraftClient.getInstance();
                if (client.player != null) {
                    int width = client.getWindow().getScaledWidth();
                    context.drawTextWithShadow(client.textRenderer, Text.literal(currentMessage),
                            width / 2 - client.textRenderer.getWidth(currentMessage) / 2,
                            60, 0xFFFFFF);
                }
            }
        });
        WorldRenderEvents.START.register((context) -> {
            MinecraftClient client = MinecraftClient.getInstance();
            Camera camera = client.gameRenderer.getCamera();
            boolean anyPressed = false;
            for (int i = 0; i < 3; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    if (!wasPressed[i]) {
                        CraneshotClient.CAMERA_CONTROLLER.startTransition(client, camera, i);
                    }
                    wasPressed[i] = true;
                    anyPressed = true;
                } else {
                    wasPressed[i] = false;
                }
            }
            if (!anyPressed) {
                CraneshotClient.CAMERA_CONTROLLER.reset(client, camera);
            }
            if (client.player != null) {
                CraneshotClient.CAMERA_CONTROLLER.updateTransition(client, camera);
            }
        });
    }
    private static void handleScrollInput(MinecraftClient client) {
        double currentTime = System.currentTimeMillis() / 1000.0;
        if (currentTime - lastScrollTime < SCROLL_COOLDOWN) return;
        double scrollDelta = ((MouseAccessor)client.mouse).getEventDeltaVerticalWheel();
        if (scrollDelta == 0) return;
        boolean scrollUp = scrollDelta > 0;
        if (CraneshotClient.selectMovementType.isPressed()) {
            CraneshotClient.CAMERA_CONTROLLER.cycleMovementType(scrollUp);
            String movementType = CraneshotClient.CAMERA_CONTROLLER.getCurrentMovement().getName();
            currentMessage = String.format("Camera %d: %s Movement", CraneshotClient.CAMERA_CONTROLLER.getCurrentMovementIndex() + 1, movementType);
            showMovementTypeMessage(currentMessage);
            lastScrollTime = currentTime;
            ((MouseAccessor)client.mouse).setEventDeltaVerticalWheel(0);
        } else {
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    CraneshotClient.CAMERA_CONTROLLER.adjustDistance(i, scrollUp);
                    lastScrollTime = currentTime;
                    ((MouseAccessor)client.mouse).setEventDeltaVerticalWheel(0);
                    break;
                }
            }
        }
    }
    private static void showMovementTypeMessage(String message) {
        showToast = true;
        messageTimer = System.currentTimeMillis() + MESSAGE_DURATION;
    }
    private static void updateMessageTimer() {
        if (System.currentTimeMillis() >= messageTimer) {
            showToast = false;
        }
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/CameraAccessor.java">
package ninja.trek.mixin.client;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import org.spongepowered.asm.mixin.gen.Invoker;
@Mixin(Camera.class)
public interface CameraAccessor {
    @Accessor("pos")
    void invokesetPos(Vec3d pos);
    @Accessor("pos")
    Vec3d getPos();
    @Invoker("setRotation")
    void invokeSetRotation(float yaw, float pitch);
}
</file>

<file path="client/java/ninja/trek/mixin/client/ExampleClientMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseAccessor.java">
package ninja.trek.mixin.client;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import net.minecraft.client.Mouse;
@Mixin(Mouse.class)
public interface MouseAccessor {
    @Accessor("eventDeltaVerticalWheel")
    double getEventDeltaVerticalWheel();
    @Accessor("eventDeltaVerticalWheel")
    void setEventDeltaVerticalWheel(double value);
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.Mouse;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import ninja.trek.CraneshotClient;
@Mixin(Mouse.class)
public class MouseMixin {
    @Shadow private double eventDeltaVerticalWheel;
    @Inject(method = "onMouseScroll", at = @At("HEAD"), cancellable = true)
    private void onScroll(long window, double horizontal, double vertical, CallbackInfo ci) {
        if (CraneshotClient.selectMovementType.isPressed() ||
                CraneshotClient.cameraKeyBinds[0].isPressed() ||
                CraneshotClient.cameraKeyBinds[1].isPressed() ||
                CraneshotClient.cameraKeyBinds[2].isPressed()) {
            eventDeltaVerticalWheel = vertical;
            ci.cancel();
        }
    }
}
</file>

<file path="client/resources/craneshot.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"MouseMixin",
		"CameraAccessor",
		"MouseAccessor"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/Craneshot.java">
package ninja.trek;
import net.fabricmc.api.ModInitializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Craneshot implements ModInitializer {
	public static final String MOD_ID = "craneshot";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	@Override
	public void onInitialize() {
		LOGGER.info("CraneShot Camera Mod initialized!");
	}
}
</file>

<file path="main/java/ninja/trek/CraneShotConfig.java">
package ninja.trek;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.fabricmc.loader.api.FabricLoader;
import java.nio.file.Files;
import java.nio.file.Path;
public class CraneShotConfig {
    private static final Path CONFIG_PATH = FabricLoader.getInstance().getConfigDir().resolve("craneshot.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static CraneShotConfig INSTANCE;
    public boolean exampleToggle = true;
    public static CraneShotConfig get() {
        if (INSTANCE == null) {
            load();
        }
        return INSTANCE;
    }
    public static void load() {
        try {
            if (Files.exists(CONFIG_PATH)) {
                INSTANCE = GSON.fromJson(Files.readString(CONFIG_PATH), CraneShotConfig.class);
            } else {
                INSTANCE = new CraneShotConfig();
                save();
            }
        } catch (Exception e) {
            INSTANCE = new CraneShotConfig();
        }
    }
    public static void save() {
        try {
            Files.writeString(CONFIG_PATH, GSON.toJson(INSTANCE));
        } catch (Exception e) {
            // Log error
        }
    }
}
</file>

<file path="main/java/ninja/trek/mixin/ExampleMixin.java">
package ninja.trek.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/resources/craneshot.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "craneshot",
	"version": "${version}",
	"name": "craneshot",
	"description": "Advanced camera controls mod for cinematics",
	"authors": ["Me!"],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/craneshot/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": ["ninja.trek.Craneshot"],
		"client": ["ninja.trek.CraneshotClient"],
		"modmenu": ["ninja.trek.CraneShotConfigMenu"],
		"fabric-datagen": ["ninja.trek.CraneshotDataGenerator"]
	},
	"mixins": [
		"craneshot.mixins.json",
		{
			"config": "craneshot.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*",
		"fabric-key-binding-api-v1": "*"
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
