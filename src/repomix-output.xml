This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-04T07:09:27.841Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/CameraController.java
client/java/ninja/trek/cameramovements/ICameraMovement.java
client/java/ninja/trek/cameramovements/LinearMovement.java
client/java/ninja/trek/CraneshotClient.java
client/java/ninja/trek/CraneShotConfigMenu.java
client/java/ninja/trek/CraneshotDataGenerator.java
client/java/ninja/trek/CraneShotEventHandler.java
client/java/ninja/trek/mixin/client/CameraAccessor.java
client/java/ninja/trek/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/mixin/client/MouseAccessor.java
client/java/ninja/trek/mixin/client/MouseMixin.java
client/resources/craneshot.client.mixins.json
main/java/ninja/trek/Craneshot.java
main/java/ninja/trek/CraneShotConfig.java
main/java/ninja/trek/mixin/ExampleMixin.java
main/resources/craneshot.mixins.json
main/resources/fabric.mod.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/CameraController.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import ninja.trek.cameramovements.*;
public class CameraController {
    private final ICameraMovement[][] movements;
    private int currentMovement = -1;
    private final int[] currentTypes;
    public CameraController() {
        movements = new ICameraMovement[][] {
                {new LinearMovement(),},
                {new LinearMovement()},
                {new LinearMovement()}
        };
        currentTypes = new int[] {0, 0, 0};
    }
    public void startTransition(MinecraftClient client, Camera camera, int movementIndex) {
        if (currentMovement != -1) {
            movements[currentMovement][currentTypes[currentMovement]].reset(client, camera);
        }
        currentMovement = movementIndex;
        movements[movementIndex][currentTypes[movementIndex]].startTransition(client, camera);
    }
    public void updateTransition(MinecraftClient client, Camera camera) {
        if (currentMovement != -1) {
            ICameraMovement movement = movements[currentMovement][currentTypes[currentMovement]];
            if (movement.updateTransition(client, camera))
                currentMovement = -1;
        }
    }
    public void reset(MinecraftClient client, Camera camera) {
        if (currentMovement != -1) {
            movements[currentMovement][currentTypes[currentMovement]].reset(client, camera);
            // Remove currentMovement = -1 so we allow updateTransition(...) to keep animating
        }
    }
    public void cycleMovementType(boolean forward) {
        if (currentMovement != -1) {
            int currentType = currentTypes[currentMovement];
            currentTypes[currentMovement] = forward ?
                    (currentType + 1) % movements[currentMovement].length :
                    (currentType - 1 + movements[currentMovement].length) % movements[currentMovement].length;
        }
    }
    public int getCurrentType(int index) {
        if (index >= 0 && index < currentTypes.length) {
            return currentTypes[index];
        }
        return 0;
    }
    public void adjustDistance(int index, boolean increase) {
        if (index >= 0 && index < movements.length) {
            movements[index][currentTypes[index]].adjustDistance(increase);
        }
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/ICameraMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
public interface ICameraMovement {
    void startTransition(MinecraftClient client, Camera camera);
    boolean updateTransition(MinecraftClient client, Camera camera);
    void reset(MinecraftClient client, Camera camera);
    void adjustDistance(boolean increase);
}
</file>

<file path="client/java/ninja/trek/cameramovements/LinearMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.client.option.Perspective;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.mixin.client.CameraAccessor;
public class LinearMovement implements ICameraMovement {
    private static final float EASING_FACTOR = 0.1f;
    private static final double SCROLL_SENSITIVITY = 0.5;
    private static final double FIRST_PERSON_DISTANCE_THRESHOLD = 3.5;
    private static final double MIN_DISTANCE = 2.0;
    private static final double MAX_DISTANCE = 20.0;
    private double targetDistance = 10;
    private double currentDistance = 0;
    private Vec3d lastPlayerPos = new Vec3d(0, 0, 0);
    private double lastYaw = 0;
    private double lastPitch = 0;
    private boolean resetting = false;
    private boolean wasFirstPerson = true;
    @Override
    public void startTransition(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return;
        lastPlayerPos = player.getPos();
        lastYaw = player.getYaw();
        lastPitch = player.getPitch();
        currentDistance = 0;
        resetting = false;
        wasFirstPerson = client.options.getPerspective() == Perspective.FIRST_PERSON;
    }
    @Override
    public boolean updateTransition(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return true;
        // Calculate desired distance based on whether we're resetting
        double desiredDistance = resetting ? 0 : targetDistance;
        // Smooth distance transition with variable easing
        double easingFactor = resetting && currentDistance < 1.0 ? EASING_FACTOR * 2 : EASING_FACTOR;
        currentDistance += (desiredDistance - currentDistance) * easingFactor;
        // Handle perspective changes
        if (currentDistance > FIRST_PERSON_DISTANCE_THRESHOLD &&
                client.options.getPerspective() == Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.THIRD_PERSON_BACK);
        } else if (currentDistance < FIRST_PERSON_DISTANCE_THRESHOLD &&
                client.options.getPerspective() != Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.FIRST_PERSON);
        }
        // Calculate camera position behind player
        double yaw = Math.toRadians(player.getYaw());
        double pitch = Math.toRadians(player.getPitch());
        // Calculate offset based on yaw and pitch
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * currentDistance;
        double yOffset = Math.sin(pitch) * currentDistance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * currentDistance;
        Vec3d playerPos = player.getEyePos();
        Vec3d cameraPos = playerPos.add(xOffset, yOffset, zOffset);
        // Update camera position and rotation
        ((CameraAccessor)camera).invokesetPos(cameraPos);
        ((CameraAccessor)camera).invokeSetRotation(player.getYaw(), player.getPitch());
        lastPlayerPos = player.getPos();
        lastYaw = player.getYaw();
        lastPitch = player.getPitch();
        // Return true only if we're fully reset
        return resetting && currentDistance < 0.01;
    }
    @Override
    public void reset(MinecraftClient client, Camera camera) {
        resetting = true;
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? (1.0 / (1.0 + SCROLL_SENSITIVITY)) : (1.0 + SCROLL_SENSITIVITY);
        targetDistance = Math.max(MIN_DISTANCE, Math.min(MAX_DISTANCE, targetDistance * multiplier));
    }
}
</file>

<file path="client/java/ninja/trek/CraneshotClient.java">
package ninja.trek;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.client.util.InputUtil;
import org.lwjgl.glfw.GLFW;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
public class CraneshotClient implements ClientModInitializer {
	public static KeyBinding[] cameraKeyBinds;
	public static KeyBinding selectMovementType;
	public static final CameraController CAMERA_CONTROLLER = new CameraController();
	@Override
	public void onInitializeClient() {
		selectMovementType = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.select_movement",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_X,
				"category.craneshot.camera"
		));
		cameraKeyBinds = new KeyBinding[]{
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera1",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_C,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera2",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_V,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera3",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_B,
						"category.craneshot.camera"
				))
		};
		CraneShotEventHandler.register();
	}
}
</file>

<file path="client/java/ninja/trek/CraneShotConfigMenu.java">
package ninja.trek;
import com.terraformersmc.modmenu.api.ConfigScreenFactory;
import com.terraformersmc.modmenu.api.ModMenuApi;
import me.shedaniel.clothconfig2.api.ConfigBuilder;
import me.shedaniel.clothconfig2.api.ConfigCategory;
import me.shedaniel.clothconfig2.api.ConfigEntryBuilder;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.text.Text;
public class CraneShotConfigMenu implements ModMenuApi {
    @Override
    public ConfigScreenFactory<?> getModConfigScreenFactory() {
        return parent -> {
            ConfigBuilder builder = ConfigBuilder.create()
                    .setParentScreen(parent)
                    .setTitle(Text.translatable("config.craneshot.title"));
            ConfigCategory general = builder.getOrCreateCategory(
                    Text.translatable("config.craneshot.category.general"));
            ConfigEntryBuilder entryBuilder = builder.entryBuilder();
            general.addEntry(entryBuilder.startBooleanToggle(
                            Text.translatable("config.craneshot.option.example_toggle"),
                            ninja.trek.CraneShotConfig.get().exampleToggle)
                    .setDefaultValue(true)
                    .setSaveConsumer(newValue -> {
                        ninja.trek.CraneShotConfig.get().exampleToggle = newValue;
                        ninja.trek.CraneShotConfig.save();
                    })
                    .build());
            return builder.build();
        };
    }
}
</file>

<file path="client/java/ninja/trek/CraneshotDataGenerator.java">
package ninja.trek;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class CraneshotDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/java/ninja/trek/CraneShotEventHandler.java">
package ninja.trek;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;
import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.text.Text;
import ninja.trek.mixin.client.MouseAccessor;
public class CraneShotEventHandler {
    private static boolean[] wasPressed = new boolean[3];
    private static double lastScrollTime = 0;
    private static final double SCROLL_COOLDOWN = 0.1;
    private static final String[] MOVEMENT_NAMES = {"Linear", "Circular", "Bezier"};
    private static String currentMessage = "";
    private static long messageTimer = 0;
    private static final long MESSAGE_DURATION = 2000;
    public static void register() {
        ClientTickEvents.END_CLIENT_TICK.register(client -> {
            handleScrollInput(client);
            updateMessageTimer();
        });
        HudRenderCallback.EVENT.register((context, tickDelta) -> {
            if (!currentMessage.isEmpty() && System.currentTimeMillis() < messageTimer) {
                MinecraftClient client = MinecraftClient.getInstance();
                if (client.player != null) {
                    int width = client.getWindow().getScaledWidth();
                    context.drawTextWithShadow(client.textRenderer, Text.literal(currentMessage),
                            width / 2 - client.textRenderer.getWidth(currentMessage) / 2,
                            60, 0xFFFFFF);
                }
            }
        });
        WorldRenderEvents.START.register((context) -> {
            MinecraftClient client = MinecraftClient.getInstance();
            Camera camera = client.gameRenderer.getCamera();
            boolean anyPressed = false;
            for (int i = 0; i < 3; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    if (!wasPressed[i]) {
                        CraneshotClient.CAMERA_CONTROLLER.startTransition(client, camera, i);
                    }
                    wasPressed[i] = true;
                    anyPressed = true;
                } else {
                    wasPressed[i] = false;
                }
            }
            if (!anyPressed) {
                CraneshotClient.CAMERA_CONTROLLER.reset(client, camera);
            }
            if (client.player != null) {
                CraneshotClient.CAMERA_CONTROLLER.updateTransition(client, camera);
            }
        });
    }
    private static void handleScrollInput(MinecraftClient client) {
        double currentTime = System.currentTimeMillis() / 1000.0;
        if (currentTime - lastScrollTime < SCROLL_COOLDOWN) return;
        double scrollDelta = ((MouseAccessor)client.mouse).getEventDeltaVerticalWheel();
        if (scrollDelta == 0) return;
        boolean scrollUp = scrollDelta > 0;
        if (CraneshotClient.selectMovementType.isPressed()) {
            CraneshotClient.CAMERA_CONTROLLER.cycleMovementType(scrollUp);
            showMovementTypeMessage();
            lastScrollTime = currentTime;
            ((MouseAccessor)client.mouse).setEventDeltaVerticalWheel(0);
        } else {
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    CraneshotClient.CAMERA_CONTROLLER.adjustDistance(i, scrollUp);
                    lastScrollTime = currentTime;
                    ((MouseAccessor)client.mouse).setEventDeltaVerticalWheel(0);
                    break;
                }
            }
        }
    }
    private static void showMovementTypeMessage() {
        int currentHotkey = -1;
        for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
            if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                currentHotkey = i;
                break;
            }
        }
        if (currentHotkey != -1) {
            String movementType = MOVEMENT_NAMES[CraneshotClient.CAMERA_CONTROLLER.getCurrentType(currentHotkey)];
            currentMessage = String.format("Camera %d: %s Movement", currentHotkey + 1, movementType);
            messageTimer = System.currentTimeMillis() + MESSAGE_DURATION;
        }
    }
    private static void updateMessageTimer() {
        if (System.currentTimeMillis() >= messageTimer) {
            currentMessage = "";
        }
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/CameraAccessor.java">
package ninja.trek.mixin.client;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import org.spongepowered.asm.mixin.gen.Invoker;
@Mixin(Camera.class)
public interface CameraAccessor {
    @Accessor("pos")
    void invokesetPos(Vec3d pos);
    @Accessor("pos")
    Vec3d getPos();
    @Invoker("setRotation")
    void invokeSetRotation(float yaw, float pitch);
}
</file>

<file path="client/java/ninja/trek/mixin/client/ExampleClientMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseAccessor.java">
package ninja.trek.mixin.client;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import net.minecraft.client.Mouse;
@Mixin(Mouse.class)
public interface MouseAccessor {
    @Accessor("eventDeltaVerticalWheel")
    double getEventDeltaVerticalWheel();
    @Accessor("eventDeltaVerticalWheel")
    void setEventDeltaVerticalWheel(double value);
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.Mouse;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import ninja.trek.CraneshotClient;
@Mixin(Mouse.class)
public class MouseMixin {
    @Shadow private double eventDeltaVerticalWheel;
    @Inject(method = "onMouseScroll", at = @At("HEAD"), cancellable = true)
    private void onScroll(long window, double horizontal, double vertical, CallbackInfo ci) {
        if (CraneshotClient.selectMovementType.isPressed() ||
                CraneshotClient.cameraKeyBinds[0].isPressed() ||
                CraneshotClient.cameraKeyBinds[1].isPressed() ||
                CraneshotClient.cameraKeyBinds[2].isPressed()) {
            eventDeltaVerticalWheel = vertical;
            ci.cancel();
        }
    }
}
</file>

<file path="client/resources/craneshot.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"MouseMixin",
		"CameraAccessor",
		"MouseAccessor"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/Craneshot.java">
package ninja.trek;
import net.fabricmc.api.ModInitializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Craneshot implements ModInitializer {
	public static final String MOD_ID = "craneshot";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	@Override
	public void onInitialize() {
		LOGGER.info("CraneShot Camera Mod initialized!");
	}
}
</file>

<file path="main/java/ninja/trek/CraneShotConfig.java">
package ninja.trek;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.fabricmc.loader.api.FabricLoader;
import java.nio.file.Files;
import java.nio.file.Path;
public class CraneShotConfig {
    private static final Path CONFIG_PATH = FabricLoader.getInstance().getConfigDir().resolve("craneshot.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static CraneShotConfig INSTANCE;
    public boolean exampleToggle = true;
    public static CraneShotConfig get() {
        if (INSTANCE == null) {
            load();
        }
        return INSTANCE;
    }
    public static void load() {
        try {
            if (Files.exists(CONFIG_PATH)) {
                INSTANCE = GSON.fromJson(Files.readString(CONFIG_PATH), CraneShotConfig.class);
            } else {
                INSTANCE = new CraneShotConfig();
                save();
            }
        } catch (Exception e) {
            INSTANCE = new CraneShotConfig();
        }
    }
    public static void save() {
        try {
            Files.writeString(CONFIG_PATH, GSON.toJson(INSTANCE));
        } catch (Exception e) {
            // Log error
        }
    }
}
</file>

<file path="main/java/ninja/trek/mixin/ExampleMixin.java">
package ninja.trek.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/resources/craneshot.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "craneshot",
	"version": "${version}",
	"name": "craneshot",
	"description": "Advanced camera controls mod for cinematics",
	"authors": ["Me!"],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/craneshot/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": ["ninja.trek.Craneshot"],
		"client": ["ninja.trek.CraneshotClient"],
		"modmenu": ["ninja.trek.CraneShotConfigMenu"],
		"fabric-datagen": ["ninja.trek.CraneshotDataGenerator"]
	},
	"mixins": [
		"craneshot.mixins.json",
		{
			"config": "craneshot.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*",
		"fabric-key-binding-api-v1": "*"
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
