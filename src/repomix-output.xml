This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-08T19:57:29.771Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/CameraController.java
client/java/ninja/trek/CameraMovementManager.java
client/java/ninja/trek/CameraMovementRegistry.java
client/java/ninja/trek/cameramovements/AbstractMovementSettings.java
client/java/ninja/trek/cameramovements/CameraMovementType.java
client/java/ninja/trek/cameramovements/CameraState.java
client/java/ninja/trek/cameramovements/CameraTarget.java
client/java/ninja/trek/cameramovements/ICameraMovement.java
client/java/ninja/trek/cameramovements/movements/BezierMovement.java
client/java/ninja/trek/cameramovements/movements/LinearMovement.java
client/java/ninja/trek/cameramovements/MovementState.java
client/java/ninja/trek/cameramovements/RaycastType.java
client/java/ninja/trek/cameramovements/RaycastUtil.java
client/java/ninja/trek/CraneshotClient.java
client/java/ninja/trek/CraneshotDataGenerator.java
client/java/ninja/trek/CraneShotEventHandler.java
client/java/ninja/trek/IKeyboardInputMixin.java
client/java/ninja/trek/IMouseMixin.java
client/java/ninja/trek/mixin/client/CameraAccessor.java
client/java/ninja/trek/mixin/client/CameraMixin.java
client/java/ninja/trek/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/mixin/client/KeyboardInputMixin.java
client/java/ninja/trek/mixin/client/MouseAccessor.java
client/java/ninja/trek/mixin/client/MouseMixin.java
client/java/ninja/trek/mixin/client/TransparencyMixin.java
client/java/ninja/trek/mixin/client/WorldRendererMixin.java
client/java/ninja/trek/MouseInterceptor.java
client/resources/craneshot.client.mixins.json
main/java/ninja/trek/Craneshot.java
main/java/ninja/trek/mixin/ExampleMixin.java
main/resources/craneshot.mixins.json
main/resources/fabric.mod.json
repomixx - cameramovements folder.bat
repomixx - ignore config.bat
repomixx - movements only.bat
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/CameraController.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.client.option.Perspective;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.BlockView;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.cameramovements.AbstractMovementSettings.POST_MOVE_KEYS;
import ninja.trek.cameramovements.AbstractMovementSettings.POST_MOVE_MOUSE;
import ninja.trek.cameramovements.CameraTarget;
import ninja.trek.mixin.client.CameraAccessor;
/**
 * Applies the computed camera state to the actual camera and handles direct keyboard and mouse input.
 */
public class CameraController {
    // The movement manager computes and maintains the base camera state.
    // Fields that hold free-control state (updated when in MOVE/ROTATE modes).
    public static POST_MOVE_KEYS currentKeyMoveMode = POST_MOVE_KEYS.NONE;
    public static POST_MOVE_MOUSE currentMouseMoveMode = POST_MOVE_MOUSE.NONE;
    public static Vec3d freeCamPosition = Vec3d.ZERO;
    public static float freeCamYaw = 0f;
    public static float freeCamPitch = 0f;
    // A “control stick” target (e.g., used to drive the base position).
    public static CameraTarget controlStick = new CameraTarget();
    // On-screen message handling.
    private String currentMessage = "";
    private long messageTimer = 0;
    private static final long MESSAGE_DURATION = 2000;
    public static final double FIRST_PERSON_THRESHOLD_MIN = 2.0;
    public static final double FIRST_PERSON_THRESHOLD_MAX = 5.0;
    public CameraController() {
    }
    //=== Input & Free Control Handling ===========================================
    /**
     * Updates the control stick based on the player's current position and view.
     */
    private void updateControlStick(MinecraftClient client) {
        if (client.player == null) return;
        Camera camera = client.gameRenderer.getCamera();
        if (camera != null) {
            if (currentMouseMoveMode == POST_MOVE_MOUSE.ROTATE_CAMERA)
                controlStick.set(
                        client.player.getEyePos(),
                        controlStick.getYaw(),
                        controlStick.getPitch()
                );
                else controlStick.set(
                    client.player.getEyePos(),
                    client.player.getYaw(),
                    client.player.getPitch()
            );
        }
    }
    /**
     * Handles keyboard-based free movement.
     */
    private void handleKeyboardMovement(MinecraftClient client, Camera camera) {
        float speed = 0.5f;
        Vec3d movement = Vec3d.ZERO;
        if (currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            float yaw = freeCamYaw;
            float pitch = freeCamPitch;
            Vec3d forward = new Vec3d(
                    -Math.sin(Math.toRadians(yaw)) * Math.cos(Math.toRadians(pitch)),
                    -Math.sin(Math.toRadians(pitch)),
                    Math.cos(Math.toRadians(yaw)) * Math.cos(Math.toRadians(pitch))
            ).normalize();
            Vec3d worldUp = new Vec3d(0, 1, 0);
            Vec3d right = worldUp.crossProduct(forward).normalize();
            Vec3d up = forward.crossProduct(right).normalize();
            if (client.options.forwardKey.isPressed()) movement = movement.add(forward);
            if (client.options.backKey.isPressed()) movement = movement.subtract(forward);
            if (client.options.leftKey.isPressed()) movement = movement.add(right);
            if (client.options.rightKey.isPressed()) movement = movement.subtract(right);
            if (client.options.jumpKey.isPressed()) movement = movement.add(up);
            if (client.options.sneakKey.isPressed()) movement = movement.subtract(up);
        } else if (currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FLAT) {
            float yaw = freeCamYaw;
            Vec3d forward = new Vec3d(
                    -Math.sin(Math.toRadians(yaw)),
                    0,
                    Math.cos(Math.toRadians(yaw))
            );
            Vec3d right = new Vec3d(
                    Math.cos(Math.toRadians(yaw)),
                    0,
                    Math.sin(Math.toRadians(yaw))
            );
            if (client.options.forwardKey.isPressed()) movement = movement.add(forward);
            if (client.options.backKey.isPressed()) movement = movement.subtract(forward);
            if (client.options.leftKey.isPressed()) movement = movement.add(right);
            if (client.options.rightKey.isPressed()) movement = movement.subtract(right);
            if (client.options.jumpKey.isPressed()) movement = movement.add(0, 1, 0);
            if (client.options.sneakKey.isPressed()) movement = movement.add(0, -1, 0);
        }
        if (movement.lengthSquared() > 0) {
            movement = movement.normalize().multiply(speed);
            freeCamPosition = freeCamPosition.add(movement);
            ((CameraAccessor) camera).invokesetPos(freeCamPosition);
        }
    }
    /**
     * Updates the camera perspective based on the distance between the camera and the player.
     */
    private void updatePerspective(MinecraftClient client, Camera camera) {
        if (client.player == null) return;
        double distance = camera.getPos().distanceTo(controlStick.getPosition());
        if (distance > FIRST_PERSON_THRESHOLD_MIN && client.options.getPerspective() == Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.THIRD_PERSON_BACK);
        } else if (distance < FIRST_PERSON_THRESHOLD_MIN && client.options.getPerspective() != Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.FIRST_PERSON);
        }
    }
    //=== Camera Update – Combining Movement and Free Controls ===================
    /**
     * Called every frame to update the camera. It retrieves the base target from the movement manager,
     * applies any free control modifications, and then applies the final state to the camera.
     */
    public void updateCamera(MinecraftClient client, Camera camera) {
        if (CraneshotClient.MOVEMENT_MANAGER.getActiveMovement() == null) return;
        updateControlStick(client);
        CameraTarget baseTarget = CraneshotClient.MOVEMENT_MANAGER.update(client, camera);
        if (baseTarget != null) {
            // Always update the position according to the current movement.
            freeCamPosition = baseTarget.getPosition();
            ((CameraAccessor) camera).invokesetPos(freeCamPosition);
            // ROTATION:
            // If we're in ROTATE_CAMERA mode, apply mouse deltas (if any) to adjust freeCamYaw/freeCamPitch.
            if (currentMouseMoveMode == POST_MOVE_MOUSE.ROTATE_CAMERA && client.mouse instanceof IMouseMixin) {
                IMouseMixin mouseMixin = (IMouseMixin) client.mouse;
                double deltaX = mouseMixin.getCapturedDeltaX();
                double deltaY = -mouseMixin.getCapturedDeltaY();
                double mouseSensitivity = client.options.getMouseSensitivity().getValue();
                double scaledSensitivity = 0.6 * mouseSensitivity * mouseSensitivity + 0.2;
                // Only update rotation if there is nonzero mouse input
                Craneshot.LOGGER.info("free rotation apdfsfdplied");
                if (deltaX != 0 || deltaY != 0) {
                    freeCamYaw += (float) (deltaX * scaledSensitivity);
                    freeCamPitch = Math.max(-90, Math.min(90, freeCamPitch - (float) (deltaY * scaledSensitivity)));
                    Craneshot.LOGGER.info("free rotation applied");
                }
                // (If no mouse delta occurs, leave freeCamYaw/freeCamPitch unchanged so that the camera keeps its rotated view.)
            } else {
                // In non-rotate mode, follow the movement’s computed rotation.
                freeCamYaw = baseTarget.getYaw();
                freeCamPitch = baseTarget.getPitch();
            }
            ((CameraAccessor) camera).invokeSetRotation(freeCamYaw, freeCamPitch);
        }
        updatePerspective(client, camera);
        updateMessageTimer();
    }
    //=== Message Handling ========================================================
    public void showMessage(String message) {
        currentMessage = message;
        messageTimer = System.currentTimeMillis() + MESSAGE_DURATION;
    }
    public String getCurrentMessage() {
        return currentMessage;
    }
    public boolean hasActiveMessage() {
        return System.currentTimeMillis() < messageTimer;
    }
    private void updateMessageTimer() {
        if (System.currentTimeMillis() >= messageTimer) {
            currentMessage = "";
        }
    }
    /**
     * Updates the camera each frame. This method (which used to be called handleCameraUpdate)
     * is responsible for applying the computed camera state (from the movement manager) as well as
     * processing any free keyboard/mouse input. It should be placed in CameraController.
     */
    public void handleCameraUpdate(BlockView area, Entity focusedEntity, boolean thirdPerson,
                                   boolean inverseView, float tickDelta, Camera camera) {
        // Verify that both the camera and the focused entity exist.
        if (camera == null || focusedEntity == null) return;
        MinecraftClient client = MinecraftClient.getInstance();
        if (client == null || client.world == null) return;
        // Update the camera based on movement-manager and free control states.
        updateCamera(client, camera);
        // Optionally update keyboard input (e.g. disable it when free control is active)
        updateKeyboardInput(client);
    }
    /**
     * Disables the player's default keyboard movement when free-control modes are active.
     */
    private void updateKeyboardInput(MinecraftClient client) {
        if (client.player != null && client.player.input instanceof IKeyboardInputMixin) {
            boolean shouldDisable = currentKeyMoveMode != POST_MOVE_KEYS.NONE;
            ((IKeyboardInputMixin) client.player.input).setDisabled(shouldDisable);
        }
    }
    public void setPostMoveStates(AbstractMovementSettings m) {
        if (m == null){
            currentKeyMoveMode = null;
            currentMouseMoveMode = null;
            MouseInterceptor.setIntercepting(false);
        } else {
            currentMouseMoveMode = m.getPostMoveMouse();
            currentKeyMoveMode = m.getPostMoveKeys();
            if (currentMouseMoveMode == POST_MOVE_MOUSE.ROTATE_CAMERA) MouseInterceptor.setIntercepting(true);
        }
    }
    public void onComplete() {
        currentMouseMoveMode = POST_MOVE_MOUSE.NONE;
        currentKeyMoveMode = POST_MOVE_KEYS.NONE;
    }
}
</file>

<file path="client/java/ninja/trek/CameraMovementManager.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import ninja.trek.cameramovements.CameraTarget;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.cameramovements.MovementState;
import java.util.*;
/**
 * Owns the movement slots and handles ticking/updating the ICameraMovements.
 * It also manages transitions, key toggle states, and slot-related operations.
 */
public class CameraMovementManager {
    // Each slot holds a list of available camera movements.
    private List<List<ICameraMovement>> slots;
    // For each slot, track which movement is currently active.
    private List<Integer> currentTypes;
    // The index of the currently active movement slot (if any).
    private Integer activeMovementSlot;
    // Toggle states for keybindings that use toggle mode.
    private Map<Integer, Boolean> toggledStates;
    // The currently active movement instance.
    private ICameraMovement activeMovement;
    // The most-recently computed camera target from the active movement.
    private CameraTarget baseTarget;
    public CameraMovementManager() {
        int numSlots = 3; // Set to the desired number of slots.
        slots = new ArrayList<>();
        currentTypes = new ArrayList<>();
        toggledStates = new HashMap<>();
        for (int i = 0; i < numSlots; i++) {
            slots.add(new ArrayList<>());
            currentTypes.add(0);
        }
        activeMovementSlot = null;
        activeMovement = null;
        baseTarget = null;
    }
    //=== Slot Management Methods =================================================
    /**
     * Sets all slots from a saved configuration.
     */
    public void setAllSlots(List<List<ICameraMovement>> savedSlots) {
        this.slots = savedSlots;
        // Reset currentTypes to valid indices.
        currentTypes = new ArrayList<>();
        for (int i = 0; i < slots.size(); i++) {
            currentTypes.add(0);
        }
    }
    /**
     * Adds a movement to the given slot.
     */
    public void addMovement(int slotIndex, ICameraMovement movement) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            slots.get(slotIndex).add(movement);
        }
    }
    /**
     * Removes a movement from the given slot.
     */
    public void removeMovement(int slotIndex, int movementIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (movementIndex >= 0 && movementIndex < slotMovements.size() && slotMovements.size() > 1) {
                slotMovements.remove(movementIndex);
                if (currentTypes.get(slotIndex) >= slotMovements.size()) {
                    currentTypes.set(slotIndex, slotMovements.size() - 1);
                }
            }
        }
    }
    /**
     * Swaps two movements in the specified slot.
     */
    public void swapMovements(int slotIndex, int index1, int index2) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (index1 >= 0 && index1 < slotMovements.size() &&
                    index2 >= 0 && index2 < slotMovements.size()) {
                Collections.swap(slotMovements, index1, index2);
            }
        }
    }
    /**
     * Returns the number of movement slots.
     */
    public int getMovementCount() {
        return slots.size();
    }
    /**
     * Returns a copy of the available movements for the given slot.
     */
    public List<ICameraMovement> getAvailableMovementsForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            return new ArrayList<>(slots.get(slotIndex));
        }
        return new ArrayList<>();
    }
    /**
     * Returns the movement currently selected in the given slot.
     */
    public ICameraMovement getMovementAt(int index) {
        if (index >= 0 && index < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(index);
            int currentType = currentTypes.get(index);
            if (!slotMovements.isEmpty() && currentType < slotMovements.size()) {
                return slotMovements.get(currentType);
            }
        }
        return null;
    }
    /**
     * Cycles the current movement type in the given slot.
     * @param forward if true, cycles forward; if false, cycles backward.
     * @param wrap whether to wrap around the list.
     */
    public void cycleMovementType(boolean forward, int slotIndex, boolean wrap) {
        if (slotIndex < 0 || slotIndex >= slots.size()) return;
        List<ICameraMovement> slotMovements = slots.get(slotIndex);
        if (slotMovements.isEmpty()) return;
        int currentType = currentTypes.get(slotIndex);
        int newType;
        if (forward) {
            newType = wrap ? (currentType + 1) % slotMovements.size() : Math.min(currentType + 1, slotMovements.size() - 1);
        } else {
            newType = wrap ? (currentType - 1 + slotMovements.size()) % slotMovements.size() : Math.max(currentType - 1, 0);
        }
        currentTypes.set(slotIndex, newType);
    }
    /**
     * Convenience method: cycles the movement type of the currently active slot.
     */
    public void cycleMovementType(boolean forward) {
        if (activeMovementSlot != null) {
            cycleMovementType(forward, activeMovementSlot, false);
        }
    }
    /**
     * Adjusts the distance (or another parameter) of the movement in the given slot.
     */
    public void adjustDistance(int slotIndex, boolean increase) {
        ICameraMovement movement = getMovementAt(slotIndex);
        if (movement != null) {
            movement.adjustDistance(increase);
        }
    }
    //=== Transition and Key State Handling =======================================
    /**
     * Starts a camera movement transition from the movement in the specified slot.
     */
    public void startTransition(MinecraftClient client, Camera camera, int slotIndex) {
        ICameraMovement movement = getMovementAt(slotIndex);
        if (movement == null) return;
        // If the same slot is already active, finish the transition.
        if (activeMovementSlot != null && activeMovementSlot.equals(slotIndex)) {
            finishTransition(client, camera);
            return;
        }
        // If another movement is active, finish it first.
        if (activeMovementSlot != null && !activeMovementSlot.equals(slotIndex)) {
            toggledStates.put(activeMovementSlot, false);
            finishTransition(client, camera);
        }
        activeMovementSlot = slotIndex;
        activeMovement = movement;
        movement.start(client, camera);
    }
    public void finishTransition(MinecraftClient client, Camera camera) {
        if (activeMovement != null) {
            activeMovement.queueReset(client, camera);
            // Do not clear activeMovement here; let update() continue to process the reset phase.
        }
    }
    /**
     * Handles key state changes.
     *
     * @param keyIndex The slot index tied to the key.
     * @param pressed  Whether the key was pressed.
     * @param isToggleMode  True if this key is in toggle mode.
     */
    public void handleKeyStateChange(int keyIndex, boolean pressed, MinecraftClient client, Camera camera, boolean isToggleMode) {
        if (pressed) {
            if (activeMovementSlot != null && !activeMovementSlot.equals(keyIndex)) {
                toggledStates.put(activeMovementSlot, false);
                finishTransition(client, camera);
            }
            if (isToggleMode) {
                boolean currentToggle = toggledStates.getOrDefault(keyIndex, false);
                boolean newToggle = !currentToggle;
                toggledStates.put(keyIndex, newToggle);
                if (newToggle) {
                    startTransition(client, camera, keyIndex);
                } else {
                    finishTransition(client, camera);
                }
            } else {
                startTransition(client, camera, keyIndex);
            }
        } else {
            if (!isToggleMode) {
                if (activeMovementSlot != null && activeMovementSlot.equals(keyIndex)) {
                    finishTransition(client, camera);
                }
            }
        }
    }
    //=== Updating / Ticking the Active Movement ==================================
    /**
     * Ticks the active movement and returns the computed CameraTarget.
     * If the movement is complete, it finishes the transition.
     */
    public CameraTarget update(MinecraftClient client, Camera camera) {
        if (activeMovement == null || client.player == null) {
            return null;
        }
        MovementState state = activeMovement.calculateState(client, camera);
        if (activeMovement.hasCompletedOutPhase()){
            CraneshotClient.CAMERA_CONTROLLER.setPostMoveStates((AbstractMovementSettings) activeMovement);
        } else CraneshotClient.CAMERA_CONTROLLER.setPostMoveStates(null);
        if (state.isComplete()) {
            CraneshotClient.CAMERA_CONTROLLER.onComplete();
            activeMovement = null;
            activeMovementSlot = null;  // Add this line to clear the slot
            toggledStates.put(activeMovementSlot, false);  // Reset toggle state
            return null;
        }
        // Adjust the base target (e.g. using player's position and any raycasting)
        baseTarget = state.getCameraTarget().withAdjustedPosition(client.player, activeMovement.getRaycastType());
        return baseTarget;
    }
    //=== Getters =================================================================
    public Integer getActiveMovementSlot() {
        return activeMovementSlot;
    }
    public ICameraMovement getActiveMovement() {
        return activeMovement;
    }
    public List<List<ICameraMovement>> getSlots() {
        return slots;
    }
}
</file>

<file path="client/java/ninja/trek/CameraMovementRegistry.java">
package ninja.trek;
import ninja.trek.cameramovements.CameraMovementType;
import ninja.trek.cameramovements.ICameraMovement;
import net.fabricmc.loader.api.FabricLoader;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.net.URL;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
public class CameraMovementRegistry {
    private static final List<Class<? extends ICameraMovement>> movementTypes = new ArrayList<>();
    private static int currentTypeIndex = 0;
    private static final String BASE_PACKAGE = "ninja.trek.cameramovements";
    public static void initialize() {
        try {
            scanPackage(BASE_PACKAGE);
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to scan for camera movements", e);
        }
    }
    private static void scanPackage(String packageName) {
        try {
            String path = packageName.replace('.', '/');
            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
            Enumeration<URL> resources = classLoader.getResources(path);
            while (resources.hasMoreElements()) {
                URL resource = resources.nextElement();
                String protocol = resource.getProtocol();
                if (protocol.equals("file")) {
                    scanDirectory(new File(resource.getFile()), packageName);
                } else if (protocol.equals("jar")) {
                    scanJar(resource, path);
                }
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Error scanning package: " + packageName, e);
        }
    }
    private static void scanDirectory(File directory, String packageName) {
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    scanDirectory(file, packageName + "." + file.getName());
                } else if (file.getName().endsWith(".class")) {
                    String className = packageName + "." + file.getName().substring(0, file.getName().length() - 6);
                    processClass(className);
                }
            }
        }
    }
    private static void scanJar(URL resourceUrl, String path) {
        String jarPath = resourceUrl.getPath().substring(5, resourceUrl.getPath().indexOf("!"));
        try (JarFile jarFile = new JarFile(jarPath)) {
            Enumeration<JarEntry> entries = jarFile.entries();
            while (entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String entryName = entry.getName();
                if (entryName.startsWith(path) && entryName.endsWith(".class")) {
                    String className = entryName.substring(0, entryName.length() - 6).replace('/', '.');
                    processClass(className);
                }
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Error scanning JAR file: " + jarPath, e);
        }
    }
    private static void processClass(String className) {
        try {
            Class<?> cls = Class.forName(className);
            if (ICameraMovement.class.isAssignableFrom(cls) &&
                    cls.isAnnotationPresent(CameraMovementType.class)) {
                CameraMovementType annotation = cls.getAnnotation(CameraMovementType.class);
                if (annotation.enabled()) {
                    @SuppressWarnings("unchecked")
                    Class<? extends ICameraMovement> movementClass = (Class<? extends ICameraMovement>) cls;
                    registerMovement(movementClass);
                }
            }
        } catch (ClassNotFoundException e) {
            Craneshot.LOGGER.error("Error loading class: " + className, e);
        }
    }
    public static void registerMovement(Class<? extends ICameraMovement> movementClass) {
        Craneshot.LOGGER.info("found movement type: " + movementClass);
        if (!movementTypes.contains(movementClass)) {
            movementTypes.add(movementClass);
        }
    }
    public static ICameraMovement createCurrentMovement() {
        try {
            Constructor<? extends ICameraMovement> constructor = movementTypes.get(currentTypeIndex).getDeclaredConstructor();
            return constructor.newInstance();
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to create movement instance", e);
            return null;
        }
    }
    public static List<MovementInfo> getAllMovements() {
        List<MovementInfo> movements = new ArrayList<>();
        for (Class<? extends ICameraMovement> cls : movementTypes) {
            CameraMovementType annotation = cls.getAnnotation(CameraMovementType.class);
            if (annotation != null) {
                movements.add(new MovementInfo(
                        annotation.name().isEmpty() ? cls.getSimpleName() : annotation.name(),
                        annotation.description(),
                        cls
                ));
            }
        }
        return movements;
    }
    public static void cycleNextMovement() {
        currentTypeIndex = (currentTypeIndex + 1) % movementTypes.size();
    }
    public static String getCurrentMovementName() {
        Class<? extends ICameraMovement> currentClass = movementTypes.get(currentTypeIndex);
        CameraMovementType annotation = currentClass.getAnnotation(CameraMovementType.class);
        return annotation != null && !annotation.name().isEmpty() ?
                annotation.name() : currentClass.getSimpleName();
    }
    public static int getMovementCount() {
        return movementTypes.size();
    }
    // Helper class to hold movement type information
    public static class MovementInfo {
        private final String name;
        private final String description;
        private final Class<? extends ICameraMovement> movementClass;
        public MovementInfo(String name, String description, Class<? extends ICameraMovement> movementClass) {
            this.name = name;
            this.description = description;
            this.movementClass = movementClass;
        }
        public String getName() { return name; }
        public String getDescription() { return description; }
        public Class<? extends ICameraMovement> getMovementClass() { return movementClass; }
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/AbstractMovementSettings.java">
package ninja.trek.cameramovements;
import net.minecraft.entity.player.PlayerEntity;
import ninja.trek.Craneshot;
import ninja.trek.config.MovementSetting;
import ninja.trek.config.MovementSettingType;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;
public abstract class AbstractMovementSettings {
    private String customName = null;
    @MovementSetting(
            label = "Raycast Type",
            type = MovementSettingType.ENUM,
            description = "Controls how the camera handles collision with blocks"
    )
    private RaycastType raycastType = RaycastType.NEAR;
    public double alpha;
    public enum START_TARGET {PLAYER};
    public enum END_TARGET {HEAD_BACK, HEAD_FRONT, VELOCITY_FRONT, VELOCITY_BACK}
    public enum POST_MOVE_MOUSE {
        NONE,       // Default behavior
        ROTATE_CAMERA // Allow free mouse control after movement
           // Allow WASD movement after movement
    }
    @MovementSetting(
            label = "Post-Movement Mouse",
            type = MovementSettingType.ENUM,
            description = "Controls camera behavior after movement completes"
    )
    protected POST_MOVE_MOUSE postMoveMouse = POST_MOVE_MOUSE.NONE;
    public POST_MOVE_MOUSE getPostMoveMouse() {
        return postMoveMouse;
    }
    public enum POST_MOVE_KEYS {
        NONE,       // Default behavior
        MOVE_CAMERA_FLAT, // Y-axis locked camera-relative movement
        MOVE_CAMERA_FREE, // Full camera-relative movement including pitch
        MOVE8       // 8-directional player movement relative to camera
    }
    @MovementSetting(
            label = "Post-Movement Keys",
            type = MovementSettingType.ENUM,
            description = "Controls camera behavior after movement completes"
    )
    protected POST_MOVE_KEYS postMoveKeys = POST_MOVE_KEYS.NONE;
    public POST_MOVE_KEYS getPostMoveKeys(){return postMoveKeys;}
    @MovementSetting(
            label = "Camera Position",
            type = MovementSettingType.ENUM,
            description = "Determines if camera follows in front or behind the player"
    )
    protected END_TARGET endTarget = END_TARGET.HEAD_BACK;
//    @MovementSetting(
//            label = "Head Locked To Camera",
//            type = MovementSettingType.BOOLEAN,
//            description = "If true, player head will follow camera orientation"
//    )
    protected boolean headLockedToCamera = true;
    public boolean isHeadLockedToCamera() {
        return headLockedToCamera;
    }
    protected CameraTarget getEndTarget(PlayerEntity player, double targetDistance) {
        switch (endTarget){
            default:
            case HEAD_BACK: return CameraTarget.fromDistanceBack(player, targetDistance);
            case HEAD_FRONT: return CameraTarget.fromDistanceFront(player, targetDistance);
        }
    }
    public RaycastType getRaycastType() {
        return raycastType != null ? raycastType : RaycastType.NONE;
    }
    public void setRaycastType(RaycastType type) {
        this.raycastType = type;
    }
    public String getDisplayName() {
        return customName != null ? customName : getClass().getSimpleName();
    }
    public void setCustomName(String name) {
        this.customName = name;
    }
    public Map<String, Object> getSettings() {
        Map<String, Object> settings = new HashMap<>();
        Stream.concat(
                        Arrays.stream(this.getClass().getDeclaredFields()),
                        Arrays.stream(AbstractMovementSettings.class.getDeclaredFields())
                )
                .filter(field -> field.isAnnotationPresent(MovementSetting.class) || field.getName().equals("customName"))
                .forEach(field -> {
                    field.setAccessible(true);
                    try {
                        Object value = field.get(this);
                        if (value instanceof Enum<?>) {
                            settings.put(field.getName(), ((Enum<?>) value).name());
                        } else {
                            settings.put(field.getName(), value);
                        }
                    } catch (IllegalAccessException e) {
                        Craneshot.LOGGER.error("Error accessing field: " + field.getName(), e);
                    }
                });
        return settings;
    }
    public void updateSetting(String key, Object value) {
        try {
            if (key.equals("customName")) {
                setCustomName((String)value);
                return;
            }
            Field field = findField(key);
            if (field != null && field.isAnnotationPresent(MovementSetting.class)) {
                field.setAccessible(true);
                // Handle different field types
                if (field.getType().isEnum()) {
                    if (value instanceof String) {
                        @SuppressWarnings("unchecked")
                        Enum<?> enumValue = Enum.valueOf(field.getType().asSubclass(Enum.class), (String) value);
                        field.set(this, enumValue);
                        if (key.equals("raycastType")) {
                            setRaycastType((RaycastType)enumValue);
                        }
                    }
                } else if (field.getType() == double.class || field.getType() == Double.class) {
                    double doubleValue;
                    if (value instanceof Number) {
                        doubleValue = ((Number)value).doubleValue();
                    } else if (value instanceof String) {
                        doubleValue = Double.parseDouble((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to double");
                    }
                    field.setDouble(this, doubleValue);
                } else if (field.getType() == float.class || field.getType() == Float.class) {
                    float floatValue;
                    if (value instanceof Number) {
                        floatValue = ((Number)value).floatValue();
                    } else if (value instanceof String) {
                        floatValue = Float.parseFloat((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to float");
                    }
                    field.setFloat(this, floatValue);
                } else if (field.getType() == int.class || field.getType() == Integer.class) {
                    int intValue;
                    if (value instanceof Number) {
                        intValue = ((Number)value).intValue();
                    } else if (value instanceof String) {
                        intValue = Integer.parseInt((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to integer");
                    }
                    field.setInt(this, intValue);
                } else {
                    // Default fallback for other types
                    field.set(this, value);
                }
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Error updating setting {} with value {}: {}", key, value, e.getMessage());
        }
    }
    private Field findField(String key) {
        try {
            return this.getClass().getDeclaredField(key);
        } catch (NoSuchFieldException e) {
            try {
                return AbstractMovementSettings.class.getDeclaredField(key);
            } catch (NoSuchFieldException ex) {
                Craneshot.LOGGER.error("Field not found: {}", key);
                return null;
            }
        }
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraMovementType.java">
package ninja.trek.cameramovements;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CameraMovementType {
    String name() default "";
    String description() default "";
    boolean enabled() default true;
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraState.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.input.Input;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
public class CameraState {
    private Vec3d position;
    private float yaw;
    private float pitch;
    public CameraState(Vec3d position, float yaw, float pitch) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public static CameraState fromCamera(Camera camera) {
        return new CameraState(camera.getPos(), camera.getYaw(), camera.getPitch());
    }
    public Vec3d getPosition() { return position; }
    public float getYaw() { return yaw; }
    public float getPitch() { return pitch; }
    public CameraState lerp(CameraState other, double t) {
        Vec3d lerpedPos = this.position.lerp(other.position, t);
        float lerpedYaw = lerpAngle(this.yaw, other.yaw, (float)t);
        float lerpedPitch = lerpAngle(this.pitch, other.pitch, (float)t);
        return new CameraState(lerpedPos, lerpedYaw, lerpedPitch);
    }
    private float lerpAngle(float start, float end, float t) {
        float diff = end - start;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return start + diff * t;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraTarget.java">
package ninja.trek.cameramovements;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.Craneshot;
public class CameraTarget {
    private Vec3d position;
    private float yaw;
    private float pitch;
    public CameraTarget(Vec3d position, float yaw, float pitch) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public CameraTarget() {
        position = new Vec3d(0,0,0);
    }
    public static CameraTarget fromCamera(Camera camera) {
        return new CameraTarget(camera.getPos(), camera.getYaw(), camera.getPitch());
    }
    public static CameraTarget fromDistanceBack(PlayerEntity player, double distance) {
        double yaw = Math.toRadians(player.getYaw());// + Math.toRadians((180));
        double pitch = Math.toRadians(player.getPitch());
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * distance;
        double yOffset = Math.sin(pitch) * distance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * distance;
        Vec3d targetPos = player.getEyePos().add(xOffset, yOffset, zOffset);
        return new CameraTarget(targetPos, player.getYaw(), player.getPitch());
    }
    public static CameraTarget fromDistanceFront(PlayerEntity player, double distance) {
        double yaw = Math.toRadians(player.getYaw() + 180); // Add 180 degrees to face front
        double pitch = Math.toRadians(-player.getPitch()); // Invert the pitch angle
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * distance;
        double yOffset = Math.sin(pitch) * distance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * distance;
        Vec3d targetPos = player.getEyePos().add(xOffset, yOffset, zOffset);
        return new CameraTarget(targetPos, player.getYaw() + 180, -player.getPitch());
    }
    public Vec3d getPosition() {
        return position;
    }
    public float getYaw() {
        return yaw;
    }
    public float getPitch() {
        return pitch;
    }
    public CameraTarget withAdjustedPosition(PlayerEntity player, RaycastType raycastType) {
//        Craneshot.LOGGER.info("withAdjustedPosition called with raycastType: {}", this.raycastType);
        Vec3d adjustedPos = RaycastUtil.adjustForCollision(player.getEyePos(), this.position, raycastType);
        return new CameraTarget(adjustedPos, this.yaw, this.pitch);
    }
    public void set(Vec3d v, float yaw, float pitch) {
        position = v;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public void set(CameraTarget t) {
        position = t.position;
        this.pitch = t.pitch;
        this.yaw = t.yaw;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/ICameraMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
public interface ICameraMovement {
    void start(MinecraftClient client, Camera camera);
    MovementState calculateState(MinecraftClient client, Camera camera);
    void queueReset(MinecraftClient client, Camera camera);
    void adjustDistance(boolean increase);
    String getName();
    float getWeight(); // For blending calculations
    boolean isComplete(); // To determine if movement should be removed
    RaycastType getRaycastType();
    default boolean hasCompletedOutPhase() { return false; }
}
</file>

<file path="client/java/ninja/trek/cameramovements/movements/BezierMovement.java">
package ninja.trek.cameramovements.movements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import ninja.trek.Craneshot;
import ninja.trek.CraneshotClient;
import ninja.trek.CameraController;
import ninja.trek.cameramovements.*;
import ninja.trek.config.MovementSetting;
@CameraMovementType(
        name = "Bezier",
        description = "Moves the camera in a curved line"
)
public class BezierMovement extends AbstractMovementSettings implements ICameraMovement {
    // --- Settings ---
    @MovementSetting(label = "Position Easing", min = 0.01, max = 1.0)
    private double positionEasing = 0.1;
    @MovementSetting(label = "Position Speed Limit", min = 0.1, max = 100.0)
    private double positionSpeedLimit = 10;
    @MovementSetting(label = "Rotation Easing", min = 0.01, max = 1.0)
    private double rotationEasing = 0.1;
    @MovementSetting(label = "Rotation Speed Limit", min = 0.1, max = 1000)
    private double rotationSpeedLimit = 500;
    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10.0;
    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0;
    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0;
    @MovementSetting(label = "Control Point Displacement", min = 0.0, max = 30)
    private double controlPointDisplacement = 5;
    @MovementSetting(label = "Displacement Angle", min = -180.0, max = 180.0)
    private double displacementAngle = 0.0;
    @MovementSetting(label = "Displacement Angle Variance", min = 0.0, max = 180.0)
    private double displacementAngleVariance = 0.0;
    // --- Internal fields for the canonical Bézier path ---
    private Vec3d canonicalStart;
    private Vec3d canonicalEnd;
    private Vec3d canonicalControl;
    private Vec3d originalCanonicalStart;
    // Store the control stick's original position and orientation
    private Vec3d originalStickPosition;
    private float originalStickYaw;
    private float originalStickPitch;
    private double progress;
    private boolean resetting = false;
    private boolean linearMode = false;
    private boolean distanceChanged = false;
    private float weight = 1.0f;
    private CameraTarget current;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        // Capture the control stick's position and rotation at the start
        Vec3d stickPosition = CameraController.controlStick.getPosition();
        float stickYaw = CameraController.controlStick.getYaw();
        float stickPitch = CameraController.controlStick.getPitch();
        // Save these original parameters
        originalStickPosition = stickPosition;
        originalStickYaw = stickYaw;
        originalStickPitch = stickPitch;
        // Get the camera's current (absolute) position
        Vec3d absStart = CameraTarget.fromCamera(camera).getPosition();
        // Determine the desired end target
        CameraTarget camEndTarget = getEndTarget(client.player, targetDistance);
        Vec3d absEnd = camEndTarget.getPosition();
        // Convert the offsets (relative to the stick) into canonical space
        canonicalStart = unrotateVectorByYawPitch(absStart.subtract(stickPosition), stickYaw, stickPitch);
        canonicalEnd = unrotateVectorByYawPitch(absEnd.subtract(stickPosition), stickYaw, stickPitch);
        // Save the original canonical start for use in the reset
        originalCanonicalStart = canonicalStart;
        // Compute the control point for the Bézier curve
        canonicalControl = generateControlPoint(canonicalStart, canonicalEnd);
        progress = 0.0;
        resetting = false;
        linearMode = false;
        distanceChanged = false;
        // Set the initial camera target
        Vec3d desiredPos = stickPosition.add(rotateVectorByYawPitch(canonicalStart, stickYaw, stickPitch));
        current = new CameraTarget(desiredPos, stickYaw, stickPitch);
        weight = 1.0f;
    }
    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        if (linearMode) Craneshot.LOGGER.info("linear");
        // Get current control stick state
        Vec3d stickPosition = CameraController.controlStick.getPosition();
        float stickYaw = CameraController.controlStick.getYaw();
        float stickPitch = CameraController.controlStick.getPitch();
        // Determine canonical endpoints
        Vec3d startCanon, endCanon;
        if (!resetting) {
            startCanon = canonicalStart;
            endCanon = canonicalEnd;
        } else {
            startCanon = canonicalEnd;
            endCanon = originalCanonicalStart;
        }
        double totalDistance = startCanon.distanceTo(endCanon);
        Vec3d desiredCanonical;
        if (!linearMode) {
            // --- Bezier movement mode ---
            double potentialDelta = (1.0 - progress) * positionEasing;
            double maxMove = positionSpeedLimit * (1.0 / 20.0);
            double allowedDelta = totalDistance > 0 ? maxMove / totalDistance : potentialDelta;
            double progressDelta = Math.min(potentialDelta, allowedDelta);
            progress = Math.min(1.0, progress + progressDelta);
            desiredCanonical = quadraticBezier(startCanon, canonicalControl, endCanon, progress);
        } else {
            // --- Linear movement mode ---
            Vec3d currentCanon = unrotateVectorByYawPitch(
                    current.getPosition().subtract(stickPosition),
                    stickYaw,
                    stickPitch
            );
            Vec3d delta = endCanon.subtract(currentCanon);
            double deltaLength = delta.length();
            double maxMove = positionSpeedLimit * (1.0 / 20.0);
            Vec3d move;
            if (deltaLength > 0) {
                move = delta.multiply(positionEasing);
                if (move.length() > maxMove) {
                    move = move.normalize().multiply(maxMove);
                }
            } else {
                move = Vec3d.ZERO;
            }
            desiredCanonical = currentCanon.add(move);
        }
        // Convert back to world space using control stick position and rotation
        Vec3d desiredAbs = stickPosition.add(
                rotateVectorByYawPitch(desiredCanonical, stickYaw, stickPitch)
        );
        // Rotation easing
        float targetYaw, targetPitch;
        if (!resetting && this.endTarget == END_TARGET.HEAD_FRONT) {
            targetYaw = stickYaw + 180f;
            targetPitch = -stickPitch;
        } else {
            targetYaw = stickYaw;
            targetPitch = stickPitch;
        }
        float yawError = targetYaw - current.getYaw();
        float pitchError = targetPitch - current.getPitch();
        while (yawError > 180) yawError -= 360;
        while (yawError < -180) yawError += 360;
        float desiredYawSpeed = (float)(yawError * rotationEasing);
        float desiredPitchSpeed = (float)(pitchError * rotationEasing);
        float maxRotation = (float)(rotationSpeedLimit * (1.0 / 20.0));
        if (Math.abs(desiredYawSpeed) > maxRotation) {
            desiredYawSpeed = Math.signum(desiredYawSpeed) * maxRotation;
        }
        if (Math.abs(desiredPitchSpeed) > maxRotation) {
            desiredPitchSpeed = Math.signum(desiredPitchSpeed) * maxRotation;
        }
        float newYaw = current.getYaw() + desiredYawSpeed;
        float newPitch = current.getPitch() + desiredPitchSpeed;
        current = new CameraTarget(desiredAbs, newYaw, newPitch);
        // Update alpha for external systems
        double remaining = desiredCanonical.distanceTo(endCanon);
        alpha = totalDistance != 0 ? remaining / totalDistance : 0.0;
        // Switch to linear mode when out phase completes
        if (!resetting && progress >= 0.999) {
            linearMode = true;
            canonicalStart = unrotateVectorByYawPitch(
                    current.getPosition().subtract(stickPosition),
                    stickYaw,
                    stickPitch
            );
            Vec3d endPos = getEndTarget(client.player, targetDistance).getPosition();
            canonicalEnd = unrotateVectorByYawPitch(
                    endPos.subtract(stickPosition),
                    stickYaw,
                    stickPitch
            );
        }
        boolean complete = resetting && progress >= 0.999;
        return new MovementState(current, complete);
    }
    // Rest of the helper methods remain largely unchanged, just updating documentation
    // to reflect that we're using control stick instead of player position
    private Vec3d quadraticBezier(Vec3d p0, Vec3d p1, Vec3d p2, double t) {
        double oneMinusT = 1.0 - t;
        return p0.multiply(oneMinusT * oneMinusT)
                .add(p1.multiply(2 * oneMinusT * t))
                .add(p2.multiply(t * t));
    }
    private Vec3d generateControlPoint(Vec3d start, Vec3d end) {
        Vec3d mid = start.add(end).multiply(0.5);
        Vec3d diff = end.subtract(start);
        if (diff.lengthSquared() < 1e-6) {
            return mid.add(new Vec3d(0, controlPointDisplacement, 0));
        }
        Vec3d tangent = diff.normalize();
        Vec3d worldUp = new Vec3d(0, 1, 0);
        Vec3d projectedUp = worldUp.subtract(tangent.multiply(worldUp.dotProduct(tangent)));
        if (projectedUp.lengthSquared() < 1e-6) {
            Vec3d arbitrary = new Vec3d(1, 0, 0);
            projectedUp = arbitrary.subtract(tangent.multiply(arbitrary.dotProduct(tangent)));
        }
        projectedUp = projectedUp.normalize();
        if (projectedUp.y > 0) {
            projectedUp = projectedUp.multiply(-1);
        }
        double randomOffset = (Math.random() * 2 - 1) * displacementAngleVariance;
        double angleDegrees = displacementAngle + randomOffset;
        double angleRadians = Math.toRadians(angleDegrees);
        Vec3d rotatedUp = projectedUp.multiply(Math.cos(angleRadians))
                .add(tangent.crossProduct(projectedUp).multiply(Math.sin(angleRadians)));
        Vec3d offset = rotatedUp.multiply(controlPointDisplacement);
        return mid.add(offset);
    }
    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        if (!resetting) {
            resetting = true;
            linearMode = false;
            progress = 1.0 - progress;
            canonicalControl = generateControlPoint(canonicalEnd, originalCanonicalStart);
        }
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? 1.1 : 0.9;
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
        if (linearMode) {
            distanceChanged = true;
        }
    }
    private Vec3d rotateVectorByYawPitch(Vec3d canonical, float yaw, float pitch) {
        double yawRad = Math.toRadians(yaw);
        double pitchRad = Math.toRadians(pitch);
        Vec3d forward = new Vec3d(
                -Math.sin(yawRad) * Math.cos(pitchRad),
                -Math.sin(pitchRad),
                Math.cos(yawRad) * Math.cos(pitchRad)
        );
        Vec3d right = new Vec3d(
                Math.cos(yawRad),
                0,
                Math.sin(yawRad)
        );
        Vec3d up = right.crossProduct(forward);
        return right.multiply(canonical.x)
                .add(up.multiply(canonical.y))
                .add(forward.multiply(canonical.z));
    }
    private Vec3d unrotateVectorByYawPitch(Vec3d worldVec, float yaw, float pitch) {
        double yawRad = Math.toRadians(yaw);
        double pitchRad = Math.toRadians(pitch);
        Vec3d forward = new Vec3d(
                -Math.sin(yawRad) * Math.cos(pitchRad),
                -Math.sin(pitchRad),
                Math.cos(yawRad) * Math.cos(pitchRad)
        );
        Vec3d right = new Vec3d(
                Math.cos(yawRad),
                0,
                Math.sin(yawRad)
        );
        Vec3d up = right.crossProduct(forward);
        double xCanonical = worldVec.dotProduct(right);
        double yCanonical = worldVec.dotProduct(up);
        double zCanonical = worldVec.dotProduct(forward);
        return new Vec3d(xCanonical, yCanonical, zCanonical);
    }
    @Override
    public String getName() {
        return "Bezier";
    }
    @Override
    public float getWeight() {
        return weight;
    }
    @Override
    public boolean isComplete() {
        return resetting && progress >= 0.999;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/movements/LinearMovement.java">
package ninja.trek.cameramovements.movements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import ninja.trek.CameraController;
import ninja.trek.Craneshot;
import ninja.trek.CraneshotClient;
import ninja.trek.cameramovements.*;
import ninja.trek.config.MovementSetting;
@CameraMovementType(
        name = "Linear",
        description = "Moves the camera along a line"
)
public class LinearMovement extends AbstractMovementSettings implements ICameraMovement {
    @MovementSetting(label = "Position Easing", min = 0.01, max = 1.0)
    private double positionEasing = 0.1;
    @MovementSetting(label = "Position Speed Limit", min = 0.1, max = 100.0)
    private double positionSpeedLimit = 2.0;
    @MovementSetting(label = "Rotation Easing", min = 0.01, max = 1.0)
    private double rotationEasing = 0.1;
    @MovementSetting(label = "Rotation Speed Limit", min = 0.1, max = 3600.0)
    private double rotationSpeedLimit = 45.0;
    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10.0;
    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0;
    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0;
    public CameraTarget start = new CameraTarget();
    public CameraTarget end = new CameraTarget();
    public CameraTarget current = new CameraTarget();
    private boolean resetting = false;
    private float weight = 1.0f;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        // Initialize with camera's current state
        start = CameraTarget.fromCamera(camera);
        current = CameraTarget.fromCamera(camera);
        // Calculate end target based on controlStick
        Vec3d targetPos = calculateTargetPosition(CameraController.controlStick);
        end = new CameraTarget(targetPos, CameraController.controlStick.getYaw(), CameraController.controlStick.getPitch());
        resetting = false;
        weight = 1.0f;
    }
    private Vec3d calculateTargetPosition(CameraTarget stick) {
        double yaw = Math.toRadians(stick.getYaw());
        double pitch = Math.toRadians(stick.getPitch());
        // Calculate offset based on target distance
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * targetDistance;
        double yOffset = Math.sin(pitch) * targetDistance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * targetDistance;
        return stick.getPosition().add(xOffset, yOffset, zOffset);
    }
    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        if (client.player == null) return new MovementState(current, true);
//        Craneshot.LOGGER.info("linear update");
        // Update start target with controlStick's current state
        start = new CameraTarget(
                CameraController.controlStick.getPosition(),
                CameraController.controlStick.getYaw(),
                CameraController.controlStick.getPitch()
        );
        // Update end target based on controlStick and target distance
        Vec3d targetPos = calculateTargetPosition(CameraController.controlStick);
        end = new CameraTarget(targetPos, CameraController.controlStick.getYaw(), CameraController.controlStick.getPitch());
        CameraTarget a = resetting ? end : start;
        CameraTarget b = resetting ? start : end;
        // Position interpolation with speed limit
        Vec3d desired = current.getPosition().lerp(b.getPosition(), positionEasing);
        Vec3d moveVector = desired.subtract(current.getPosition());
        double moveDistance = moveVector.length();
        if (moveDistance > 0.01) {
            double maxMove = positionSpeedLimit * (1.0/20.0); // Convert blocks/second to blocks/tick
            if (moveDistance > maxMove) {
                Vec3d limitedMove = moveVector.normalize().multiply(maxMove);
                desired = current.getPosition().add(limitedMove);
            }
        }
        // Rotation interpolation with speed limit
        float targetYaw = b.getYaw();
        float targetPitch = b.getPitch();
        float yawDiff = targetYaw - current.getYaw();
        float pitchDiff = targetPitch - current.getPitch();
        // Normalize angles to [-180, 180]
        while (yawDiff > 180) yawDiff -= 360;
        while (yawDiff < -180) yawDiff += 360;
        // Apply easing to get desired rotation speed
        float desiredYawSpeed = (float)(yawDiff * rotationEasing);
        float desiredPitchSpeed = (float)(pitchDiff * rotationEasing);
        // Apply rotation speed limit
        float maxRotation = (float)(rotationSpeedLimit * (1.0/20.0));
        if (Math.abs(desiredYawSpeed) > maxRotation) {
            desiredYawSpeed = Math.signum(desiredYawSpeed) * maxRotation;
        }
        if (Math.abs(desiredPitchSpeed) > maxRotation) {
            desiredPitchSpeed = Math.signum(desiredPitchSpeed) * maxRotation;
        }
        // Apply the final rotation
        float newYaw = current.getYaw() + desiredYawSpeed;
        float newPitch = current.getPitch() + desiredPitchSpeed;
        current = new CameraTarget(desired, newYaw, newPitch);
        // Calculate progress for blending
        alpha = current.getPosition().distanceTo(b.getPosition()) /
                a.getPosition().distanceTo(b.getPosition());
        boolean complete = resetting && moveDistance < 0.01;
        return new MovementState(current, complete);
    }
    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        if (client.player == null) return;
        resetting = true;
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? 1.1 : 0.9;
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
    }
    @Override
    public String getName() {
        return "Linear";
    }
    @Override
    public float getWeight() {
        return weight;
    }
    @Override
    public boolean isComplete() {
        return resetting && current.getPosition().distanceTo(start.getPosition()) < 0.01;
    }
    @Override
    public boolean hasCompletedOutPhase() {
        return !resetting && current.getPosition().distanceTo(end.getPosition()) < 0.01;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/MovementState.java">
package ninja.trek.cameramovements;
public class MovementState {
    private final CameraTarget target;
    private final boolean isComplete;
    public MovementState(CameraTarget target, boolean isComplete) {
        this.target = target;
        this.isComplete = isComplete;
    }
    public CameraTarget getCameraTarget() {
        return target;
    }
    public boolean isComplete() {
        return isComplete;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/RaycastType.java">
package ninja.trek.cameramovements;
/**
 * Enum defining different raycast behaviors for camera collision handling
 */
public enum RaycastType {
    /**
     * No raycast collision checking - camera can clip through blocks
     */
    NONE,
    /**
     * Raycasts from player to desired camera position.
     * If collision detected, moves camera closer to player.
     * Behaves like default Minecraft third person camera.
     */
    NEAR,
    /**
     * Raycasts from desired camera position towards player.
     * If camera would be inside block, moves it to first non-solid position.
     * Provides more stable distant shots by preferring to keep camera far out.
     */
    FAR
}
</file>

<file path="client/java/ninja/trek/cameramovements/RaycastUtil.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.RaycastContext;
public class RaycastUtil {
    private static final double CAMERA_OFFSET = 0.5;
    private static final double STEP_SIZE = 0.5;
    private static final double FINE_STEP_SIZE = 0.1;
    public static Vec3d adjustForCollision(Vec3d playerPos, Vec3d targetPos, RaycastType raycastType) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.world == null || raycastType == RaycastType.NONE) {
            return targetPos;
        }
        switch (raycastType) {
            case NEAR:
                return handleNearRaycast(client, playerPos, targetPos);
            case FAR:
                return handleFarRaycast(client, playerPos, targetPos);
            default:
                return targetPos;
        }
    }
    private static Vec3d handleNearRaycast(MinecraftClient client, Vec3d playerPos, Vec3d targetPos) {
        BlockHitResult hit = client.world.raycast(new RaycastContext(
                playerPos,
                targetPos,
                RaycastContext.ShapeType.VISUAL,
                RaycastContext.FluidHandling.NONE,
                client.player
        ));
        if (hit.getType() == HitResult.Type.BLOCK) {
            Vec3d hitPos = hit.getPos();
            Vec3d directionVector = hitPos.subtract(playerPos).normalize();
            return hitPos.subtract(directionVector.multiply(CAMERA_OFFSET));
        }
        return targetPos;
    }
    private static Vec3d handleFarRaycast(MinecraftClient client, Vec3d playerPos, Vec3d targetPos) {
        Vec3d direction = targetPos.subtract(playerPos).normalize();
        double totalDistance = targetPos.distanceTo(playerPos);
        // Start from target position
        Vec3d currentPos = targetPos;
        if (isPositionInAir(client, currentPos)) {
            return refinePosition(client, currentPos, direction);
        }
        // Coarse search
        for (double distance = STEP_SIZE; distance < totalDistance; distance += STEP_SIZE) {
            Vec3d checkPos = targetPos.subtract(direction.multiply(distance));
            if (isPositionInAir(client, checkPos)) {
                return refinePosition(client, checkPos, direction.multiply(-1));
            }
        }
        return playerPos;
    }
    private static Vec3d refinePosition(MinecraftClient client, Vec3d startPos, Vec3d direction) {
        // Raycast forward until we hit something
        BlockHitResult hit = client.world.raycast(new RaycastContext(
                startPos,
                startPos.add(direction.multiply(2.0)), // Look 2 blocks ahead
                RaycastContext.ShapeType.VISUAL,
                RaycastContext.FluidHandling.NONE,
                client.player
        ));
        if (hit.getType() == HitResult.Type.BLOCK) {
            Vec3d hitPos = hit.getPos();
            return hitPos.subtract(direction.multiply(CAMERA_OFFSET));
        }
        return startPos;
    }
    private static boolean isPositionInAir(MinecraftClient client, Vec3d pos) {
        BlockPos blockPos = BlockPos.ofFloored(pos);
        return client.world.getBlockState(blockPos).isAir();
    }
}
</file>

<file path="client/java/ninja/trek/CraneshotClient.java">
package ninja.trek;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.client.util.InputUtil;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.config.GeneralSettingsIO;
import ninja.trek.config.MenuOverlayScreen;
import ninja.trek.config.SlotSettingsIO;
import org.lwjgl.glfw.GLFW;
import java.util.List;
public class CraneshotClient implements ClientModInitializer {
	public static KeyBinding[] cameraKeyBinds;
	public static KeyBinding selectMovementType;
	public static final CameraController CAMERA_CONTROLLER = new CameraController();
	public static KeyBinding toggleMenuKey;
	private static boolean isMenuOpen = false;
	public static MenuOverlayScreen MENU = new MenuOverlayScreen();
	public static final CameraMovementManager MOVEMENT_MANAGER = new CameraMovementManager();
	@Override
	public void onInitializeClient() {
		toggleMenuKey = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.toggle_menu",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_Z,
				"category.craneshot.ui"
		));
		selectMovementType = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.select_movement",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_X,
				"category.craneshot.camera"
		));
		cameraKeyBinds = new KeyBinding[]{
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera1",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_C,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera2",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_V,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera3",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_B,
						"category.craneshot.camera"
				))
		};
		CameraMovementRegistry.initialize();
		GeneralSettingsIO.loadSettings();
		List<List<ICameraMovement>> savedSlots = SlotSettingsIO.loadSlots();
		MOVEMENT_MANAGER.setAllSlots(savedSlots);
		CraneShotEventHandler.register();
	}
	public static void checkKeybinds() {
		if (toggleMenuKey.wasPressed()) {
			MENU.toggleMenu();
		}
	}
}
</file>

<file path="client/java/ninja/trek/CraneshotDataGenerator.java">
package ninja.trek;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class CraneshotDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/java/ninja/trek/CraneShotEventHandler.java">
package ninja.trek;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;
import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.text.Text;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.config.SlotMenuSettings;
import ninja.trek.mixin.client.MouseAccessor;
import java.util.HashMap;
import java.util.Map;
/**
 * Handles client tick, HUD rendering, and world render events.
 * This class delegates key and scroll input to the movement manager and camera controller.
 */
public class CraneShotEventHandler {
    private static final double SCROLL_COOLDOWN = 0.1;
    private static double lastScrollTime = 0;
    private static final Map<Integer, Boolean> keyStates = new HashMap<>();
    public static void register() {
        // Register client tick event for input handling.
        ClientTickEvents.END_CLIENT_TICK.register(client -> {
            handleScrollInput(client);
            CraneshotClient.checkKeybinds();
        });
        // Register HUD rendering for on-screen messages.
        HudRenderCallback.EVENT.register((context, tickDelta) -> {
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.player != null && CraneshotClient.CAMERA_CONTROLLER.hasActiveMessage()) {
                String message = CraneshotClient.CAMERA_CONTROLLER.getCurrentMessage();
                int width = client.getWindow().getScaledWidth();
                context.drawTextWithShadow(
                        client.textRenderer,
                        Text.literal(message),
                        width / 2 - client.textRenderer.getWidth(message) / 2,
                        60,
                        0xFFFFFF
                );
            }
        });
        // Register world render event to update camera and handle key state changes.
        WorldRenderEvents.START.register(context -> {
            MinecraftClient client = MinecraftClient.getInstance();
            Camera camera = client.gameRenderer.getCamera();
            // Process each key binding state.
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                boolean currentlyPressed = CraneshotClient.cameraKeyBinds[i].isPressed();
                boolean wasPressed = keyStates.getOrDefault(i, false);
                // Only act on changes in state.
                if (currentlyPressed != wasPressed) {
                    boolean isToggle = SlotMenuSettings.getToggleState(i);
                    // Delegate key state handling to the movement manager.
                    CraneshotClient.MOVEMENT_MANAGER.handleKeyStateChange(i, currentlyPressed, client, camera, isToggle);
                }
                keyStates.put(i, currentlyPressed);
            }
        });
    }
    /**
     * Processes mouse scroll input. When the "select movement type" key is pressed,
     * the scroll wheel cycles the current movement type. Otherwise, scroll
     * events are used to adjust the distance of the active movement.
     */
    private static void handleScrollInput(MinecraftClient client) {
        double currentTime = System.currentTimeMillis() / 1000.0;
        if (currentTime - lastScrollTime < SCROLL_COOLDOWN) {
            return;
        }
        MouseAccessor mouseAccessor = (MouseAccessor) client.mouse;
        double scrollDelta = mouseAccessor.getEventDeltaVerticalWheel();
        if (scrollDelta == 0) {
            return;
        }
        boolean scrollUp = scrollDelta > 0;
        // If the movement type selector key is pressed, cycle movement types.
        if (CraneshotClient.selectMovementType.isPressed()) {
            CraneshotClient.MOVEMENT_MANAGER.cycleMovementType(scrollUp);
            // Optionally display a message showing the active movement type.
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    ICameraMovement movement = CraneshotClient.MOVEMENT_MANAGER.getMovementAt(i);
                    if (movement != null) {
                        CraneshotClient.CAMERA_CONTROLLER.showMessage(
                                "Camera " + (i + 1) + ": " + movement.getName() + " Movement"
                        );
                    }
                    break;
                }
            }
            lastScrollTime = currentTime;
            mouseAccessor.setEventDeltaVerticalWheel(0);
        }
        // Otherwise, use the scroll to adjust the distance parameter.
        else {
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    CraneshotClient.MOVEMENT_MANAGER.adjustDistance(i, !scrollUp);
                    lastScrollTime = currentTime;
                    mouseAccessor.setEventDeltaVerticalWheel(0);
                    break;
                }
            }
        }
    }
}
</file>

<file path="client/java/ninja/trek/IKeyboardInputMixin.java">
package ninja.trek;
public interface IKeyboardInputMixin {
    void setDisabled(boolean disabled);
}
</file>

<file path="client/java/ninja/trek/IMouseMixin.java">
package ninja.trek;
public interface IMouseMixin {
    double getCapturedDeltaX();
    double getCapturedDeltaY();
}
</file>

<file path="client/java/ninja/trek/mixin/client/CameraAccessor.java">
package ninja.trek.mixin.client;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.BlockView;
import ninja.trek.CraneshotClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import org.spongepowered.asm.mixin.gen.Invoker;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
// CameraAccessor.java
@Mixin(Camera.class)
public interface CameraAccessor {
    @Accessor("pos")
    void invokesetPos(Vec3d pos);
    @Accessor("pos")
    Vec3d getPos();
    @Invoker("setRotation")
    void invokeSetRotation(float yaw, float pitch);
}
</file>

<file path="client/java/ninja/trek/mixin/client/CameraMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.Entity;
import net.minecraft.world.BlockView;
import ninja.trek.CraneshotClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
// CameraMixin.java
@Mixin(Camera.class)
public class CameraMixin {
    @Inject(method = "update", at = @At("TAIL"))
    private void onCameraUpdate(BlockView area, Entity focusedEntity, boolean thirdPerson,
                                boolean inverseView, float tickDelta, CallbackInfo ci) {
        CraneshotClient.CAMERA_CONTROLLER.handleCameraUpdate(area, focusedEntity, thirdPerson, inverseView, tickDelta, (Camera)(Object)this);
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/ExampleClientMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/mixin/client/KeyboardInputMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.input.Input;
import net.minecraft.client.input.KeyboardInput;
import ninja.trek.IKeyboardInputMixin;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(KeyboardInput.class)
public abstract class KeyboardInputMixin extends Input implements IKeyboardInputMixin {
    private boolean disabled = false;
    private float savedForward, savedSideways;
    private boolean savedJumping, savedSneaking;
    private boolean savedSprinting;  // Add sprinting state
    @Override
    public void setDisabled(boolean disabled) {
        if (this.disabled != disabled) {
            if (disabled) {
                // Store current state when disabling
                this.savedForward = this.movementForward;
                this.savedSideways = this.movementSideways;
                this.savedJumping = this.jumping;
                this.savedSneaking = this.sneaking;
                // Immediately clear all movement
                this.movementForward = 0;
                this.movementSideways = 0;
                this.jumping = false;
                this.sneaking = false;
            }
            this.disabled = disabled;
        }
    }
    @Inject(method = "tick", at = @At("HEAD"), cancellable = true)
    private void onTick(boolean slowDown, float slowDownFactor, CallbackInfo ci) {
        if (disabled) {
            // Force all movement values to zero
            this.movementForward = 0;
            this.movementSideways = 0;
            this.jumping = false;
            this.sneaking = false;
            ci.cancel();
        } else {
            // Restore saved state when not disabled
            this.movementForward = savedForward;
            this.movementSideways = savedSideways;
            this.jumping = savedJumping;
            this.sneaking = savedSneaking;
        }
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseAccessor.java">
package ninja.trek.mixin.client;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import net.minecraft.client.Mouse;
@Mixin(Mouse.class)
public interface MouseAccessor {
    @Accessor("cursorDeltaX")
    double getCursorDeltaX();
    @Accessor("cursorDeltaY")
    double getCursorDeltaY();
    @Accessor("cursorDeltaX")
    void setCursorDeltaX(double value);
    @Accessor("cursorDeltaY")
    void setCursorDeltaY(double value);
    @Accessor("eventDeltaVerticalWheel")
    double getEventDeltaVerticalWheel();
    @Accessor("eventDeltaVerticalWheel")
    void setEventDeltaVerticalWheel(double value);
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.Mouse;
import ninja.trek.IMouseMixin;
import ninja.trek.MouseInterceptor;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(Mouse.class)
public class MouseMixin implements IMouseMixin {
    @Shadow private double cursorDeltaX;
    @Shadow private double cursorDeltaY;
    private double capturedDeltaX;
    private double capturedDeltaY;
    @Inject(method = "updateMouse", at = @At("HEAD"), cancellable = true)
    private void onUpdateMouse(CallbackInfo ci) {
        MinecraftClient client = MinecraftClient.getInstance();
        // Only intercept mouse movement if we're intercepting AND not in a screen
        if (MouseInterceptor.isIntercepting() && client.currentScreen == null) {
            capturedDeltaX = cursorDeltaX;
            capturedDeltaY = cursorDeltaY;
            cursorDeltaX = 0;
            cursorDeltaY = 0;
            ci.cancel();
        }
    }
    @Inject(method = "onMouseButton", at = @At("HEAD"), cancellable = true)
    private void onMouseButton(long window, int button, int action, int mods, CallbackInfo ci) {
        MinecraftClient client = MinecraftClient.getInstance();
        // Only intercept mouse clicks if we're intercepting AND not in a screen
        if (MouseInterceptor.isIntercepting() && client.currentScreen == null) {
            ci.cancel();
        }
    }
    @Override
    public double getCapturedDeltaX() {
        return capturedDeltaX;
    }
    @Override
    public double getCapturedDeltaY() {
        return capturedDeltaY;
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/TransparencyMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.network.AbstractClientPlayerEntity;
import net.minecraft.client.render.RenderLayer;
import net.minecraft.client.render.VertexConsumer;
import net.minecraft.client.render.VertexConsumerProvider;
import net.minecraft.client.render.entity.PlayerEntityRenderer;
import net.minecraft.client.render.item.HeldItemRenderer;
import net.minecraft.client.render.model.json.ModelTransformationMode;
import net.minecraft.client.util.math.MatrixStack;
import net.minecraft.entity.LivingEntity;
import net.minecraft.item.ItemStack;
import net.minecraft.util.Arm;
import ninja.trek.CameraController;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.ModifyVariable;
public class TransparencyMixin {
    @Mixin(PlayerEntityRenderer.class)
    public static class PlayerMixin {
        @ModifyVariable(method = "render", at = @At("HEAD"), ordinal = 0)
        private VertexConsumerProvider modifyVertexConsumer(VertexConsumerProvider vertexConsumers,
                                                            AbstractClientPlayerEntity player, float yaw, float tickDelta,
                                                            MatrixStack matrices, VertexConsumerProvider originalVertexConsumers, int light) {
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.gameRenderer.getCamera() == null) return originalVertexConsumers;
            double distance = client.gameRenderer.getCamera().getPos().distanceTo(player.getEyePos());
            float alpha;
            if (distance <= CameraController.FIRST_PERSON_THRESHOLD_MIN) {
                alpha = 0.0f;
            } else if (distance >= CameraController.FIRST_PERSON_THRESHOLD_MAX) {
                alpha = 1.0f;
            } else {
                alpha = (float) ((distance - CameraController.FIRST_PERSON_THRESHOLD_MIN) /
                        (CameraController.FIRST_PERSON_THRESHOLD_MAX - CameraController.FIRST_PERSON_THRESHOLD_MIN));
            }
            return new VertexConsumerProvider() {
                @Override
                public VertexConsumer getBuffer(RenderLayer renderLayer) {
                    if (renderLayer.equals(RenderLayer.getEntitySolid(player.getSkinTextures().texture()))) {
                        RenderLayer translucentLayer = RenderLayer.getEntityTranslucent(
                                player.getSkinTextures().texture(), true);
                        return new TranslucentVertexConsumer(originalVertexConsumers.getBuffer(translucentLayer), alpha);
                    }
                    return originalVertexConsumers.getBuffer(renderLayer);
                }
            };
        }
    }
    @Mixin(HeldItemRenderer.class)
    public static class ItemMixin {
        @ModifyVariable(method = "renderArm", at = @At("HEAD"), ordinal = 0)
        private VertexConsumerProvider modifyArmVertexConsumer(VertexConsumerProvider vertexConsumers,
                                                               MatrixStack matrices, VertexConsumerProvider originalVertexConsumers, int light, Arm arm) {
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.gameRenderer.getCamera() == null || client.player == null) return originalVertexConsumers;
            double distance = client.gameRenderer.getCamera().getPos().distanceTo(client.player.getEyePos());
            float alpha = Math.max(0.0f, Math.min(1.0f,
                    (float) (distance / CameraController.FIRST_PERSON_THRESHOLD_MIN)));
            return new VertexConsumerProvider() {
                @Override
                public VertexConsumer getBuffer(RenderLayer renderLayer) {
                    if (client.player != null &&
                            renderLayer.equals(RenderLayer.getEntitySolid(client.player.getSkinTextures().texture()))) {
                        RenderLayer translucentLayer = RenderLayer.getEntityTranslucent(
                                client.player.getSkinTextures().texture(), true);
                        return new TranslucentVertexConsumer(originalVertexConsumers.getBuffer(translucentLayer), alpha);
                    }
                    return originalVertexConsumers.getBuffer(renderLayer);
                }
            };
        }
        @ModifyVariable(method = "renderItem", at = @At("HEAD"), ordinal = 0)
        private VertexConsumerProvider modifyItemVertexConsumer(VertexConsumerProvider vertexConsumers,
                                                                LivingEntity entity, ItemStack stack, ModelTransformationMode renderMode,
                                                                boolean leftHanded, MatrixStack matrices, VertexConsumerProvider originalVertexConsumers, int light) {
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.gameRenderer.getCamera() == null || client.player == null) return originalVertexConsumers;
            double distance = client.gameRenderer.getCamera().getPos().distanceTo(client.player.getEyePos());
            float alpha = Math.max(0.0f, Math.min(1.0f,
                    (float) (distance / CameraController.FIRST_PERSON_THRESHOLD_MIN)));
            return new VertexConsumerProvider() {
                @Override
                public VertexConsumer getBuffer(RenderLayer renderLayer) {
                    if (!renderLayer.toString().contains("entity")) {
                        return new TranslucentVertexConsumer(originalVertexConsumers.getBuffer(renderLayer), alpha);
                    }
                    return originalVertexConsumers.getBuffer(renderLayer);
                }
            };
        }
        @ModifyVariable(method = "renderFirstPersonItem", at = @At("HEAD"), ordinal = 0)
        private VertexConsumerProvider modifyFirstPersonItemVertexConsumer(VertexConsumerProvider vertexConsumers) {
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.gameRenderer.getCamera() == null || client.player == null) return vertexConsumers;
            double distance = client.gameRenderer.getCamera().getPos().distanceTo(client.player.getEyePos());
            float alpha = Math.max(0.0f, Math.min(1.0f,
                    (float) (distance / CameraController.FIRST_PERSON_THRESHOLD_MIN)));
            return new VertexConsumerProvider() {
                @Override
                public VertexConsumer getBuffer(RenderLayer renderLayer) {
                    if (!renderLayer.toString().contains("entity")) {
                        return new TranslucentVertexConsumer(vertexConsumers.getBuffer(renderLayer), alpha);
                    }
                    return vertexConsumers.getBuffer(renderLayer);
                }
            };
        }
    }
    private static class TranslucentVertexConsumer implements VertexConsumer {
        private final VertexConsumer parent;
        private final float alpha;
        public TranslucentVertexConsumer(VertexConsumer parent, float alpha) {
            this.parent = parent;
            this.alpha = alpha;
        }
        @Override
        public VertexConsumer vertex(float x, float y, float z) {
            return parent.vertex(x, y, z);
        }
        @Override
        public VertexConsumer color(int red, int green, int blue, int alpha) {
            return parent.color(red, green, blue, (int)(this.alpha * alpha));
        }
        @Override
        public VertexConsumer texture(float u, float v) {
            return parent.texture(u, v);
        }
        @Override
        public VertexConsumer overlay(int u, int v) {
            return parent.overlay(u, v);
        }
        @Override
        public VertexConsumer light(int u, int v) {
            return parent.light(u, v);
        }
        @Override
        public VertexConsumer normal(float x, float y, float z) {
            return parent.normal(x, y, z);
        }
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/WorldRendererMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.network.ClientPlayerEntity;
import net.minecraft.client.render.WorldRenderer;
import net.minecraft.client.render.Camera;
import net.minecraft.client.render.Frustum;
import net.minecraft.client.render.chunk.ChunkBuilder;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.util.math.ChunkSectionPos;
import ninja.trek.CameraController;
import ninja.trek.cameramovements.AbstractMovementSettings;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.*;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(WorldRenderer.class)
public abstract class WorldRendererMixin {
    @Shadow private int viewDistance;
    @Shadow private double lastCameraX;
    @Shadow private double lastCameraY;
    @Shadow private double lastCameraZ;
    private long lastUpdateTime = 0;
    private static final long UPDATE_INTERVAL = 1000; // 1 second in milliseconds
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 0
    )
    private double modifyPlayerX(double d) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            return CameraController.freeCamPosition.x;
        }
        return d;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 1
    )
    private double modifyPlayerY(double e) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            return CameraController.freeCamPosition.y;
        }
        return e;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 2
    )
    private double modifyPlayerZ(double f) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            return CameraController.freeCamPosition.z;
        }
        return f;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 3
    )
    private double modifyCameraX(double g) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            lastCameraX = CameraController.freeCamPosition.x;
            return CameraController.freeCamPosition.x;
        }
        return g;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 4
    )
    private double modifyCameraY(double h) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            lastCameraY = CameraController.freeCamPosition.y;
            return CameraController.freeCamPosition.y;
        }
        return h;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 5
    )
    private double modifyCameraZ(double l) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            lastCameraZ = CameraController.freeCamPosition.z;
            return CameraController.freeCamPosition.z;
        }
        return l;
    }
    @Inject(
            method = "setupTerrain",
            at = @At("HEAD")
    )
    private void onSetupTerrainStart(Camera camera, Frustum frustum, boolean hasForcedFrustum, boolean spectator, CallbackInfo ci) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            Vec3d freeCamPos = CameraController.freeCamPosition;
            ((CameraAccessor)camera).invokesetPos(freeCamPos);
            // Update the frustum to use the freecam position so that chunks aren't culled incorrectly.
            frustum.setPosition(freeCamPos.x, freeCamPos.y, freeCamPos.z);
            // Check if enough time has passed since last update
            long currentTime = System.currentTimeMillis();
            if (currentTime - lastUpdateTime > UPDATE_INTERVAL) {
                // Force chunk updates when camera moves significantly
                double movementThreshold = 12.0;
                double dx = Math.abs(freeCamPos.x - lastCameraX);
                double dy = Math.abs(freeCamPos.y - lastCameraY);
                double dz = Math.abs(freeCamPos.z - lastCameraZ);
                if (dx > movementThreshold || dy > movementThreshold || dz > movementThreshold) {
                    WorldRenderer worldRenderer = (WorldRenderer)(Object)this;
                    //worldRenderer.reload();
                    lastUpdateTime = currentTime;
                }
            }
        }
    }
    @Inject(
            method = "setupTerrain",
            at = @At("RETURN")
    )
    private void onSetupTerrainEnd(Camera camera, Frustum frustum, boolean hasForcedFrustum, boolean spectator, CallbackInfo ci) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            WorldRenderer worldRenderer = (WorldRenderer)(Object)this;
            worldRenderer.getChunkBuilder().setCameraPosition(CameraController.freeCamPosition);
        }
    }
    @ModifyArg(
            method = "setupTerrain",
            at = @At(
                    value = "INVOKE",
                    target = "Lnet/minecraft/client/render/chunk/ChunkBuilder;setCameraPosition(Lnet/minecraft/util/math/Vec3d;)V"
            ),
            index = 0
    )
    private Vec3d modifyChunkBuilderCameraPosition(Vec3d original) {
        if (CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT || CameraController.currentKeyMoveMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            return CameraController.freeCamPosition;
        }
        return original;
    }
//    // Redirect the call to ClientPlayerEntity#getX() in setupTerrain
//    @Redirect(
//            method = "setupTerrain",
//            at = @At(
//                    value = "INVOKE",
//                    target = "Lnet/minecraft/client/network/ClientPlayerEntity;getX()D"
//            )
//    )
//    private double redirectPlayerX(ClientPlayerEntity player) {
//        if (CameraController.inFreeControlMode) {
//            return CameraController.freeCamPosition.x;
//        }
//        return player.getX();
//    }
//
//    // Redirect the call to ClientPlayerEntity#getY() in setupTerrain
//    @Redirect(
//            method = "setupTerrain",
//            at = @At(
//                    value = "INVOKE",
//                    target = "Lnet/minecraft/client/network/ClientPlayerEntity;getY()D"
//            )
//    )
//    private double redirectPlayerY(ClientPlayerEntity player) {
//        if (CameraController.inFreeControlMode) {
//            return CameraController.freeCamPosition.y;
//        }
//        return player.getY();
//    }
//
//    // Redirect the call to ClientPlayerEntity#getZ() in setupTerrain
//    @Redirect(
//            method = "setupTerrain",
//            at = @At(
//                    value = "INVOKE",
//                    target = "Lnet/minecraft/client/network/ClientPlayerEntity;getZ()D"
//            )
//    )
//    private double redirectPlayerZ(ClientPlayerEntity player) {
//        if (CameraController.inFreeControlMode) {
//            return CameraController.freeCamPosition.z;
//        }
//        return player.getZ();
//    }
//
//    // Redirect the call to Camera#getPitch() in setupTerrain so that it uses freecam pitch
//    @Redirect(
//            method = "setupTerrain",
//            at = @At(
//                    value = "INVOKE",
//                    target = "Lnet/minecraft/client/render/Camera;getPitch()F"
//            )
//    )
//    private float redirectCameraPitch(Camera camera) {
//        if (CameraController.inFreeControlMode) {
//            return CameraController.freeCamPitch;
//        }
//        return camera.getPitch();
//    }
//
//    // Redirect the call to Camera#getYaw() in setupTerrain so that it uses freecam yaw
//    @Redirect(
//            method = "setupTerrain",
//            at = @At(
//                    value = "INVOKE",
//                    target = "Lnet/minecraft/client/render/Camera;getYaw()F"
//            )
//    )
//    private float redirectCameraYaw(Camera camera) {
//        if (CameraController.inFreeControlMode) {
//            return CameraController.freeCamYaw;
//        }
//        return camera.getYaw();
//    }
}
</file>

<file path="client/java/ninja/trek/MouseInterceptor.java">
package ninja.trek;
public class MouseInterceptor {
    private static boolean intercepting = false;
    public static void setIntercepting(boolean intercept) {
        intercepting = intercept;
    }
    public static boolean isIntercepting() {
        return intercepting;
    }
}
</file>

<file path="client/resources/craneshot.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"MouseMixin",
		"CameraAccessor",
		"CameraMixin",
		"MouseAccessor",
		"KeyboardInputMixin",
		"WorldRendererMixin"

	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/Craneshot.java">
package ninja.trek;
import net.fabricmc.api.ModInitializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Craneshot implements ModInitializer {
	public static final String MOD_ID = "craneshot";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	@Override
	public void onInitialize() {
		LOGGER.info("CraneShot Camera Mod initialized!");
	}
}
</file>

<file path="main/java/ninja/trek/mixin/ExampleMixin.java">
package ninja.trek.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/resources/craneshot.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "craneshot",
	"version": "${version}",
	"name": "craneshot",
	"description": "Advanced camera controls mod for cinematics",
	"authors": ["Me!"],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/craneshot/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": ["ninja.trek.Craneshot"],
		"client": ["ninja.trek.CraneshotClient"],
		
		"fabric-datagen": ["ninja.trek.CraneshotDataGenerator"]
	},
	"mixins": [
		"craneshot.mixins.json",
		{
			"config": "craneshot.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*",
		"fabric-key-binding-api-v1": "*"
	}
}
</file>

<file path="repomixx - cameramovements folder.bat">
repomix client/java/ninja/trek/cameraMovements --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

<file path="repomixx - ignore config.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**" --ignore **/config/**
</file>

<file path="repomixx - movements only.bat">
repomix client/java/ninja/trek/cameraMovements/movements --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
