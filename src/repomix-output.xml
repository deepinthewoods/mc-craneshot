This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-06T10:52:21.294Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/CameraController.java
client/java/ninja/trek/CameraMovementManager.java
client/java/ninja/trek/CameraMovementRegistry.java
client/java/ninja/trek/cameramovements/CameraMovementType.java
client/java/ninja/trek/cameramovements/CameraState.java
client/java/ninja/trek/cameramovements/CameraTarget.java
client/java/ninja/trek/cameramovements/ICameraMovement.java
client/java/ninja/trek/cameramovements/movements/LinearMovement.java
client/java/ninja/trek/cameramovements/MovementState.java
client/java/ninja/trek/cameramovements/RaycastType.java
client/java/ninja/trek/cameramovements/RaycastUtil.java
client/java/ninja/trek/config/AbstractMovementSettings.java
client/java/ninja/trek/config/GeneralMenuSettings.java
client/java/ninja/trek/config/GeneralSettingsIO.java
client/java/ninja/trek/config/MenuOverlayScreen.java
client/java/ninja/trek/config/MovementSetting.java
client/java/ninja/trek/config/MovementSettingType.java
client/java/ninja/trek/config/RenameModal.java
client/java/ninja/trek/config/SettingSlider.java
client/java/ninja/trek/config/SettingWidget.java
client/java/ninja/trek/config/SlotMenuSettings.java
client/java/ninja/trek/config/SlotSettingsIO.java
client/java/ninja/trek/config/TransitionMode.java
client/java/ninja/trek/config/TransitionModeManager.java
client/java/ninja/trek/config/WrapSettings.java
client/java/ninja/trek/CraneshotClient.java
client/java/ninja/trek/CraneshotDataGenerator.java
client/java/ninja/trek/CraneShotEventHandler.java
client/java/ninja/trek/mixin/client/CameraAccessor.java
client/java/ninja/trek/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/mixin/client/MouseAccessor.java
client/java/ninja/trek/mixin/client/MouseMixin.java
client/resources/craneshot.client.mixins.json
main/java/ninja/trek/Craneshot.java
main/java/ninja/trek/mixin/ExampleMixin.java
main/resources/craneshot.mixins.json
main/resources/fabric.mod.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/CameraController.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.option.Perspective;
import net.minecraft.client.render.Camera;
import ninja.trek.cameramovements.*;
import ninja.trek.cameramovements.movements.LinearMovement;
import ninja.trek.config.*;
import java.util.*;
public class CameraController {
    private List<List<ICameraMovement>> slots;
    private final ArrayList<Integer> currentTypes;
    private CameraMovementManager movementManager;
    private final Map<Integer, ICameraMovement> activeMovementSlots;
    private static final double FIRST_PERSON_THRESHOLD = 2.0;
    private ICameraMovement queuedMovement;
    private int queuedMovementSlot = -1;
    public CameraController() {
        slots = new ArrayList<>();
        currentTypes = new ArrayList<>();
        movementManager = new CameraMovementManager();
        activeMovementSlots = new HashMap<>();
        // Initialize slots ?
//        for (int i = 0; i < 3; i++) {
//            currentTypes.add(0);
//        }
    }
    public void startTransition(MinecraftClient client, Camera camera, int movementIndex) {
        ICameraMovement movement = getMovementAt(movementIndex);
        if (movement == null) return;
        switch (GeneralMenuSettings.getCurrentTransitionMode()) {
            case INTERPOLATE -> {
                ICameraMovement previousMovement = activeMovementSlots.put(movementIndex, movement);
                if (previousMovement != null) {
                    previousMovement.queueReset(client, camera);
                }
                movement.start(client, camera);
                movementManager.addMovement(movement, client, camera);
            }
            case QUEUE -> {
                boolean canStartNewMovement = activeMovementSlots.isEmpty() ||
                        (activeMovementSlots.size() == 1 &&
                                activeMovementSlots.values().iterator().next().isComplete());
                if (canStartNewMovement) {
                    clearCompletedMovements(client, camera);
                    activeMovementSlots.clear();
                    activeMovementSlots.put(movementIndex, movement);
                    movement.start(client, camera);
                    movementManager.addMovement(movement, client, camera);
                    queuedMovement = null;
                    queuedMovementSlot = -1;
                } else {
                    queuedMovement = movement;
                    queuedMovementSlot = movementIndex;
                }
            }
            case IMMEDIATE -> {
                clearAllMovements(client, camera);
                activeMovementSlots.clear();
                activeMovementSlots.put(movementIndex, movement);
                movement.start(client, camera);
                movementManager.addMovement(movement, client, camera);
            }
        }
    }
    public void tick(MinecraftClient client, Camera camera) {
        movementManager.update(client, camera);
        updatePerspective(client, camera);
        if (TransitionModeManager.getCurrentMode() == TransitionMode.QUEUE) {
            if (queuedMovement != null) {
                boolean allMovementsComplete = activeMovementSlots.values().stream()
                        .allMatch(ICameraMovement::isComplete);
                if (allMovementsComplete) {
                    clearAllMovements(client, camera);
                    activeMovementSlots.clear();
                    activeMovementSlots.put(queuedMovementSlot, queuedMovement);
                    queuedMovement.start(client, camera);
                    movementManager.addMovement(queuedMovement, client, camera);
                    queuedMovement = null;
                    queuedMovementSlot = -1;
                }
            }
        } else {
            clearCompletedMovements(client, camera);
        }
    }
    private void clearAllMovements(MinecraftClient client, Camera camera) {
        for (ICameraMovement movement : activeMovementSlots.values()) {
            movement.queueReset(client, camera);
        }
        movementManager = new CameraMovementManager();
        activeMovementSlots.clear();
    }
    public void queueFinish(MinecraftClient client, Camera camera) {
        for (ICameraMovement movement : activeMovementSlots.values()) {
            movement.queueReset(client, camera);
        }
    }
    private void clearCompletedMovements(MinecraftClient client, Camera camera) {
        Iterator<Map.Entry<Integer, ICameraMovement>> iterator = activeMovementSlots.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<Integer, ICameraMovement> entry = iterator.next();
            if (entry.getValue().isComplete()) {
                entry.getValue().queueReset(client, camera);
                iterator.remove();
            }
        }
    }
    private void updatePerspective(MinecraftClient client, Camera camera) {
        if (client.player == null) return;
        double distance = camera.getPos().distanceTo(client.player.getEyePos());
        if (distance > FIRST_PERSON_THRESHOLD &&
                client.options.getPerspective() == Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.THIRD_PERSON_BACK);
        } else if (distance < FIRST_PERSON_THRESHOLD &&
                client.options.getPerspective() != Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.FIRST_PERSON);
        }
    }
    // Movement management methods
    public void cycleMovementType(boolean forward) {
        for (Map.Entry<Integer, ICameraMovement> entry : activeMovementSlots.entrySet()) {
            int slotIndex = entry.getKey();
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            int currentType = currentTypes.get(slotIndex);
            boolean wrap = SlotMenuSettings.getWrapState(slotIndex);
            if (forward) {
                if (currentType < slotMovements.size() - 1 || wrap) {
                    currentTypes.set(slotIndex, wrap ?
                            (currentType + 1) % slotMovements.size() :
                            Math.min(currentType + 1, slotMovements.size() - 1));
                }
            } else {
                if (currentType > 0 || wrap) {
                    currentTypes.set(slotIndex, wrap ?
                            (currentType - 1 + slotMovements.size()) % slotMovements.size() :
                            Math.max(currentType - 1, 0));
                }
            }
        }
    }
    public void adjustDistance(int index, boolean increase) {
        ICameraMovement movement = getMovementAt(index);
        if (movement != null) {
            movement.adjustDistance(increase);
        }
    }
    // Slot management methods
    public void addMovement(int slotIndex, ICameraMovement movement) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            slots.get(slotIndex).add(movement);
        }
    }
    public void removeMovement(int slotIndex, int movementIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (movementIndex >= 0 && movementIndex < slotMovements.size() && slotMovements.size() > 1) {
                slotMovements.remove(movementIndex);
                if (currentTypes.get(slotIndex) >= slotMovements.size()) {
                    currentTypes.set(slotIndex, slotMovements.size() - 1);
                }
            }
        }
    }
    // Getter methods
    public int getMovementCount() {
        return slots.size();
    }
    public ICameraMovement getMovementAt(int index) {
        if (index >= 0 && index < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(index);
            int currentType = currentTypes.get(index);
            if (!slotMovements.isEmpty() && currentType < slotMovements.size()) {
                return slotMovements.get(currentType);
            }
        }
        return null;
    }
    public List<ICameraMovement> getAvailableMovementsForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            return new ArrayList<>(slots.get(slotIndex));
        }
        return new ArrayList<>();
    }
    public int getCurrentTypeForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < currentTypes.size()) {
            return currentTypes.get(slotIndex);
        }
        return 0;
    }
    public void swapMovements(int slotIndex, int index1, int index2) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (index1 >= 0 && index1 < slotMovements.size() &&
                    index2 >= 0 && index2 < slotMovements.size()) {
                Collections.swap(slotMovements, index1, index2);
            }
        }
    }
    public void setAllSlots(List<List<ICameraMovement>> savedSlots) {
        this.slots = savedSlots;
    }
}
</file>

<file path="client/java/ninja/trek/CameraMovementManager.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.util.math.Vec3d;
import net.minecraft.client.render.Camera;
import ninja.trek.cameramovements.CameraTarget;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.MovementState;
import ninja.trek.mixin.client.CameraAccessor;
import java.util.*;
public class CameraMovementManager {
    private final List<ICameraMovement> activeMovements = new ArrayList<>();
    public void addMovement(ICameraMovement movement, MinecraftClient client, Camera camera) {
        movement.start(client, camera);
        activeMovements.add(movement);
    }
    public void update(MinecraftClient client, Camera camera) {
        if (activeMovements.isEmpty() || client.player == null) return;
        // Calculate states and total weight
        float totalWeight = 0;
        List<WeightedState> states = new ArrayList<>();
        Iterator<ICameraMovement> iterator = activeMovements.iterator();
        while (iterator.hasNext()) {
            ICameraMovement movement = iterator.next();
            MovementState state = movement.calculateState(client, camera);
            if (state.isComplete()) {
                iterator.remove();
            } else {
                float weight = movement.getWeight();
                // Apply raycast collision check to each movement's target
                CameraTarget adjustedTarget = state.getCameraTarget().withAdjustedPosition(client.player);
                states.add(new WeightedState(adjustedTarget, weight));
                totalWeight += weight;
            }
        }
        // Blend states based on weights
        if (!states.isEmpty()) {
            CameraTarget blendedTarget = blendStates(states, totalWeight);
            // Final collision check on blended position
            CameraTarget finalTarget = blendedTarget.withAdjustedPosition(client.player);
            applyCameraTarget(finalTarget, camera);
        }
    }
    private CameraTarget blendStates(List<WeightedState> states, float totalWeight) {
        if (states.size() == 1) {
            return states.get(0).target;
        }
        Vec3d blendedPos = Vec3d.ZERO;
        float blendedYaw = 0;
        float blendedPitch = 0;
        for (WeightedState weighted : states) {
            float normalizedWeight = weighted.weight / totalWeight;
            CameraTarget target = weighted.target;
            blendedPos = blendedPos.add(
                    target.getPosition().multiply(normalizedWeight)
            );
            blendedYaw += target.getYaw() * normalizedWeight;
            blendedPitch += target.getPitch() * normalizedWeight;
        }
        // Use the raycast type from the highest weight movement
        WeightedState highestWeightState = states.stream()
                .max(Comparator.comparing(ws -> ws.weight))
                .orElse(states.get(0));
        return new CameraTarget(blendedPos, blendedYaw, blendedPitch,
                highestWeightState.target.getRaycastType());
    }
    private void applyCameraTarget(CameraTarget target, Camera camera) {
        CameraAccessor accessor = (CameraAccessor) camera;
        accessor.invokesetPos(target.getPosition());
        accessor.invokeSetRotation(target.getYaw(), target.getPitch());
    }
    private static class WeightedState {
        final CameraTarget target;
        final float weight;
        WeightedState(CameraTarget target, float weight) {
            this.target = target;
            this.weight = weight;
        }
    }
}
</file>

<file path="client/java/ninja/trek/CameraMovementRegistry.java">
package ninja.trek;
import ninja.trek.cameramovements.CameraMovementType;
import ninja.trek.cameramovements.ICameraMovement;
import net.fabricmc.loader.api.FabricLoader;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.net.URL;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
public class CameraMovementRegistry {
    private static final List<Class<? extends ICameraMovement>> movementTypes = new ArrayList<>();
    private static int currentTypeIndex = 0;
    private static final String BASE_PACKAGE = "ninja.trek.cameramovements";
    public static void initialize() {
        try {
            scanPackage(BASE_PACKAGE);
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to scan for camera movements", e);
        }
    }
    private static void scanPackage(String packageName) {
        try {
            String path = packageName.replace('.', '/');
            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
            Enumeration<URL> resources = classLoader.getResources(path);
            while (resources.hasMoreElements()) {
                URL resource = resources.nextElement();
                String protocol = resource.getProtocol();
                if (protocol.equals("file")) {
                    scanDirectory(new File(resource.getFile()), packageName);
                } else if (protocol.equals("jar")) {
                    scanJar(resource, path);
                }
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Error scanning package: " + packageName, e);
        }
    }
    private static void scanDirectory(File directory, String packageName) {
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    scanDirectory(file, packageName + "." + file.getName());
                } else if (file.getName().endsWith(".class")) {
                    String className = packageName + "." + file.getName().substring(0, file.getName().length() - 6);
                    processClass(className);
                }
            }
        }
    }
    private static void scanJar(URL resourceUrl, String path) {
        String jarPath = resourceUrl.getPath().substring(5, resourceUrl.getPath().indexOf("!"));
        try (JarFile jarFile = new JarFile(jarPath)) {
            Enumeration<JarEntry> entries = jarFile.entries();
            while (entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String entryName = entry.getName();
                if (entryName.startsWith(path) && entryName.endsWith(".class")) {
                    String className = entryName.substring(0, entryName.length() - 6).replace('/', '.');
                    processClass(className);
                }
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Error scanning JAR file: " + jarPath, e);
        }
    }
    private static void processClass(String className) {
        try {
            Class<?> cls = Class.forName(className);
            if (ICameraMovement.class.isAssignableFrom(cls) &&
                    cls.isAnnotationPresent(CameraMovementType.class)) {
                CameraMovementType annotation = cls.getAnnotation(CameraMovementType.class);
                if (annotation.enabled()) {
                    @SuppressWarnings("unchecked")
                    Class<? extends ICameraMovement> movementClass = (Class<? extends ICameraMovement>) cls;
                    registerMovement(movementClass);
                }
            }
        } catch (ClassNotFoundException e) {
            Craneshot.LOGGER.error("Error loading class: " + className, e);
        }
    }
    public static void registerMovement(Class<? extends ICameraMovement> movementClass) {
        if (!movementTypes.contains(movementClass)) {
            movementTypes.add(movementClass);
        }
    }
    public static ICameraMovement createCurrentMovement() {
        try {
            Constructor<? extends ICameraMovement> constructor = movementTypes.get(currentTypeIndex).getDeclaredConstructor();
            return constructor.newInstance();
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to create movement instance", e);
            return null;
        }
    }
    public static List<MovementInfo> getAllMovements() {
        List<MovementInfo> movements = new ArrayList<>();
        for (Class<? extends ICameraMovement> cls : movementTypes) {
            CameraMovementType annotation = cls.getAnnotation(CameraMovementType.class);
            if (annotation != null) {
                movements.add(new MovementInfo(
                        annotation.name().isEmpty() ? cls.getSimpleName() : annotation.name(),
                        annotation.description(),
                        cls
                ));
            }
        }
        return movements;
    }
    public static void cycleNextMovement() {
        currentTypeIndex = (currentTypeIndex + 1) % movementTypes.size();
    }
    public static String getCurrentMovementName() {
        Class<? extends ICameraMovement> currentClass = movementTypes.get(currentTypeIndex);
        CameraMovementType annotation = currentClass.getAnnotation(CameraMovementType.class);
        return annotation != null && !annotation.name().isEmpty() ?
                annotation.name() : currentClass.getSimpleName();
    }
    public static int getMovementCount() {
        return movementTypes.size();
    }
    // Helper class to hold movement type information
    public static class MovementInfo {
        private final String name;
        private final String description;
        private final Class<? extends ICameraMovement> movementClass;
        public MovementInfo(String name, String description, Class<? extends ICameraMovement> movementClass) {
            this.name = name;
            this.description = description;
            this.movementClass = movementClass;
        }
        public String getName() { return name; }
        public String getDescription() { return description; }
        public Class<? extends ICameraMovement> getMovementClass() { return movementClass; }
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraMovementType.java">
package ninja.trek.cameramovements;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CameraMovementType {
    String name() default "";
    String description() default "";
    boolean enabled() default true;
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraState.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
public class CameraState {
    private Vec3d position;
    private float yaw;
    private float pitch;
    public CameraState(Vec3d position, float yaw, float pitch) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public static CameraState fromCamera(Camera camera) {
        return new CameraState(camera.getPos(), camera.getYaw(), camera.getPitch());
    }
    public Vec3d getPosition() { return position; }
    public float getYaw() { return yaw; }
    public float getPitch() { return pitch; }
    public CameraState lerp(CameraState other, double t) {
        Vec3d lerpedPos = this.position.lerp(other.position, t);
        float lerpedYaw = lerpAngle(this.yaw, other.yaw, (float)t);
        float lerpedPitch = lerpAngle(this.pitch, other.pitch, (float)t);
        return new CameraState(lerpedPos, lerpedYaw, lerpedPitch);
    }
    private float lerpAngle(float start, float end, float t) {
        float diff = end - start;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return start + diff * t;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraTarget.java">
package ninja.trek.cameramovements;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.Craneshot;
public class CameraTarget {
    private Vec3d position;
    private float yaw;
    private float pitch;
    private RaycastType raycastType;
    public CameraTarget(Vec3d position, float yaw, float pitch, RaycastType raycastType) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
        this.raycastType = raycastType;
    }
    public static CameraTarget fromCamera(Camera camera, RaycastType raycastType) {
        return new CameraTarget(camera.getPos(), camera.getYaw(), camera.getPitch(), raycastType);
    }
    public static CameraTarget fromPlayer(PlayerEntity player, RaycastType raycastType) {
        return new CameraTarget(player.getEyePos(), player.getYaw(), player.getPitch(), raycastType);
    }
    public static CameraTarget fromDistance(PlayerEntity player, double distance, RaycastType raycastType) {
        double yaw = Math.toRadians(player.getYaw());
        double pitch = Math.toRadians(player.getPitch());
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * distance;
        double yOffset = Math.sin(pitch) * distance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * distance;
        Vec3d targetPos = player.getEyePos().add(xOffset, yOffset, zOffset);
        return new CameraTarget(targetPos, player.getYaw(), player.getPitch(), raycastType);
    }
    public CameraTarget lerp(CameraTarget other, double t) {
        Vec3d lerpedPos = this.position.lerp(other.position, t);
        float lerpedYaw = lerpAngle(this.yaw, other.yaw, (float)t);
        float lerpedPitch = lerpAngle(this.pitch, other.pitch, (float)t);
        return new CameraTarget(lerpedPos, lerpedYaw, lerpedPitch, this.raycastType);
    }
    private float lerpAngle(float start, float end, float t) {
        float diff = end - start;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return start + diff * t;
    }
    public Vec3d getPosition() {
        return position;
    }
    public float getYaw() {
        return yaw;
    }
    public float getPitch() {
        return pitch;
    }
    public RaycastType getRaycastType() {
        return raycastType;
    }
    public void setPosition(Vec3d position) {
        this.position = position;
    }
    public CameraTarget withAdjustedPosition(PlayerEntity player) {
        Craneshot.LOGGER.info("withAdjustedPosition called with raycastType: {}", this.raycastType);
        Vec3d adjustedPos = RaycastUtil.adjustForCollision(player.getEyePos(), this.position, this.raycastType);
        return new CameraTarget(adjustedPos, this.yaw, this.pitch, this.raycastType);
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/ICameraMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
public interface ICameraMovement {
    void start(MinecraftClient client, Camera camera);
    MovementState calculateState(MinecraftClient client, Camera camera);
    void queueReset(MinecraftClient client, Camera camera);
    void adjustDistance(boolean increase);
    String getName();
    float getWeight(); // For blending calculations
    boolean isComplete(); // To determine if movement should be removed
}
</file>

<file path="client/java/ninja/trek/cameramovements/movements/LinearMovement.java">
package ninja.trek.cameramovements.movements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.cameramovements.CameraMovementType;
import ninja.trek.cameramovements.CameraTarget;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.MovementState;
import ninja.trek.config.AbstractMovementSettings;
import ninja.trek.config.MovementSetting;
@CameraMovementType(
        name = "Linear Movement",
        description = "Moves the camera with linear interpolation and speed limiting"
)
public class LinearMovement extends AbstractMovementSettings implements ICameraMovement {
    @MovementSetting(label = "Easing Factor", min = 0.01, max = 1.0)
    private double easingFactor = 0.1;
    @MovementSetting(label = "Speed Limit", min = 0.1, max = 100.0)
    private double speedLimit = 2.0;
    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10.0;
    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0;
    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0;
    private CameraTarget currentTarget;
    private CameraTarget destinationTarget;
    private boolean resetting = false;
    private float weight = 1.0f;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return;
        currentTarget = CameraTarget.fromCamera(camera, getRaycastType());
        destinationTarget = CameraTarget.fromDistance(player, targetDistance, getRaycastType());
        resetting = false;
        weight = 1.0f;
    }
    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return new MovementState(currentTarget, true);
        // Update destination target if not resetting
        if (!resetting) {
            destinationTarget = CameraTarget.fromDistance(player, targetDistance, getRaycastType());
        }
        // First calculate desired position using lerp
        Vec3d currentPos = currentTarget.getPosition();
        Vec3d targetPos = destinationTarget.getPosition();
        Vec3d desiredPos = currentPos.lerp(targetPos, easingFactor);
        // Calculate rotation lerp
        float desiredYaw = lerpAngle(currentTarget.getYaw(), destinationTarget.getYaw(), (float)easingFactor);
        float desiredPitch = lerpAngle(currentTarget.getPitch(), destinationTarget.getPitch(), (float)easingFactor);
        // Now limit how far we can move toward the desired position
        Vec3d moveVector = desiredPos.subtract(currentPos);
        double moveDistance = moveVector.length();
        boolean complete = false;
        if (moveDistance < 0.01) {
            currentTarget = new CameraTarget(desiredPos, desiredYaw, desiredPitch, getRaycastType());
            complete = resetting && currentPos.distanceTo(targetPos) < 0.01;
        } else {
            // Calculate maximum allowed movement this frame
            double maxMove = speedLimit * (1.0/20.0); // Convert blocks/second to blocks/tick
            // If we need to move further than allowed, scale back the movement
            if (moveDistance > maxMove) {
                Vec3d limitedMove = moveVector.normalize().multiply(maxMove);
                desiredPos = currentPos.add(limitedMove);
                // Scale back rotation proportionally
                float moveFactor = (float)(maxMove / moveDistance);
                desiredYaw = lerpAngle(currentTarget.getYaw(), desiredYaw, moveFactor);
                desiredPitch = lerpAngle(currentTarget.getPitch(), desiredPitch, moveFactor);
            }
            currentTarget = new CameraTarget(desiredPos, desiredYaw, desiredPitch, getRaycastType());
        }
        return new MovementState(currentTarget, complete);
    }
    private float lerpAngle(float start, float end, float t) {
        float diff = end - start;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return start + diff * t;
    }
    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        if (client.player == null) return;
        resetting = true;
        destinationTarget = new CameraTarget(
                client.player.getEyePos(),
                client.player.getYaw(),
                client.player.getPitch(),
                getRaycastType()
        );
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? 1.1 : 0.9;
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
    }
    @Override
    public String getName() {
        return "Linear";
    }
    @Override
    public float getWeight() {
        return weight;
    }
    @Override
    public boolean isComplete() {
        return resetting && MinecraftClient.getInstance().player != null &&
                currentTarget.getPosition().distanceTo(MinecraftClient.getInstance().player.getEyePos()) < 0.1;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/MovementState.java">
package ninja.trek.cameramovements;
public class MovementState {
    private final CameraTarget target;
    private final boolean isComplete;
    public MovementState(CameraTarget target, boolean isComplete) {
        this.target = target;
        this.isComplete = isComplete;
    }
    public CameraTarget getCameraTarget() {
        return target;
    }
    public boolean isComplete() {
        return isComplete;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/RaycastType.java">
package ninja.trek.cameramovements;
/**
 * Enum defining different raycast behaviors for camera collision handling
 */
public enum RaycastType {
    /**
     * No raycast collision checking - camera can clip through blocks
     */
    NONE,
    /**
     * Raycasts from player to desired camera position.
     * If collision detected, moves camera closer to player.
     * Behaves like default Minecraft third person camera.
     */
    NEAR,
    /**
     * Raycasts from desired camera position towards player.
     * If camera would be inside block, moves it to first non-solid position.
     * Provides more stable distant shots by preferring to keep camera far out.
     */
    FAR
}
</file>

<file path="client/java/ninja/trek/cameramovements/RaycastUtil.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.RaycastContext;
public class RaycastUtil {
    private static final double CAMERA_OFFSET = 0.5;
    private static final double STEP_SIZE = 0.5;
    private static final double FINE_STEP_SIZE = 0.1;
    public static Vec3d adjustForCollision(Vec3d playerPos, Vec3d targetPos, RaycastType raycastType) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.world == null || raycastType == RaycastType.NONE) {
            return targetPos;
        }
        switch (raycastType) {
            case NEAR:
                return handleNearRaycast(client, playerPos, targetPos);
            case FAR:
                return handleFarRaycast(client, playerPos, targetPos);
            default:
                return targetPos;
        }
    }
    private static Vec3d handleNearRaycast(MinecraftClient client, Vec3d playerPos, Vec3d targetPos) {
        BlockHitResult hit = client.world.raycast(new RaycastContext(
                playerPos,
                targetPos,
                RaycastContext.ShapeType.VISUAL,
                RaycastContext.FluidHandling.NONE,
                client.player
        ));
        if (hit.getType() == HitResult.Type.BLOCK) {
            Vec3d hitPos = hit.getPos();
            Vec3d directionVector = hitPos.subtract(playerPos).normalize();
            return hitPos.subtract(directionVector.multiply(CAMERA_OFFSET));
        }
        return targetPos;
    }
    private static Vec3d handleFarRaycast(MinecraftClient client, Vec3d playerPos, Vec3d targetPos) {
        Vec3d direction = targetPos.subtract(playerPos).normalize();
        double totalDistance = targetPos.distanceTo(playerPos);
        // Start from target position
        Vec3d currentPos = targetPos;
        if (isPositionInAir(client, currentPos)) {
            return refinePosition(client, currentPos, direction);
        }
        // Coarse search
        for (double distance = STEP_SIZE; distance < totalDistance; distance += STEP_SIZE) {
            Vec3d checkPos = targetPos.subtract(direction.multiply(distance));
            if (isPositionInAir(client, checkPos)) {
                return refinePosition(client, checkPos, direction.multiply(-1));
            }
        }
        return playerPos;
    }
    private static Vec3d refinePosition(MinecraftClient client, Vec3d startPos, Vec3d direction) {
        // Raycast forward until we hit something
        BlockHitResult hit = client.world.raycast(new RaycastContext(
                startPos,
                startPos.add(direction.multiply(2.0)), // Look 2 blocks ahead
                RaycastContext.ShapeType.VISUAL,
                RaycastContext.FluidHandling.NONE,
                client.player
        ));
        if (hit.getType() == HitResult.Type.BLOCK) {
            Vec3d hitPos = hit.getPos();
            return hitPos.subtract(direction.multiply(CAMERA_OFFSET));
        }
        return startPos;
    }
    private static boolean isPositionInAir(MinecraftClient client, Vec3d pos) {
        BlockPos blockPos = BlockPos.ofFloored(pos);
        return client.world.getBlockState(blockPos).isAir();
    }
}
</file>

<file path="client/java/ninja/trek/config/AbstractMovementSettings.java">
package ninja.trek.config;
import ninja.trek.Craneshot;
import ninja.trek.cameramovements.RaycastType;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;
public abstract class AbstractMovementSettings {
    private String customName = null;
    @MovementSetting(
            label = "Raycast Type",
            type = MovementSettingType.ENUM,
            description = "Controls how the camera handles collision with blocks"
    )
    private RaycastType raycastType = RaycastType.NEAR;
    public RaycastType getRaycastType() {
        return raycastType != null ? raycastType : RaycastType.NONE;
    }
    public void setRaycastType(RaycastType type) {
        this.raycastType = type;
    }
    public String getDisplayName() {
        return customName != null ? customName : getClass().getSimpleName();
    }
    public void setCustomName(String name) {
        this.customName = name;
    }
    public Map<String, Object> getSettings() {
        Map<String, Object> settings = new HashMap<>();
        Stream.concat(
                        Arrays.stream(this.getClass().getDeclaredFields()),
                        Arrays.stream(AbstractMovementSettings.class.getDeclaredFields())
                )
                .filter(field -> field.isAnnotationPresent(MovementSetting.class) || field.getName().equals("customName"))
                .forEach(field -> {
                    field.setAccessible(true);
                    try {
                        Object value = field.get(this);
                        if (value instanceof Enum<?>) {
                            settings.put(field.getName(), ((Enum<?>) value).name());
                        } else {
                            settings.put(field.getName(), value);
                        }
                    } catch (IllegalAccessException e) {
                        Craneshot.LOGGER.error("Error accessing field: " + field.getName(), e);
                    }
                });
        return settings;
    }
    public void updateSetting(String key, Object value) {
        try {
            if (key.equals("customName")) {
                setCustomName((String)value);
                return;
            }
            Field field = findField(key);
            if (field != null && field.isAnnotationPresent(MovementSetting.class)) {
                field.setAccessible(true);
                // Handle different field types
                if (field.getType().isEnum()) {
                    if (value instanceof String) {
                        @SuppressWarnings("unchecked")
                        Enum<?> enumValue = Enum.valueOf(field.getType().asSubclass(Enum.class), (String) value);
                        field.set(this, enumValue);
                        if (key.equals("raycastType")) {
                            setRaycastType((RaycastType)enumValue);
                        }
                    }
                } else if (field.getType() == double.class || field.getType() == Double.class) {
                    double doubleValue;
                    if (value instanceof Number) {
                        doubleValue = ((Number)value).doubleValue();
                    } else if (value instanceof String) {
                        doubleValue = Double.parseDouble((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to double");
                    }
                    field.setDouble(this, doubleValue);
                } else if (field.getType() == float.class || field.getType() == Float.class) {
                    float floatValue;
                    if (value instanceof Number) {
                        floatValue = ((Number)value).floatValue();
                    } else if (value instanceof String) {
                        floatValue = Float.parseFloat((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to float");
                    }
                    field.setFloat(this, floatValue);
                } else if (field.getType() == int.class || field.getType() == Integer.class) {
                    int intValue;
                    if (value instanceof Number) {
                        intValue = ((Number)value).intValue();
                    } else if (value instanceof String) {
                        intValue = Integer.parseInt((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to integer");
                    }
                    field.setInt(this, intValue);
                } else {
                    // Default fallback for other types
                    field.set(this, value);
                }
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Error updating setting {} with value {}: {}", key, value, e.getMessage());
        }
    }
    private Field findField(String key) {
        try {
            return this.getClass().getDeclaredField(key);
        } catch (NoSuchFieldException e) {
            try {
                return AbstractMovementSettings.class.getDeclaredField(key);
            } catch (NoSuchFieldException ex) {
                Craneshot.LOGGER.error("Field not found: {}", key);
                return null;
            }
        }
    }
}
</file>

<file path="client/java/ninja/trek/config/GeneralMenuSettings.java">
package ninja.trek.config;
public class GeneralMenuSettings {
    private static TransitionMode currentTransitionMode = TransitionMode.IMMEDIATE;
    public static TransitionMode getCurrentTransitionMode() {
        return currentTransitionMode;
    }
    public static void setCurrentTransitionMode(TransitionMode mode) {
        currentTransitionMode = mode;
    }
}
</file>

<file path="client/java/ninja/trek/config/GeneralSettingsIO.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonObject;
import net.minecraft.client.MinecraftClient;
import ninja.trek.Craneshot;
import java.io.*;
public class GeneralSettingsIO {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_general.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    public static void saveSettings() {
        try {
            if (!CONFIG_FILE.getParentFile().exists()) {
                CONFIG_FILE.getParentFile().mkdirs();
            }
            try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
                JsonObject settingsObj = new JsonObject();
                // Save TransitionMode
                settingsObj.addProperty("transitionMode", GeneralMenuSettings.getCurrentTransitionMode().name());
                // Save wrap states for each slot
                JsonObject wrapStatesObj = new JsonObject();
                for (int i = 0; i < 3; i++) {  // Assuming 3 slots
                    wrapStatesObj.addProperty("slot" + i, SlotMenuSettings.getWrapState(i));
                }
                settingsObj.add("wrapStates", wrapStatesObj);
                GSON.toJson(settingsObj, writer);
                Craneshot.LOGGER.info("Saved general settings configuration");
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Failed to save general settings", e);
        }
    }
    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) {
            Craneshot.LOGGER.info("No general settings file found, using defaults");
            return;
        }
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            JsonObject settingsObj = GSON.fromJson(reader, JsonObject.class);
            // Load TransitionMode
            if (settingsObj.has("transitionMode")) {
                String modeName = settingsObj.get("transitionMode").getAsString();
                try {
                    TransitionMode mode = TransitionMode.valueOf(modeName);
                    GeneralMenuSettings.setCurrentTransitionMode(mode);
                } catch (IllegalArgumentException e) {
                    Craneshot.LOGGER.warn("Invalid transition mode in config: " + modeName);
                }
            }
            // Load wrap states
            if (settingsObj.has("wrapStates")) {
                JsonObject wrapStatesObj = settingsObj.getAsJsonObject("wrapStates");
                for (int i = 0; i < 3; i++) {  // Assuming 3 slots
                    String key = "slot" + i;
                    if (wrapStatesObj.has(key)) {
                        boolean wrapState = wrapStatesObj.get(key).getAsBoolean();
                        SlotMenuSettings.setWrapState(i, wrapState);
                    }
                }
            }
            Craneshot.LOGGER.info("Loaded general settings configuration");
        } catch (IOException e) {
            Craneshot.LOGGER.error("Failed to load general settings", e);
        }
    }
}
</file>

<file path="client/java/ninja/trek/config/MenuOverlayScreen.java">
package ninja.trek.config;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.CheckboxWidget;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;
import ninja.trek.CameraMovementRegistry;
import ninja.trek.Craneshot;
import ninja.trek.CraneshotClient;
import ninja.trek.cameramovements.ICameraMovement;
import java.lang.reflect.Field;
import java.util.*;
public class MenuOverlayScreen extends Screen {
    private static final Map<Integer, Set<Integer>> expandedMovements = new HashMap<>();
    private static final int MARGIN = 20;
    private static final int TAB_HEIGHT = 30;
    private static final int CONTENT_START_Y = TAB_HEIGHT - 10;
    private static final double SCROLL_SPEED = 10;
    private static boolean isMenuOpen = false;
    private int selectedTab = 0;
    private final List<SettingSlider> settingSliders = new ArrayList<>();
    private int scrollOffset = 0;
    private int maxScroll = 0;
    private int guiWidth;
    private int guiHeight;
    private int centerX;
    private int centerY;
    private int selectedMovementTypeIndex = 0;
    public MenuOverlayScreen() {
        super(Text.literal("CraneShot Settings"));
        isMenuOpen = false;
    }
    @Override
    protected void init() {
        this.guiWidth = this.width - (MARGIN * 2);
        this.guiHeight = this.height - (MARGIN * 2);
        this.centerX = MARGIN;
        this.centerY = MARGIN;
        int visibleStartY = centerY + CONTENT_START_Y;
        int visibleEndY = centerY + guiHeight;
        createTabButtons();
        int BUTTON_HEIGHT = 20;
        int MOVEMENT_SPACING = BUTTON_HEIGHT - 5;
        int MOVEMENT_ROW_HEIGHT = BUTTON_HEIGHT + 5;
        int SETTING_HEIGHT = BUTTON_HEIGHT + 5;
        if (selectedTab > 0) {
            int slotIndex = selectedTab - 1;
            createControlsBar(slotIndex, visibleStartY, BUTTON_HEIGHT);
            createMovementList(slotIndex, visibleStartY, visibleEndY, BUTTON_HEIGHT,
                    MOVEMENT_ROW_HEIGHT, MOVEMENT_SPACING, SETTING_HEIGHT);
        } else if (selectedTab == 0) {
            addGeneralSettings();
        }
    }
    private void createTabButtons() {
        int tabCount = CraneshotClient.CAMERA_CONTROLLER.getMovementCount() + 1;
        int tabWidth = Math.min(100, (guiWidth - 20) / tabCount);
        for (int i = 0; i <= CraneshotClient.CAMERA_CONTROLLER.getMovementCount(); i++) {
            int tabIndex = i;
            String tabName = (i == 0) ? "General" : "Slot " + i;
            Text buttonText = Text.literal(tabName);
            if (i != selectedTab) {
                buttonText = buttonText.copy().formatted(Formatting.GRAY);
            }
            ButtonWidget slotBtn = ButtonWidget.builder(buttonText, button -> switchTab(tabIndex))
                    .dimensions(centerX + (i * (tabWidth + 5)), centerY, tabWidth, 20)
                    .build();
            this.addDrawableChild(slotBtn);
        }
    }
    private void createControlsBar(int slotIndex, int visibleStartY, int BUTTON_HEIGHT) {
        if (visibleStartY <= centerY + CONTENT_START_Y + BUTTON_HEIGHT) {
            int addButtonWidth = 60;
            int typeButtonWidth = 120;
            int clipboardButtonWidth = 40;
            int spacing = 10;
            // Add movement button
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Add"), button -> addMovement(slotIndex))
                    .dimensions(centerX + 10, centerY + CONTENT_START_Y, addButtonWidth, BUTTON_HEIGHT)
                    .build());
            // Paste button
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Paste"), button -> pasteMovement(slotIndex))
                    .dimensions(centerX + addButtonWidth + spacing, centerY + CONTENT_START_Y, clipboardButtonWidth, BUTTON_HEIGHT)
                    .build());
            // Movement type selector
            List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
            String currentTypeName = movements.isEmpty() ? "None" : movements.get(selectedMovementTypeIndex).getName();
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Type: " + currentTypeName),
                            button -> cycleMovementType())
                    .dimensions(centerX + addButtonWidth + clipboardButtonWidth + spacing * 2, centerY + CONTENT_START_Y,
                            typeButtonWidth, BUTTON_HEIGHT)
                    .build());
            // Wrap checkbox
            this.addDrawableChild(CheckboxWidget.builder(Text.literal("Wrap"), this.textRenderer)
                    .pos(centerX + addButtonWidth + clipboardButtonWidth + typeButtonWidth + spacing * 3, centerY + CONTENT_START_Y)
                    .checked(SlotMenuSettings.getWrapState(slotIndex))
                    .callback((checkbox, checked) -> SlotMenuSettings.setWrapState(slotIndex, checked))
                    .build());
        }
    }
    private void createMovementControls(int slotIndex, int index, ICameraMovement movement, int rowY, int BUTTON_HEIGHT) {
        int controlX = centerX + 10;
        // Movement control buttons
        if (index > 0) {
            addDrawableChild(ButtonWidget.builder(Text.literal("↑"),
                            button -> moveMovement(slotIndex, index, index - 1))
                    .dimensions(controlX, rowY, 20, BUTTON_HEIGHT).build());
        }
        controlX += 25;
        if (index < CraneshotClient.CAMERA_CONTROLLER.getAvailableMovementsForSlot(slotIndex).size() - 1) {
            addDrawableChild(ButtonWidget.builder(Text.literal("↓"),
                            button -> moveMovement(slotIndex, index, index + 1))
                    .dimensions(controlX, rowY, 20, BUTTON_HEIGHT).build());
        }
        controlX += 25;
        if (CraneshotClient.CAMERA_CONTROLLER.getAvailableMovementsForSlot(slotIndex).size() > 1) {
            addDrawableChild(ButtonWidget.builder(Text.literal("×"),
                            button -> deleteMovement(slotIndex, index))
                    .dimensions(controlX, rowY, 20, BUTTON_HEIGHT).build());
        }
        controlX += 25;
        // Rename button
        if (movement instanceof AbstractMovementSettings settings) {
            addDrawableChild(ButtonWidget.builder(Text.literal("r"), button -> {
                        if (client != null) {
                            client.setScreen(new RenameModal(this, settings, this::reinitialize));
                        }
                    })
                    .dimensions(controlX, rowY, 20, BUTTON_HEIGHT)
                    .build());
            controlX += 25;
        }
        // Movement name/expand button
        int remainingWidth = Math.min(200, guiWidth / 3);
        String displayName = movement instanceof AbstractMovementSettings ?
                ((AbstractMovementSettings)movement).getDisplayName() :
                movement.getName();
        addDrawableChild(ButtonWidget.builder(
                        Text.literal((isMovementExpanded(slotIndex, index) ? "▼ " : "▶ ") + displayName),
                        button -> {
                            toggleMovementExpanded(slotIndex, index);
                            reinitialize();
                        })
                .dimensions(controlX, rowY, remainingWidth, BUTTON_HEIGHT)
                .build());
        // Copy button after the name
        controlX += remainingWidth + 5;
        addDrawableChild(ButtonWidget.builder(Text.literal("Copy"), button -> copyMovement(movement))
                .dimensions(controlX, rowY, 30, BUTTON_HEIGHT)
                .build());
    }
    private void addGeneralSettings() {
        int yOffset = CONTENT_START_Y + 20;
        int buttonWidth = 200;
        int buttonX = centerX + (guiWidth - buttonWidth) / 2;
        this.addDrawableChild(ButtonWidget.builder(
                        Text.literal("Transition Mode: " + GeneralMenuSettings.getCurrentTransitionMode().getDisplayName()),
                        button -> {
                            TransitionMode[] modes = TransitionMode.values();
                            int currentIndex = Arrays.asList(modes).indexOf(GeneralMenuSettings.getCurrentTransitionMode());
                            int nextIndex = (currentIndex + 1) % modes.length;
                            GeneralMenuSettings.setCurrentTransitionMode(modes[nextIndex]);
                            button.setMessage(Text.literal("Transition Mode: " + modes[nextIndex].getDisplayName()));
                        })
                .dimensions(buttonX, centerY + yOffset, buttonWidth, 20)
                .build());
    }
    private void createMovementList(int slotIndex, int visibleStartY, int visibleEndY,
                                    int BUTTON_HEIGHT, int MOVEMENT_ROW_HEIGHT, int MOVEMENT_SPACING, int SETTING_HEIGHT) {
        List<ICameraMovement> movements = CraneshotClient.CAMERA_CONTROLLER.getAvailableMovementsForSlot(slotIndex);
        int yOffset = CONTENT_START_Y + BUTTON_HEIGHT + 10;
        for (int i = 0; i < movements.size(); i++) {
            int index = i;
            ICameraMovement movement = movements.get(i);
            int rowY = centerY + yOffset - scrollOffset;
            if (rowY >= visibleStartY - BUTTON_HEIGHT && rowY <= visibleEndY) {
                createMovementControls(slotIndex, index, movement, rowY, BUTTON_HEIGHT);
            }
            yOffset += MOVEMENT_ROW_HEIGHT;
            if (movement instanceof AbstractMovementSettings settings && isMovementExpanded(slotIndex, index)) {
                yOffset = createSettingsSection(settings, rowY, yOffset, visibleStartY, visibleEndY,
                        BUTTON_HEIGHT, SETTING_HEIGHT, MOVEMENT_SPACING);
            } else {
                yOffset += MOVEMENT_SPACING;
            }
        }
        updateScrollBounds(yOffset);
    }
    private int createSettingsSection(AbstractMovementSettings settings, int rowY, int yOffset,
                                      int visibleStartY, int visibleEndY, int BUTTON_HEIGHT, int SETTING_HEIGHT, int MOVEMENT_SPACING) {
        List<Field> settingFields = new ArrayList<>();
        collectSettingFields(settings, settingFields);
        int totalWidth = guiWidth - 40;
        int labelWidth = Math.min(150, totalWidth / 4);
        int controlWidth = Math.min(200, totalWidth / 2);
        int settingWidth = labelWidth + controlWidth + 10;
        int columnsCount = Math.max(1, Math.min(3, (totalWidth + 20) / (settingWidth + 20)));
        int settingsPerColumn = (int) Math.ceil(settingFields.size() / (double) columnsCount);
        for (int fieldIndex = 0; fieldIndex < settingFields.size(); fieldIndex++) {
            Field field = settingFields.get(fieldIndex);
            MovementSetting annotation = field.getAnnotation(MovementSetting.class);
            field.setAccessible(true);
            try {
                int column = fieldIndex / settingsPerColumn;
                int row = fieldIndex % settingsPerColumn;
                int settingX = centerX + 20 + column * (settingWidth + 20);
                int settingY = centerY + yOffset + (row * SETTING_HEIGHT) - scrollOffset;
                if (settingY >= visibleStartY - BUTTON_HEIGHT && settingY <= visibleEndY) {
                    createSettingControl(settings, field, annotation, settingX, settingY,
                            labelWidth, controlWidth, BUTTON_HEIGHT);
                }
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        return yOffset + (settingsPerColumn * SETTING_HEIGHT) + MOVEMENT_SPACING;
    }
    private void createSettingControl(AbstractMovementSettings settings, Field field,
                                      MovementSetting annotation, int settingX, int settingY, int labelWidth,
                                      int controlWidth, int BUTTON_HEIGHT) throws IllegalAccessException {
        // Label button
        addDrawableChild(ButtonWidget.builder(Text.literal(annotation.label()), button -> {})
                .dimensions(settingX, settingY, labelWidth, BUTTON_HEIGHT)
                .build());
        // Control
        if (annotation.type() == MovementSettingType.ENUM) {
            ButtonWidget enumButton = SettingWidget.createEnumButton(
                    settingX + labelWidth + 10,
                    settingY,
                    controlWidth,
                    BUTTON_HEIGHT,
                    field.getName(),
                    settings,
                    annotation
            );
            if (enumButton != null) {
                addDrawableChild(enumButton);
            }
        } else {
            double value = ((Number) field.get(settings)).doubleValue();
            addDrawableChild(SettingWidget.createSlider(
                    settingX + labelWidth + 10,
                    settingY,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal(annotation.label()),
                    annotation.min(),
                    annotation.max(),
                    value,
                    field.getName(),
                    settings
            ));
        }
    }
    private void collectSettingFields(AbstractMovementSettings settings, List<Field> settingFields) {
        // Get fields from the concrete class
        for (Field field : settings.getClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(MovementSetting.class)) {
                settingFields.add(field);
            }
        }
        // Get fields from AbstractMovementSettings
        for (Field field : AbstractMovementSettings.class.getDeclaredFields()) {
            if (field.isAnnotationPresent(MovementSetting.class)) {
                settingFields.add(field);
            }
        }
    }
    private void updateScrollBounds(int yOffset) {
        int contentHeight = yOffset - (CONTENT_START_Y + 20 + 10);
        int visibleHeight = guiHeight - CONTENT_START_Y - 10;
        maxScroll = Math.max(0, contentHeight - visibleHeight);
    }
    private void cycleMovementType() {
        List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
        if (!movements.isEmpty()) {
            selectedMovementTypeIndex = (selectedMovementTypeIndex + 1) % movements.size();
            reinitialize();
        }
    }
    private void addMovement(int slotIndex) {
        List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
        if (!movements.isEmpty()) {
            try {
                ICameraMovement newMovement = movements.get(selectedMovementTypeIndex)
                        .getMovementClass()
                        .getDeclaredConstructor()
                        .newInstance();
                CraneshotClient.CAMERA_CONTROLLER.addMovement(slotIndex, newMovement);
                reinitialize();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    @Override
    public void resize(MinecraftClient client, int width, int height) {
        super.resize(client, width, height);
        this.scrollOffset = 0;
        this.reinitialize();
    }
    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        context.fill(0, 0, this.width, this.height, 0x80000000);
        context.fill(
                centerX,
                centerY + CONTENT_START_Y,
                centerX + guiWidth,
                centerY + guiHeight,
                0xC0000000
        );
        super.render(context, mouseX, mouseY, delta);
        if (maxScroll > 0) {
            if (scrollOffset > 0) {
                context.drawCenteredTextWithShadow(
                        this.textRenderer,
                        Text.literal("▲"),
                        centerX + guiWidth - 15,
                        centerY + CONTENT_START_Y,
                        0xFFFFFF
                );
            }
            if (scrollOffset < maxScroll) {
                context.drawCenteredTextWithShadow(
                        this.textRenderer,
                        Text.literal("▼"),
                        centerX + guiWidth - 15,
                        centerY + guiHeight - 15,
                        0xFFFFFF
                );
            }
        }
    }
    // Keep existing helper methods
    private boolean isMovementExpanded(int slotIndex, int movementIndex) {
        return expandedMovements.computeIfAbsent(slotIndex, k -> new HashSet<>()).contains(movementIndex);
    }
    private void toggleMovementExpanded(int slotIndex, int movementIndex) {
        Set<Integer> expanded = expandedMovements.computeIfAbsent(slotIndex, k -> new HashSet<>());
        if (!expanded.remove(movementIndex)) {
            expanded.add(movementIndex);
        }
    }
    private void deleteMovement(int slotIndex, int movementIndex) {
        CraneshotClient.CAMERA_CONTROLLER.removeMovement(slotIndex, movementIndex);
        reinitialize();
    }
    private void moveMovement(int slotIndex, int fromIndex, int toIndex) {
        CraneshotClient.CAMERA_CONTROLLER.swapMovements(slotIndex, fromIndex, toIndex);
        reinitialize();
    }
    private void reinitialize() {
        this.clearChildren();
        this.init();
    }
    @Override
    public boolean mouseScrolled(double mouseX, double mouseY, double horizontalAmount, double verticalAmount) {
        if (verticalAmount != 0) {
            scroll((int)(-verticalAmount * SCROLL_SPEED));
            return true;
        }
        return super.mouseScrolled(mouseX, mouseY, horizontalAmount, verticalAmount);
    }
    @Override
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        if (keyCode == CraneshotClient.toggleMenuKey.getDefaultKey().getCode()) toggleMenu();
        return true;
    }
    private void scroll(int amount) {
        if (maxScroll > 0) {
            scrollOffset = Math.max(0, Math.min(scrollOffset + amount, maxScroll));
            clearChildren();
            init();
        }
    }
    private void switchTab(int index) {
        selectedTab = index;
        scrollOffset = 0;
        clearChildren();
        init();
    }
    public void toggleMenu() {
        MinecraftClient client = MinecraftClient.getInstance();
        if (isMenuOpen) {
            close();
        } else {
            client.setScreen(this);
            isMenuOpen = true;
        }
    }
    @Override
    public void close() {
        // Save the current slots configuration before closing
        List<List<ICameraMovement>> slots = new ArrayList<>();
        for (int i = 0; i < CraneshotClient.CAMERA_CONTROLLER.getMovementCount(); i++) {
            slots.add(CraneshotClient.CAMERA_CONTROLLER.getAvailableMovementsForSlot(i));
        }
        SlotSettingsIO.saveSlots(slots);
        GeneralSettingsIO.saveSettings();
        if (this.client != null) {
            this.client.setScreen(null);
        }
        isMenuOpen = false;
    }
    private void copyMovement(ICameraMovement movement) {
        SlotSettingsIO.copyMovementToClipboard(movement);
    }
    private void pasteMovement(int slotIndex) {
        try {
            ICameraMovement newMovement = SlotSettingsIO.createMovementFromClipboard();
            if (newMovement != null) {
                CraneshotClient.CAMERA_CONTROLLER.addMovement(slotIndex, newMovement);
                reinitialize();
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to paste movement", e);
        }
    }
    @Override
    public boolean shouldPause() {
        return false;
    }
}
</file>

<file path="client/java/ninja/trek/config/MovementSetting.java">
package ninja.trek.config;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface MovementSetting {
    String label();
    String description() default "";
    double min() default 0;
    double max() default 100;
    MovementSettingType type() default MovementSettingType.SLIDER;
}
</file>

<file path="client/java/ninja/trek/config/MovementSettingType.java">
package ninja.trek.config;
public enum MovementSettingType {
    SLIDER,
    ENUM
}
</file>

<file path="client/java/ninja/trek/config/RenameModal.java">
package ninja.trek.config;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.TextFieldWidget;
import net.minecraft.text.Text;
import net.minecraft.client.gui.DrawContext;
public class RenameModal extends Screen {
    private final Screen parent;
    private final AbstractMovementSettings movement;
    private TextFieldWidget nameField;
    private final Runnable onComplete;
    private static final int MODAL_WIDTH = 200;
    private static final int MODAL_HEIGHT = 100;
    public RenameModal(Screen parent, AbstractMovementSettings movement, Runnable onComplete) {
        super(Text.literal("Rename Movement"));
        this.parent = parent;
        this.movement = movement;
        this.onComplete = onComplete;
    }
    @Override
    protected void init() {
        int centerX = width / 2;
        int centerY = height / 2;
        int modalLeft = centerX - MODAL_WIDTH / 2;
        int modalTop = centerY - MODAL_HEIGHT / 2;
        // Create text field
        nameField = new TextFieldWidget(
                textRenderer,
                modalLeft + 10,
                modalTop + 30,
                MODAL_WIDTH - 20,
                20,
                Text.literal("Name")
        );
        nameField.setText(movement.getDisplayName());
        nameField.setMaxLength(32);
        addSelectableChild(nameField);
        setInitialFocus(nameField);
        // Create buttons
        addDrawableChild(ButtonWidget.builder(Text.literal("Save"), button -> {
                    movement.setCustomName(nameField.getText());
                    if (onComplete != null) onComplete.run();
                    close();
                })
                .dimensions(modalLeft + 10, modalTop + MODAL_HEIGHT - 30, 80, 20)
                .build());
        addDrawableChild(ButtonWidget.builder(Text.literal("Cancel"), button -> close())
                .dimensions(modalLeft + MODAL_WIDTH - 90, modalTop + MODAL_HEIGHT - 30, 80, 20)
                .build());
    }
    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        if (parent != null) {
           // parent.render(context, mouseX, mouseY, delta);
        }
        super.render(context, mouseX, mouseY, delta);
        int centerX = width / 2;
        int centerY = height / 2;
        int modalLeft = centerX - MODAL_WIDTH / 2;
        int modalTop = centerY - MODAL_HEIGHT / 2;
        // Draw modal background
        context.fill(modalLeft, modalTop, modalLeft + MODAL_WIDTH, modalTop + MODAL_HEIGHT, 0xF0000000);
        context.fill(modalLeft + 1, modalTop + 1, modalLeft + MODAL_WIDTH - 1, modalTop + MODAL_HEIGHT - 1, 0xFF444444);
        // Draw title
        context.drawCenteredTextWithShadow(textRenderer, "Rename Movement", centerX, modalTop + 10, 0xFFFFFF);
        nameField.render(context, mouseX, mouseY, delta);
    }
    @Override
    public void close() {
        if (this.client != null) {
            this.client.setScreen(parent);
        }
    }
    @Override
    public boolean shouldPause() {
        return false;
    }
}
</file>

<file path="client/java/ninja/trek/config/SettingSlider.java">
package ninja.trek.config;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.SliderWidget;
import net.minecraft.text.Text;
import ninja.trek.cameramovements.RaycastType;
class SettingSlider extends SliderWidget {
    private final double min;
    private final double max;
    private final String fieldName;
    private final AbstractMovementSettings settings;
    private final Text label;
    public SettingSlider(int x, int y, int width, int height, Text label,
                         double min, double max, double value, String fieldName, AbstractMovementSettings settings) {
        super(x, y, width, height, label, (value - min) / (max - min));
        this.min = min;
        this.max = max;
        this.fieldName = fieldName;
        this.settings = settings;
        this.label = label;
        updateMessage();
    }
    @Override
    protected void updateMessage() {
        setMessage(Text.literal(String.format("%.2f", getValue())));
    }
    @Override
    protected void applyValue() {
        double value = min + (max - min) * this.value;
        settings.updateSetting(fieldName, value);
    }
    public Text getLabel() {
        return label;
    }
    private double getValue() {
        return min + (max - min) * this.value;
    }
}
</file>

<file path="client/java/ninja/trek/config/SettingWidget.java">
package ninja.trek.config;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.SliderWidget;
import net.minecraft.text.Text;
import ninja.trek.Craneshot;
import java.lang.reflect.Field;
public class SettingWidget {
    public static ButtonWidget createEnumButton ( int x, int y, int width, int height,
                                                  String fieldName, AbstractMovementSettings settings, MovementSetting annotation){
        try {
            Field field = null;
            try {
                field = settings.getClass().getDeclaredField(fieldName);
            } catch (NoSuchFieldException e) {
                try {
                    field = AbstractMovementSettings.class.getDeclaredField(fieldName);
                } catch (NoSuchFieldException ex) {
                    throw new IllegalStateException("Field not found: " + fieldName);
                }
            }
            if (!field.getType().isEnum()) {
                throw new IllegalStateException("Field is not an enum type: " + fieldName);
            }
            field.setAccessible(true);
            Object initialValue = field.get(settings);
            if (!(initialValue instanceof Enum<?>)) {
                throw new IllegalStateException("Field value is not an enum: " + fieldName);
            }
            Class<? extends Enum<?>> enumClass = (Class<? extends Enum<?>>) field.getType().asSubclass(Enum.class);
            Enum<?>[] enumConstants = enumClass.getEnumConstants();
            final Field finalField = field;
            // Create button with current value
            ButtonWidget button = ButtonWidget.builder(
                    Text.literal(formatButtonText(annotation.label(), initialValue.toString())),
                    btn -> {
                        try {
                            Enum<?> currentValue = (Enum<?>) finalField.get(settings);
                            int currentIndex = currentValue.ordinal();
                            int nextIndex = (currentIndex + 1) % enumConstants.length;
                            Enum<?> nextValue = enumConstants[nextIndex];
                            // Set the new value and update the settings
                            finalField.set(settings, nextValue);
                            settings.updateSetting(fieldName, nextValue.name());
                            // Update button text
                            btn.setMessage(Text.literal(formatButtonText(annotation.label(), nextValue.toString())));
                            Craneshot.LOGGER.info("Updated enum setting " + fieldName + " to " + nextValue.name());
                            // Ensure raycastType is properly updated in settings
                            if (fieldName.equals("raycastType")) {
                                settings.updateSetting("raycastType", nextValue.name());
                            }
                        } catch (IllegalAccessException e) {
                            Craneshot.LOGGER.error("Failed to update enum setting", e);
                        }
                    }
            ).dimensions(x, y, width, height).build();
            return button;
        } catch (Exception e) {
            Craneshot.LOGGER.error("Error creating enum button", e);
            return null;
        }
    }
    private static String formatButtonText(String label, String value) {
        // Convert SNAKE_CASE to Title Case and format nicely
        String formattedValue = value.toLowerCase()
                .replace('_', ' ')
                .trim();
        formattedValue = Character.toUpperCase(formattedValue.charAt(0)) +
                formattedValue.substring(1);
        return label + ": " + formattedValue;
    }
    public static SliderWidget createSlider(int x, int y, int width, int height, Text label,
                                            double min, double max, double value, String fieldName, AbstractMovementSettings settings) {
        return new SettingSlider(x, y, width, height, label, min, max, value, fieldName, settings);
    }
}
</file>

<file path="client/java/ninja/trek/config/SlotMenuSettings.java">
package ninja.trek.config;
import java.util.HashMap;
import java.util.Map;
public class SlotMenuSettings {
    private static final Map<Integer, Boolean> wrapStates = new HashMap<>();
    public static boolean getWrapState(int slotIndex) {
        return wrapStates.getOrDefault(slotIndex, false);
    }
    public static void setWrapState(int slotIndex, boolean state) {
        wrapStates.put(slotIndex, state);
    }
}
</file>

<file path="client/java/ninja/trek/config/SlotSettingsIO.java">
package ninja.trek.config;
import com.google.gson.*;
import net.minecraft.client.MinecraftClient;
import ninja.trek.Craneshot;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.movements.LinearMovement;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
public class SlotSettingsIO {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_slots.json");
    private static final Gson GSON = new GsonBuilder()
            .setPrettyPrinting()
            .registerTypeAdapter(ICameraMovement.class, new CameraMovementSerializer())
            .create();
    public static JsonObject movementToJson(ICameraMovement movement) {
        JsonObject movementObj = new JsonObject();
        movementObj.addProperty("type", movement.getClass().getName());
        if (movement instanceof AbstractMovementSettings settings) {
            JsonObject settingsObj = new JsonObject();
            for (Map.Entry<String, Object> entry : settings.getSettings().entrySet()) {
                if (entry.getValue() != null) {
                    settingsObj.addProperty(entry.getKey(), entry.getValue().toString());
                }
            }
            movementObj.add("settings", settingsObj);
        }
        return movementObj;
    }
    public static void saveSlots(List<List<ICameraMovement>> slots) {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            JsonArray slotsArray = new JsonArray();
            for (List<ICameraMovement> slot : slots) {
                JsonArray slotArray = new JsonArray();
                for (ICameraMovement movement : slot) {
                    slotArray.add(movementToJson(movement));
                }
                slotsArray.add(slotArray);
            }
            GSON.toJson(slotsArray, writer);
            Craneshot.LOGGER.info("Saved camera movement slots configuration");
        } catch (IOException e) {
            Craneshot.LOGGER.error("Failed to save camera movement slots", e);
        }
    }
    public static ICameraMovement jsonToMovement(JsonObject movementObj) {
        String type = movementObj.get("type").getAsString();
        try {
            Class<?> movementClass = Class.forName(type);
            Constructor<?> constructor = movementClass.getDeclaredConstructor();
            ICameraMovement movement = (ICameraMovement) constructor.newInstance();
            if (movement instanceof AbstractMovementSettings settings &&
                    movementObj.has("settings")) {
                JsonObject settingsObj = movementObj.getAsJsonObject("settings");
                for (Map.Entry<String, JsonElement> entry : settingsObj.entrySet()) {
                    String value = entry.getValue().getAsString();
                    settings.updateSetting(entry.getKey(), value);
                }
            }
            return movement;
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to load movement: " + type, e);
            // Return default movement if loading fails
            return new LinearMovement();
        }
    }
    public static List<List<ICameraMovement>> loadSlots() {
        List<List<ICameraMovement>> slots = new ArrayList<>();
        if (!CONFIG_FILE.exists()) {
            // Return default configuration with one EasingMovement per slot
            for (int i = 0; i < 3; i++) {
                List<ICameraMovement> slot = new ArrayList<>();
                slot.add(new LinearMovement());
                slots.add(slot);
            }
            return slots;
        }
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            JsonArray slotsArray = JsonParser.parseReader(reader).getAsJsonArray();
            for (JsonElement slotElement : slotsArray) {
                List<ICameraMovement> slot = new ArrayList<>();
                JsonArray slotArray = slotElement.getAsJsonArray();
                for (JsonElement movementElement : slotArray) {
                    JsonObject movementObj = movementElement.getAsJsonObject();
                    slot.add(jsonToMovement(movementObj));
                }
                slots.add(slot);
            }
            Craneshot.LOGGER.info("Loaded camera movement slots configuration");
        } catch (IOException e) {
            Craneshot.LOGGER.error("Failed to load camera movement slots", e);
            // Return default configuration on error
            for (int i = 0; i < 3; i++) {
                List<ICameraMovement> slot = new ArrayList<>();
                slot.add(new LinearMovement());
                slots.add(slot);
            }
        }
        return slots;
    }
    public static void copyMovementToClipboard(ICameraMovement movement) {
        try {
            JsonObject movementJson = movementToJson(movement);
            String jsonStr = GSON.toJson(movementJson);
            // Use Minecraft's clipboard handling
            MinecraftClient.getInstance().keyboard.setClipboard(jsonStr);
            Craneshot.LOGGER.info("Copied movement settings to clipboard");
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to copy movement settings", e);
        }
    }
    public static ICameraMovement createMovementFromClipboard() {
        try {
            // Use Minecraft's clipboard handling
            String clipboardText = MinecraftClient.getInstance().keyboard.getClipboard();
            JsonObject movementObj = JsonParser.parseString(clipboardText).getAsJsonObject();
            return jsonToMovement(movementObj);
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to create movement from clipboard", e);
            return new LinearMovement(); // Return default movement if parsing fails
        }
    }
    private static class CameraMovementSerializer implements JsonSerializer<ICameraMovement> {
        @Override
        public JsonElement serialize(ICameraMovement movement, java.lang.reflect.Type typeOfSrc, JsonSerializationContext context) {
            return movementToJson(movement);
        }
    }
}
</file>

<file path="client/java/ninja/trek/config/TransitionMode.java">
// TransitionMode.java
package ninja.trek.config;
import net.minecraft.client.MinecraftClient;
import java.io.FileReader;
import java.io.FileWriter;
public enum TransitionMode {
    IMMEDIATE("Immediate Switch"),
    INTERPOLATE("Interpolate"),
    QUEUE("Queue");
    private final String displayName;
    TransitionMode(String displayName) {
        this.displayName = displayName;
    }
    public String getDisplayName() {
        return displayName;
    }
}
</file>

<file path="client/java/ninja/trek/config/TransitionModeManager.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.client.MinecraftClient;
import java.io.*;
public class TransitionModeManager {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_transition.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static TransitionMode currentMode = TransitionMode.IMMEDIATE;
    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) return;
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            String modeName = GSON.fromJson(reader, String.class);
            currentMode = TransitionMode.valueOf(modeName);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static void saveSettings() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(currentMode.name(), writer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static TransitionMode getCurrentMode() {
        return currentMode;
    }
    public static void setCurrentMode(TransitionMode mode) {
        currentMode = mode;
        saveSettings();
    }
}
</file>

<file path="client/java/ninja/trek/config/WrapSettings.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.client.MinecraftClient;
import java.io.*;
import java.util.HashMap;
import java.util.Map;
public class WrapSettings {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_wrap.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static Map<Integer, Boolean> wrapStates = new HashMap<>();
    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) return;
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            wrapStates = GSON.fromJson(reader, Map.class);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static void saveSettings() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(wrapStates, writer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static boolean getWrapState(int slotIndex) {
        return wrapStates.getOrDefault(slotIndex, false);
    }
    public static void setWrapState(int slotIndex, boolean state) {
        wrapStates.put(slotIndex, state);
        saveSettings();
    }
}
</file>

<file path="client/java/ninja/trek/CraneshotClient.java">
package ninja.trek;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.client.util.InputUtil;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.config.GeneralSettingsIO;
import ninja.trek.config.MenuOverlayScreen;
import ninja.trek.config.SlotSettingsIO;
import org.lwjgl.glfw.GLFW;
import java.util.List;
public class CraneshotClient implements ClientModInitializer {
	public static KeyBinding[] cameraKeyBinds;
	public static KeyBinding selectMovementType;
	public static final CameraController CAMERA_CONTROLLER = new CameraController();
	public static KeyBinding toggleMenuKey;
	private static boolean isMenuOpen = false;
	public static MenuOverlayScreen MENU = new MenuOverlayScreen();
	@Override
	public void onInitializeClient() {
		toggleMenuKey = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.toggle_menu",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_Z,
				"category.craneshot.ui"
		));
		selectMovementType = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.select_movement",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_X,
				"category.craneshot.camera"
		));
		cameraKeyBinds = new KeyBinding[]{
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera1",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_C,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera2",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_V,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera3",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_B,
						"category.craneshot.camera"
				))
		};
		CameraMovementRegistry.initialize();
		GeneralSettingsIO.loadSettings();
		List<List<ICameraMovement>> savedSlots = SlotSettingsIO.loadSlots();
		CAMERA_CONTROLLER.setAllSlots(savedSlots);
		CraneShotEventHandler.register();
	}
	public static void checkKeybinds() {
		if (toggleMenuKey.wasPressed()) {
			MENU.toggleMenu();
		}
	}
}
</file>

<file path="client/java/ninja/trek/CraneshotDataGenerator.java">
package ninja.trek;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class CraneshotDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/java/ninja/trek/CraneShotEventHandler.java">
package ninja.trek;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;
import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.text.Text;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.mixin.client.MouseAccessor;
import java.util.HashMap;
import java.util.Map;
public class CraneShotEventHandler {
    private static final double SCROLL_COOLDOWN = 0.1;
    private static double lastScrollTime = 0;
    private static String currentMessage = "";
    private static long messageTimer = 0;
    private static final long MESSAGE_DURATION = 2000;
    private static final Map<Integer, Boolean> keyStates = new HashMap<>();
    public static void register() {
        // Register client tick event for input handling
        ClientTickEvents.END_CLIENT_TICK.register(client -> {
            handleScrollInput(client);
            updateMessageTimer();
            CraneshotClient.checkKeybinds();
        });
        // Register HUD rendering for messages
        HudRenderCallback.EVENT.register((context, tickDelta) -> {
            if (!currentMessage.isEmpty() && System.currentTimeMillis() < messageTimer) {
                MinecraftClient client = MinecraftClient.getInstance();
                if (client.player != null) {
                    int width = client.getWindow().getScaledWidth();
                    context.drawTextWithShadow(
                            client.textRenderer,
                            Text.literal(currentMessage),
                            width / 2 - client.textRenderer.getWidth(currentMessage) / 2,
                            60,
                            0xFFFFFF
                    );
                }
            }
        });
        // Register world render event for camera updates
        WorldRenderEvents.START.register(context -> {
            MinecraftClient client = MinecraftClient.getInstance();
            Camera camera = client.gameRenderer.getCamera();
            // Handle camera movement key states
            boolean anyPressed = false;
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                boolean currentlyPressed = CraneshotClient.cameraKeyBinds[i].isPressed();
                boolean wasPressed = keyStates.getOrDefault(i, false);
                if (currentlyPressed) {
                    if (!wasPressed) {
                        // Key just pressed - start movement
                        CraneshotClient.CAMERA_CONTROLLER.startTransition(client, camera, i);
                    }
                    anyPressed = true;
                }
                keyStates.put(i, currentlyPressed);
            }
            // If no keys are pressed, reset the camera
            if (!anyPressed) {
                CraneshotClient.CAMERA_CONTROLLER.queueFinish(client, camera);
            }
            // Update camera movements
            if (client.player != null) {
                CraneshotClient.CAMERA_CONTROLLER.tick(client, camera);
            }
        });
    }
    private static void handleScrollInput(MinecraftClient client) {
        double currentTime = System.currentTimeMillis() / 1000.0;
        if (currentTime - lastScrollTime < SCROLL_COOLDOWN) {
            return;
        }
        MouseAccessor mouseAccessor = (MouseAccessor)client.mouse;
        double scrollDelta = mouseAccessor.getEventDeltaVerticalWheel();
        if (scrollDelta == 0) {
            return;
        }
        boolean scrollUp = scrollDelta > 0;
        // Handle movement type cycling
        if (CraneshotClient.selectMovementType.isPressed()) {
            CraneshotClient.CAMERA_CONTROLLER.cycleMovementType(scrollUp);
            // Find the active movement to display its type
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    ICameraMovement movement = CraneshotClient.CAMERA_CONTROLLER.getMovementAt(i);
                    if (movement != null) {
                        showMovementTypeMessage(String.format(
                                "Camera %d: %s Movement",
                                i + 1,
                                movement.getName()
                        ));
                    }
                    break;
                }
            }
            lastScrollTime = currentTime;
            mouseAccessor.setEventDeltaVerticalWheel(0);
        }
        // Handle distance adjustment
        else {
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    CraneshotClient.CAMERA_CONTROLLER.adjustDistance(i, scrollUp);
                    lastScrollTime = currentTime;
                    mouseAccessor.setEventDeltaVerticalWheel(0);
                    break;
                }
            }
        }
    }
    private static void showMovementTypeMessage(String message) {
        currentMessage = message;
        messageTimer = System.currentTimeMillis() + MESSAGE_DURATION;
    }
    private static void updateMessageTimer() {
        if (System.currentTimeMillis() >= messageTimer) {
            currentMessage = "";
        }
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/CameraAccessor.java">
package ninja.trek.mixin.client;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import org.spongepowered.asm.mixin.gen.Invoker;
@Mixin(Camera.class)
public interface CameraAccessor {
    @Accessor("pos")
    void invokesetPos(Vec3d pos);
    @Accessor("pos")
    Vec3d getPos();
    @Invoker("setRotation")
    void invokeSetRotation(float yaw, float pitch);
}
</file>

<file path="client/java/ninja/trek/mixin/client/ExampleClientMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseAccessor.java">
package ninja.trek.mixin.client;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import net.minecraft.client.Mouse;
@Mixin(Mouse.class)
public interface MouseAccessor {
    @Accessor("eventDeltaVerticalWheel")
    double getEventDeltaVerticalWheel();
    @Accessor("eventDeltaVerticalWheel")
    void setEventDeltaVerticalWheel(double value);
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.Mouse;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import ninja.trek.CraneshotClient;
@Mixin(Mouse.class)
public class MouseMixin {
    @Shadow private double eventDeltaVerticalWheel;
    @Inject(method = "onMouseScroll", at = @At("HEAD"), cancellable = true)
    private void onScroll(long window, double horizontal, double vertical, CallbackInfo ci) {
        if (CraneshotClient.selectMovementType.isPressed() ||
                CraneshotClient.cameraKeyBinds[0].isPressed() ||
                CraneshotClient.cameraKeyBinds[1].isPressed() ||
                CraneshotClient.cameraKeyBinds[2].isPressed()) {
            eventDeltaVerticalWheel = vertical;
            ci.cancel();
        }
    }
}
</file>

<file path="client/resources/craneshot.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"MouseMixin",
		"CameraAccessor",
		"MouseAccessor"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/Craneshot.java">
package ninja.trek;
import net.fabricmc.api.ModInitializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Craneshot implements ModInitializer {
	public static final String MOD_ID = "craneshot";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	@Override
	public void onInitialize() {
		LOGGER.info("CraneShot Camera Mod initialized!");
	}
}
</file>

<file path="main/java/ninja/trek/mixin/ExampleMixin.java">
package ninja.trek.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/resources/craneshot.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "craneshot",
	"version": "${version}",
	"name": "craneshot",
	"description": "Advanced camera controls mod for cinematics",
	"authors": ["Me!"],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/craneshot/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": ["ninja.trek.Craneshot"],
		"client": ["ninja.trek.CraneshotClient"],
		
		"fabric-datagen": ["ninja.trek.CraneshotDataGenerator"]
	},
	"mixins": [
		"craneshot.mixins.json",
		{
			"config": "craneshot.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*",
		"fabric-key-binding-api-v1": "*"
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
