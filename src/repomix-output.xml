This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-05T12:28:25.906Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/CameraController.java
client/java/ninja/trek/CameraMovementManager.java
client/java/ninja/trek/CameraMovementRegistry.java
client/java/ninja/trek/cameramovements/CameraMovementType.java
client/java/ninja/trek/cameramovements/CameraState.java
client/java/ninja/trek/cameramovements/CameraTarget.java
client/java/ninja/trek/cameramovements/ICameraMovement.java
client/java/ninja/trek/cameramovements/movements/EasingMovement.java
client/java/ninja/trek/cameramovements/movements/LinearMovement.java
client/java/ninja/trek/cameramovements/MovementState.java
client/java/ninja/trek/cameramovements/RaycastType.java
client/java/ninja/trek/cameramovements/RaycastUtil.java
client/java/ninja/trek/config/AbstractMovementSettings.java
client/java/ninja/trek/config/MenuOverlayScreen.java
client/java/ninja/trek/config/MovementConfigManager.java
client/java/ninja/trek/config/MovementSetting.java
client/java/ninja/trek/config/MovementSettingType.java
client/java/ninja/trek/config/SettingSlider.java
client/java/ninja/trek/config/SettingWidget.java
client/java/ninja/trek/config/TransitionMode.java
client/java/ninja/trek/config/TransitionModeManager.java
client/java/ninja/trek/config/WrapSettings.java
client/java/ninja/trek/CraneshotClient.java
client/java/ninja/trek/CraneshotDataGenerator.java
client/java/ninja/trek/CraneShotEventHandler.java
client/java/ninja/trek/mixin/client/CameraAccessor.java
client/java/ninja/trek/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/mixin/client/MouseAccessor.java
client/java/ninja/trek/mixin/client/MouseMixin.java
client/resources/craneshot.client.mixins.json
main/java/ninja/trek/Craneshot.java
main/java/ninja/trek/mixin/ExampleMixin.java
main/resources/craneshot.mixins.json
main/resources/fabric.mod.json
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/CameraController.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.option.Perspective;
import net.minecraft.client.render.Camera;
import ninja.trek.cameramovements.*;
import ninja.trek.cameramovements.movements.EasingMovement;
import ninja.trek.config.TransitionMode;
import ninja.trek.config.TransitionModeManager;
import ninja.trek.config.WrapSettings;
import java.util.*;
public class CameraController {
    private final List<List<ICameraMovement>> slots;
    private final ArrayList<Integer> currentTypes;
    private CameraMovementManager movementManager;
    private final Map<Integer, ICameraMovement> activeMovementSlots;
    private static final double FIRST_PERSON_THRESHOLD = 2.0;
    private ICameraMovement queuedMovement;
    private int queuedMovementSlot = -1;
    public CameraController() {
        slots = new ArrayList<>();
        currentTypes = new ArrayList<>();
        movementManager = new CameraMovementManager();
        activeMovementSlots = new HashMap<>();
        // Initialize slots with default configurations
        for (int i = 0; i < 3; i++) {
            ArrayList<ICameraMovement> arr = new ArrayList<>();
            arr.add(new EasingMovement());
            slots.add(arr);
            currentTypes.add(0);
        }
    }
    public void startTransition(MinecraftClient client, Camera camera, int movementIndex) {
        ICameraMovement movement = getMovementAt(movementIndex);
        if (movement == null) return;
        switch (TransitionModeManager.getCurrentMode()) {
            case INTERPOLATE -> {
                ICameraMovement previousMovement = activeMovementSlots.put(movementIndex, movement);
                if (previousMovement != null) {
                    previousMovement.queueReset(client, camera);
                }
                movement.start(client, camera);
                movementManager.addMovement(movement, client, camera);
            }
            case QUEUE -> {
                boolean canStartNewMovement = activeMovementSlots.isEmpty() ||
                        (activeMovementSlots.size() == 1 &&
                                activeMovementSlots.values().iterator().next().isComplete());
                if (canStartNewMovement) {
                    clearCompletedMovements(client, camera);
                    activeMovementSlots.clear();
                    activeMovementSlots.put(movementIndex, movement);
                    movement.start(client, camera);
                    movementManager.addMovement(movement, client, camera);
                    queuedMovement = null;
                    queuedMovementSlot = -1;
                } else {
                    queuedMovement = movement;
                    queuedMovementSlot = movementIndex;
                }
            }
            case IMMEDIATE -> {
                clearAllMovements(client, camera);
                activeMovementSlots.clear();
                activeMovementSlots.put(movementIndex, movement);
                movement.start(client, camera);
                movementManager.addMovement(movement, client, camera);
            }
        }
    }
    public void tick(MinecraftClient client, Camera camera) {
        movementManager.update(client, camera);
        updatePerspective(client, camera);
        if (TransitionModeManager.getCurrentMode() == TransitionMode.QUEUE) {
            if (queuedMovement != null) {
                boolean allMovementsComplete = activeMovementSlots.values().stream()
                        .allMatch(ICameraMovement::isComplete);
                if (allMovementsComplete) {
                    clearAllMovements(client, camera);
                    activeMovementSlots.clear();
                    activeMovementSlots.put(queuedMovementSlot, queuedMovement);
                    queuedMovement.start(client, camera);
                    movementManager.addMovement(queuedMovement, client, camera);
                    queuedMovement = null;
                    queuedMovementSlot = -1;
                }
            }
        } else {
            clearCompletedMovements(client, camera);
        }
    }
    private void clearAllMovements(MinecraftClient client, Camera camera) {
        for (ICameraMovement movement : activeMovementSlots.values()) {
            movement.queueReset(client, camera);
        }
        movementManager = new CameraMovementManager();
        activeMovementSlots.clear();
    }
    public void queueFinish(MinecraftClient client, Camera camera) {
        for (ICameraMovement movement : activeMovementSlots.values()) {
            movement.queueReset(client, camera);
        }
    }
    private void clearCompletedMovements(MinecraftClient client, Camera camera) {
        Iterator<Map.Entry<Integer, ICameraMovement>> iterator = activeMovementSlots.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<Integer, ICameraMovement> entry = iterator.next();
            if (entry.getValue().isComplete()) {
                entry.getValue().queueReset(client, camera);
                iterator.remove();
            }
        }
    }
    private void updatePerspective(MinecraftClient client, Camera camera) {
        if (client.player == null) return;
        double distance = camera.getPos().distanceTo(client.player.getEyePos());
        if (distance > FIRST_PERSON_THRESHOLD &&
                client.options.getPerspective() == Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.THIRD_PERSON_BACK);
        } else if (distance < FIRST_PERSON_THRESHOLD &&
                client.options.getPerspective() != Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.FIRST_PERSON);
        }
    }
    // Movement management methods
    public void cycleMovementType(boolean forward) {
        for (Map.Entry<Integer, ICameraMovement> entry : activeMovementSlots.entrySet()) {
            int slotIndex = entry.getKey();
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            int currentType = currentTypes.get(slotIndex);
            boolean wrap = WrapSettings.getWrapState(slotIndex);
            if (forward) {
                if (currentType < slotMovements.size() - 1 || wrap) {
                    currentTypes.set(slotIndex, wrap ?
                            (currentType + 1) % slotMovements.size() :
                            Math.min(currentType + 1, slotMovements.size() - 1));
                }
            } else {
                if (currentType > 0 || wrap) {
                    currentTypes.set(slotIndex, wrap ?
                            (currentType - 1 + slotMovements.size()) % slotMovements.size() :
                            Math.max(currentType - 1, 0));
                }
            }
        }
    }
    public void adjustDistance(int index, boolean increase) {
        ICameraMovement movement = getMovementAt(index);
        if (movement != null) {
            movement.adjustDistance(increase);
        }
    }
    // Slot management methods
    public void addMovement(int slotIndex, ICameraMovement movement) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            slots.get(slotIndex).add(movement);
        }
    }
    public void removeMovement(int slotIndex, int movementIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (movementIndex >= 0 && movementIndex < slotMovements.size() && slotMovements.size() > 1) {
                slotMovements.remove(movementIndex);
                if (currentTypes.get(slotIndex) >= slotMovements.size()) {
                    currentTypes.set(slotIndex, slotMovements.size() - 1);
                }
            }
        }
    }
    // Getter methods
    public int getMovementCount() {
        return slots.size();
    }
    public ICameraMovement getMovementAt(int index) {
        if (index >= 0 && index < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(index);
            int currentType = currentTypes.get(index);
            if (!slotMovements.isEmpty() && currentType < slotMovements.size()) {
                return slotMovements.get(currentType);
            }
        }
        return null;
    }
    public List<ICameraMovement> getAvailableMovementsForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            return new ArrayList<>(slots.get(slotIndex));
        }
        return new ArrayList<>();
    }
    public int getCurrentTypeForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < currentTypes.size()) {
            return currentTypes.get(slotIndex);
        }
        return 0;
    }
    public void swapMovements(int slotIndex, int index1, int index2) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (index1 >= 0 && index1 < slotMovements.size() &&
                    index2 >= 0 && index2 < slotMovements.size()) {
                Collections.swap(slotMovements, index1, index2);
            }
        }
    }
}
</file>

<file path="client/java/ninja/trek/CameraMovementManager.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.util.math.Vec3d;
import net.minecraft.client.render.Camera;
import ninja.trek.cameramovements.CameraTarget;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.MovementState;
import ninja.trek.mixin.client.CameraAccessor;
import java.util.*;
public class CameraMovementManager {
    private final List<ICameraMovement> activeMovements = new ArrayList<>();
    public void addMovement(ICameraMovement movement, MinecraftClient client, Camera camera) {
        movement.start(client, camera);
        activeMovements.add(movement);
    }
    public void update(MinecraftClient client, Camera camera) {
        if (activeMovements.isEmpty() || client.player == null) return;
        // Calculate states and total weight
        float totalWeight = 0;
        List<WeightedState> states = new ArrayList<>();
        Iterator<ICameraMovement> iterator = activeMovements.iterator();
        while (iterator.hasNext()) {
            ICameraMovement movement = iterator.next();
            MovementState state = movement.calculateState(client, camera);
            if (state.isComplete()) {
                iterator.remove();
            } else {
                float weight = movement.getWeight();
                // Apply raycast collision check to each movement's target
                CameraTarget adjustedTarget = state.getCameraTarget().withAdjustedPosition(client.player);
                states.add(new WeightedState(adjustedTarget, weight));
                totalWeight += weight;
            }
        }
        // Blend states based on weights
        if (!states.isEmpty()) {
            CameraTarget blendedTarget = blendStates(states, totalWeight);
            // Final collision check on blended position
            CameraTarget finalTarget = blendedTarget.withAdjustedPosition(client.player);
            applyCameraTarget(finalTarget, camera);
        }
    }
    private CameraTarget blendStates(List<WeightedState> states, float totalWeight) {
        if (states.size() == 1) {
            return states.get(0).target;
        }
        Vec3d blendedPos = Vec3d.ZERO;
        float blendedYaw = 0;
        float blendedPitch = 0;
        for (WeightedState weighted : states) {
            float normalizedWeight = weighted.weight / totalWeight;
            CameraTarget target = weighted.target;
            blendedPos = blendedPos.add(
                    target.getPosition().multiply(normalizedWeight)
            );
            blendedYaw += target.getYaw() * normalizedWeight;
            blendedPitch += target.getPitch() * normalizedWeight;
        }
        // Use the raycast type from the highest weight movement
        WeightedState highestWeightState = states.stream()
                .max(Comparator.comparing(ws -> ws.weight))
                .orElse(states.get(0));
        return new CameraTarget(blendedPos, blendedYaw, blendedPitch,
                highestWeightState.target.getRaycastType());
    }
    private void applyCameraTarget(CameraTarget target, Camera camera) {
        CameraAccessor accessor = (CameraAccessor) camera;
        accessor.invokesetPos(target.getPosition());
        accessor.invokeSetRotation(target.getYaw(), target.getPitch());
    }
    private static class WeightedState {
        final CameraTarget target;
        final float weight;
        WeightedState(CameraTarget target, float weight) {
            this.target = target;
            this.weight = weight;
        }
    }
}
</file>

<file path="client/java/ninja/trek/CameraMovementRegistry.java">
package ninja.trek;
import ninja.trek.cameramovements.CameraMovementType;
import ninja.trek.cameramovements.ICameraMovement;
import net.fabricmc.loader.api.FabricLoader;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.net.URL;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
public class CameraMovementRegistry {
    private static final List<Class<? extends ICameraMovement>> movementTypes = new ArrayList<>();
    private static int currentTypeIndex = 0;
    private static final String BASE_PACKAGE = "ninja.trek.cameramovements";
    public static void initialize() {
        try {
            scanPackage(BASE_PACKAGE);
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to scan for camera movements", e);
        }
    }
    private static void scanPackage(String packageName) {
        try {
            String path = packageName.replace('.', '/');
            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
            Enumeration<URL> resources = classLoader.getResources(path);
            while (resources.hasMoreElements()) {
                URL resource = resources.nextElement();
                String protocol = resource.getProtocol();
                if (protocol.equals("file")) {
                    scanDirectory(new File(resource.getFile()), packageName);
                } else if (protocol.equals("jar")) {
                    scanJar(resource, path);
                }
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Error scanning package: " + packageName, e);
        }
    }
    private static void scanDirectory(File directory, String packageName) {
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    scanDirectory(file, packageName + "." + file.getName());
                } else if (file.getName().endsWith(".class")) {
                    String className = packageName + "." + file.getName().substring(0, file.getName().length() - 6);
                    processClass(className);
                }
            }
        }
    }
    private static void scanJar(URL resourceUrl, String path) {
        String jarPath = resourceUrl.getPath().substring(5, resourceUrl.getPath().indexOf("!"));
        try (JarFile jarFile = new JarFile(jarPath)) {
            Enumeration<JarEntry> entries = jarFile.entries();
            while (entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String entryName = entry.getName();
                if (entryName.startsWith(path) && entryName.endsWith(".class")) {
                    String className = entryName.substring(0, entryName.length() - 6).replace('/', '.');
                    processClass(className);
                }
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Error scanning JAR file: " + jarPath, e);
        }
    }
    private static void processClass(String className) {
        try {
            Class<?> cls = Class.forName(className);
            if (ICameraMovement.class.isAssignableFrom(cls) &&
                    cls.isAnnotationPresent(CameraMovementType.class)) {
                CameraMovementType annotation = cls.getAnnotation(CameraMovementType.class);
                if (annotation.enabled()) {
                    @SuppressWarnings("unchecked")
                    Class<? extends ICameraMovement> movementClass = (Class<? extends ICameraMovement>) cls;
                    registerMovement(movementClass);
                }
            }
        } catch (ClassNotFoundException e) {
            Craneshot.LOGGER.error("Error loading class: " + className, e);
        }
    }
    public static void registerMovement(Class<? extends ICameraMovement> movementClass) {
        if (!movementTypes.contains(movementClass)) {
            movementTypes.add(movementClass);
        }
    }
    public static ICameraMovement createCurrentMovement() {
        try {
            Constructor<? extends ICameraMovement> constructor = movementTypes.get(currentTypeIndex).getDeclaredConstructor();
            return constructor.newInstance();
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to create movement instance", e);
            return null;
        }
    }
    public static List<MovementInfo> getAllMovements() {
        List<MovementInfo> movements = new ArrayList<>();
        for (Class<? extends ICameraMovement> cls : movementTypes) {
            CameraMovementType annotation = cls.getAnnotation(CameraMovementType.class);
            if (annotation != null) {
                movements.add(new MovementInfo(
                        annotation.name().isEmpty() ? cls.getSimpleName() : annotation.name(),
                        annotation.description(),
                        cls
                ));
            }
        }
        return movements;
    }
    public static void cycleNextMovement() {
        currentTypeIndex = (currentTypeIndex + 1) % movementTypes.size();
    }
    public static String getCurrentMovementName() {
        Class<? extends ICameraMovement> currentClass = movementTypes.get(currentTypeIndex);
        CameraMovementType annotation = currentClass.getAnnotation(CameraMovementType.class);
        return annotation != null && !annotation.name().isEmpty() ?
                annotation.name() : currentClass.getSimpleName();
    }
    public static int getMovementCount() {
        return movementTypes.size();
    }
    // Helper class to hold movement type information
    public static class MovementInfo {
        private final String name;
        private final String description;
        private final Class<? extends ICameraMovement> movementClass;
        public MovementInfo(String name, String description, Class<? extends ICameraMovement> movementClass) {
            this.name = name;
            this.description = description;
            this.movementClass = movementClass;
        }
        public String getName() { return name; }
        public String getDescription() { return description; }
        public Class<? extends ICameraMovement> getMovementClass() { return movementClass; }
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraMovementType.java">
package ninja.trek.cameramovements;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CameraMovementType {
    String name() default "";
    String description() default "";
    boolean enabled() default true;
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraState.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
public class CameraState {
    private Vec3d position;
    private float yaw;
    private float pitch;
    public CameraState(Vec3d position, float yaw, float pitch) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public static CameraState fromCamera(Camera camera) {
        return new CameraState(camera.getPos(), camera.getYaw(), camera.getPitch());
    }
    public Vec3d getPosition() { return position; }
    public float getYaw() { return yaw; }
    public float getPitch() { return pitch; }
    public CameraState lerp(CameraState other, double t) {
        Vec3d lerpedPos = this.position.lerp(other.position, t);
        float lerpedYaw = lerpAngle(this.yaw, other.yaw, (float)t);
        float lerpedPitch = lerpAngle(this.pitch, other.pitch, (float)t);
        return new CameraState(lerpedPos, lerpedYaw, lerpedPitch);
    }
    private float lerpAngle(float start, float end, float t) {
        float diff = end - start;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return start + diff * t;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraTarget.java">
package ninja.trek.cameramovements;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
public class CameraTarget {
    private Vec3d position;
    private float yaw;
    private float pitch;
    private RaycastType raycastType;
    public CameraTarget(Vec3d position, float yaw, float pitch, RaycastType raycastType) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
        this.raycastType = raycastType;
    }
    public static CameraTarget fromCamera(Camera camera) {
        return new CameraTarget(camera.getPos(), camera.getYaw(), camera.getPitch(), RaycastType.NONE);
    }
    public static CameraTarget fromPlayer(PlayerEntity player) {
        return new CameraTarget(player.getEyePos(), player.getYaw(), player.getPitch(), RaycastType.NONE);
    }
    public static CameraTarget fromDistance(PlayerEntity player, double distance, RaycastType raycastType) {
        double yaw = Math.toRadians(player.getYaw());
        double pitch = Math.toRadians(player.getPitch());
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * distance;
        double yOffset = Math.sin(pitch) * distance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * distance;
        Vec3d targetPos = player.getEyePos().add(xOffset, yOffset, zOffset);
        return new CameraTarget(targetPos, player.getYaw(), player.getPitch(), raycastType);
    }
    public CameraTarget lerp(CameraTarget other, double t) {
        Vec3d lerpedPos = this.position.lerp(other.position, t);
        float lerpedYaw = lerpAngle(this.yaw, other.yaw, (float)t);
        float lerpedPitch = lerpAngle(this.pitch, other.pitch, (float)t);
        return new CameraTarget(lerpedPos, lerpedYaw, lerpedPitch, this.raycastType);
    }
    private float lerpAngle(float start, float end, float t) {
        float diff = end - start;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return start + diff * t;
    }
    public Vec3d getPosition() {
        return position;
    }
    public float getYaw() {
        return yaw;
    }
    public float getPitch() {
        return pitch;
    }
    public RaycastType getRaycastType() {
        return raycastType;
    }
    public void setPosition(Vec3d position) {
        this.position = position;
    }
    public CameraTarget withAdjustedPosition(PlayerEntity player) {
        Vec3d adjustedPos = RaycastUtil.adjustForCollision(player.getEyePos(), this.position, this.raycastType);
        return new CameraTarget(adjustedPos, this.yaw, this.pitch, this.raycastType);
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/ICameraMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
public interface ICameraMovement {
    void start(MinecraftClient client, Camera camera);
    MovementState calculateState(MinecraftClient client, Camera camera);
    void queueReset(MinecraftClient client, Camera camera);
    void adjustDistance(boolean increase);
    String getName();
    float getWeight(); // For blending calculations
    boolean isComplete(); // To determine if movement should be removed
}
</file>

<file path="client/java/ninja/trek/cameramovements/movements/EasingMovement.java">
package ninja.trek.cameramovements.movements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import ninja.trek.cameramovements.*;
import ninja.trek.config.AbstractMovementSettings;
import ninja.trek.config.MovementSetting;
@CameraMovementType(
        name = "Easing Movement",
        description = "Moves the camera in a smooth eased motion"
)
public class EasingMovement extends AbstractMovementSettings implements ICameraMovement {
    @MovementSetting(label = "Position Easing Factor", min = 0.01, max = 1.0)
    private double positionEasingFactor = 0.1f;
    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10;
    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0f;
    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0f;
    private CameraTarget currentTarget;
    private CameraTarget destinationTarget;
    private boolean resetting = false;
    private float weight = 1.0f;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return;
        currentTarget = CameraTarget.fromCamera(camera);
        destinationTarget = CameraTarget.fromDistance(player, targetDistance, getRaycastType());
        resetting = false;
        weight = 1.0f;
    }
    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return new MovementState(currentTarget, true);
        // Update destination if not resetting
        if (!resetting) {
            destinationTarget = CameraTarget.fromDistance(player, targetDistance, getRaycastType());
        }
        // Calculate new position and rotation with easing
        currentTarget = currentTarget.lerp(destinationTarget, positionEasingFactor);
        // Check if we're close enough to complete
        boolean complete = resetting &&
                currentTarget.getPosition().distanceTo(player.getEyePos()) < 0.1;
        return new MovementState(currentTarget, complete);
    }
    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        if (client.player == null) return;
        resetting = true;
        destinationTarget = CameraTarget.fromPlayer(client.player);
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? 1.1 : 0.9;
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
    }
    @Override
    public String getName() {
        return "Easing";
    }
    @Override
    public float getWeight() {
        return weight;
    }
    @Override
    public boolean isComplete() {
        return resetting && MinecraftClient.getInstance().player != null &&
                currentTarget.getPosition().distanceTo(MinecraftClient.getInstance().player.getEyePos()) < 0.1;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/movements/LinearMovement.java">
package ninja.trek.cameramovements.movements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.cameramovements.CameraMovementType;
import ninja.trek.cameramovements.CameraTarget;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.MovementState;
import ninja.trek.config.AbstractMovementSettings;
import ninja.trek.config.MovementSetting;
@CameraMovementType(
        name = "Linear Movement",
        description = "Moves the camera in a straight line at constant speed"
)
public class LinearMovement extends AbstractMovementSettings implements ICameraMovement {
    @MovementSetting(label = "Movement Speed", min = 0.1, max = 5.0)
    private double movementSpeed = 1.0;
    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10.0;
    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0;
    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0;
    private CameraTarget currentTarget;
    private CameraTarget destinationTarget;
    private boolean resetting = false;
    private float weight = 1.0f;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return;
        currentTarget = CameraTarget.fromCamera(camera);
        destinationTarget = CameraTarget.fromDistance(player, targetDistance, getRaycastType());
        resetting = false;
        weight = 1.0f;
    }
    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return new MovementState(currentTarget, true);
        // Update destination target if not resetting
        if (!resetting) {
            destinationTarget = CameraTarget.fromDistance(player, targetDistance, getRaycastType());
        }
        // Calculate movement for this frame
        double distanceToMove = movementSpeed * (1.0/20.0); // Convert to blocks per tick
        Vec3d currentPos = currentTarget.getPosition();
        Vec3d targetPos = destinationTarget.getPosition();
        // Calculate direction vector
        double dx = targetPos.x - currentPos.x;
        double dy = targetPos.y - currentPos.y;
        double dz = targetPos.z - currentPos.z;
        double totalDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);
        boolean complete = false;
        if (totalDistance < distanceToMove) {
            // If we're close enough, snap to the destination
            currentTarget = destinationTarget;
            complete = resetting && totalDistance < 0.1;
        } else {
            // Normalize direction vector and multiply by speed
            double scale = distanceToMove / totalDistance;
            double newX = currentPos.x + dx * scale;
            double newY = currentPos.y + dy * scale;
            double newZ = currentPos.z + dz * scale;
            // Linear interpolation of rotation
            float progress = (float)(distanceToMove / totalDistance);
            float newYaw = lerpAngle(currentTarget.getYaw(), destinationTarget.getYaw(), progress);
            float newPitch = lerpAngle(currentTarget.getPitch(), destinationTarget.getPitch(), progress);
            currentTarget = new CameraTarget(
                    new Vec3d(newX, newY, newZ),
                    newYaw,
                    newPitch,
                    getRaycastType()
            );
        }
        return new MovementState(currentTarget, complete);
    }
    private float lerpAngle(float start, float end, float t) {
        float diff = end - start;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return start + diff * t;
    }
    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        if (client.player == null) return;
        resetting = true;
        destinationTarget = CameraTarget.fromPlayer(client.player);
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? 1.1 : 0.9;
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
    }
    @Override
    public String getName() {
        return "Linear";
    }
    @Override
    public float getWeight() {
        return weight;
    }
    @Override
    public boolean isComplete() {
        return resetting && MinecraftClient.getInstance().player != null &&
                currentTarget.getPosition().distanceTo(MinecraftClient.getInstance().player.getEyePos()) < 0.1;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/MovementState.java">
package ninja.trek.cameramovements;
public class MovementState {
    private final CameraTarget target;
    private final boolean isComplete;
    public MovementState(CameraTarget target, boolean isComplete) {
        this.target = target;
        this.isComplete = isComplete;
    }
    public CameraTarget getCameraTarget() {
        return target;
    }
    public boolean isComplete() {
        return isComplete;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/RaycastType.java">
package ninja.trek.cameramovements;
/**
 * Enum defining different raycast behaviors for camera collision handling
 */
public enum RaycastType {
    /**
     * No raycast collision checking - camera can clip through blocks
     */
    NONE,
    /**
     * Raycasts from player to desired camera position.
     * If collision detected, moves camera closer to player.
     * Behaves like default Minecraft third person camera.
     */
    NEAR,
    /**
     * Raycasts from desired camera position towards player.
     * If camera would be inside block, moves it to first non-solid position.
     * Provides more stable distant shots by preferring to keep camera far out.
     */
    FAR
}
</file>

<file path="client/java/ninja/trek/cameramovements/RaycastUtil.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.RaycastContext;
/**
 * Utility class for handling camera raycasting and collision detection
 */
public class RaycastUtil {
    private static final double CAMERA_OFFSET = 0.1; // Small offset to prevent z-fighting
    /**
     * Adjusts a target camera position based on raycast collision checks
     */
    public static Vec3d adjustForCollision(Vec3d playerPos, Vec3d targetPos, RaycastType raycastType) {
        if (raycastType == RaycastType.NONE) {
            return targetPos;
        }
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.world == null) return targetPos;
        RaycastContext.FluidHandling fluidHandling = RaycastContext.FluidHandling.NONE;
        RaycastContext.ShapeType shapeType = RaycastContext.ShapeType.VISUAL;
        if (raycastType == RaycastType.NEAR) {
            // Cast from player to desired camera position
            BlockHitResult hit = client.world.raycast(new RaycastContext(
                    playerPos,
                    targetPos,
                    shapeType,
                    fluidHandling,
                    client.player
            ));
            if (hit.getType() == HitResult.Type.BLOCK) {
                // Move slightly in front of the hit position
                Vec3d hitPos = hit.getPos();
                Vec3d directionVector = hitPos.subtract(playerPos).normalize();
                return hitPos.subtract(directionVector.multiply(CAMERA_OFFSET));
            }
        } else if (raycastType == RaycastType.FAR) {
            // Cast from desired camera position back to player
            BlockHitResult hit = client.world.raycast(new RaycastContext(
                    targetPos,
                    playerPos,
                    shapeType,
                    fluidHandling,
                    client.player
            ));
            if (hit.getType() == HitResult.Type.BLOCK) {
                // Move slightly away from the hit position towards the camera direction
                Vec3d hitPos = hit.getPos();
                Vec3d directionVector = targetPos.subtract(playerPos).normalize();
                return hitPos.add(directionVector.multiply(CAMERA_OFFSET));
            }
        }
        return targetPos;
    }
}
</file>

<file path="client/java/ninja/trek/config/AbstractMovementSettings.java">
package ninja.trek.config;
import ninja.trek.cameramovements.RaycastType;
import java.lang.reflect.Field;
import java.util.HashMap;
import java.util.Map;
public abstract class AbstractMovementSettings {
    @MovementSetting(label = "Raycast Type", type = MovementSettingType.ENUM)
    protected RaycastType raycastType = RaycastType.NEAR;
    public AbstractMovementSettings() {
        loadSettings();
    }
    public Map<String, Object> getSettings() {
        Map<String, Object> settings = new HashMap<>();
        for (Field field : this.getClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(MovementSetting.class)) {
                field.setAccessible(true);
                try {
                    Object value = field.get(this);
                    // Handle enum serialization
                    if (value instanceof Enum<?>) {
                        settings.put(field.getName(), ((Enum<?>) value).name());
                    } else {
                        settings.put(field.getName(), value);
                    }
                } catch (IllegalAccessException e) {
                    e.printStackTrace();
                }
            }
        }
        return settings;
    }
    public void updateSetting(String key, Object value) {
        try {
            Field field = this.getClass().getDeclaredField(key);
            if (field.isAnnotationPresent(MovementSetting.class)) {
                field.setAccessible(true);
                if (field.getType().isEnum() && value instanceof String) {
                    // Handle enum deserialization
                    @SuppressWarnings("unchecked")
                    Object enumValue = Enum.valueOf(field.getType().asSubclass(Enum.class), (String) value);
                    field.set(this, enumValue);
                } else {
                    field.set(this, value);
                }
                saveSettings();
            }
        } catch (NoSuchFieldException | IllegalAccessException e) {
            e.printStackTrace();
        }
    }
    public RaycastType getRaycastType() {
        return raycastType;
    }
    private void saveSettings() {
        MovementConfigManager.updateMovementSettings(this.getClass().getSimpleName(), getSettings());
    }
    private void loadSettings() {
        Map<String, Object> savedSettings = MovementConfigManager.getSettingsForMovement(this.getClass().getSimpleName());
        for (Map.Entry<String, Object> entry : savedSettings.entrySet()) {
            updateSetting(entry.getKey(), entry.getValue());
        }
    }
}
</file>

<file path="client/java/ninja/trek/config/MenuOverlayScreen.java">
package ninja.trek.config;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.gui.DrawContext;
import net.minecraft.client.gui.screen.Screen;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.CheckboxWidget;
import net.minecraft.text.Text;
import ninja.trek.CameraMovementRegistry;
import ninja.trek.CraneshotClient;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.movements.EasingMovement;
import java.lang.reflect.Field;
import java.util.*;
public class MenuOverlayScreen extends Screen {
    private static final Map<Integer, Set<Integer>> expandedMovements = new HashMap<>();
    private static final int MARGIN = 20;
    private static final int TAB_HEIGHT = 30;
    private static final int CONTENT_START_Y = TAB_HEIGHT - 10;
    private static final double SCROLL_SPEED = 10;
    private static boolean isMenuOpen = false;
    private int selectedTab = 0;
    private final List<SettingSlider> settingSliders = new ArrayList<>();
    private int scrollOffset = 0;
    private int maxScroll = 0;
    private int guiWidth;
    private int guiHeight;
    private int centerX;
    private int centerY;
    private int selectedMovementTypeIndex = 0;
    public MenuOverlayScreen() {
        super(Text.literal("CraneShot Settings"));
        isMenuOpen = true;
    }
    @Override
    protected void init() {
        this.guiWidth = this.width - (MARGIN * 2);
        this.guiHeight = this.height - (MARGIN * 2);
        this.centerX = MARGIN;
        this.centerY = MARGIN;
        int visibleStartY = centerY + CONTENT_START_Y;
        int visibleEndY = centerY + guiHeight;
        int height = 0;
        // Create tab buttons
        int tabCount = CraneshotClient.CAMERA_CONTROLLER.getMovementCount() + 1;
        int tabWidth = Math.min(100, (guiWidth - 20) / tabCount);
        for (int i = 0; i <= CraneshotClient.CAMERA_CONTROLLER.getMovementCount(); i++) {
            int tabIndex = i;
            String tabName = (i == 0) ? "General" : "Slot " + i;
            ButtonWidget slotBtn = ButtonWidget.builder(Text.literal(tabName), button -> switchTab(tabIndex))
                    .dimensions(centerX + (i * (tabWidth + 5)), centerY, tabWidth, 20)
                    .build();
            height = slotBtn.getHeight();
            this.addDrawableChild(slotBtn);
        }
        int BUTTON_HEIGHT = height;
        int MOVEMENT_SPACING = BUTTON_HEIGHT - 5;
        int MOVEMENT_ROW_HEIGHT = BUTTON_HEIGHT + 5;
        int SETTING_HEIGHT = BUTTON_HEIGHT + 5;
        if (selectedTab > 0) {
            int slotIndex = selectedTab - 1;
            // Add controls bar if within visible area
            if (visibleStartY <= centerY + CONTENT_START_Y + BUTTON_HEIGHT) {
                int addButtonWidth = 60;
                int typeButtonWidth = 120;
                int spacing = 10;
                // Add movement button
                this.addDrawableChild(ButtonWidget.builder(Text.literal("Add"), button -> addMovement(slotIndex))
                        .dimensions(centerX + 10, centerY + CONTENT_START_Y, addButtonWidth, BUTTON_HEIGHT)
                        .build());
                // Get current movement type for display
                List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
                String currentTypeName = movements.isEmpty() ? "None" :
                        movements.get(selectedMovementTypeIndex).getName();
                // Movement type selector button
                this.addDrawableChild(ButtonWidget.builder(Text.literal("Type: " + currentTypeName),
                                button -> cycleMovementType())
                        .dimensions(centerX + addButtonWidth + spacing + 10, centerY + CONTENT_START_Y,
                                typeButtonWidth, BUTTON_HEIGHT)
                        .build());
                // Wrap checkbox
                this.addDrawableChild(CheckboxWidget.builder(Text.literal("Wrap"), this.textRenderer)
                        .pos(centerX + addButtonWidth + typeButtonWidth + spacing + 20, centerY + CONTENT_START_Y)
                        .checked(WrapSettings.getWrapState(slotIndex))
                        .callback((checkbox, checked) -> WrapSettings.setWrapState(slotIndex, checked))
                        .build());
            }
            // Render movement list
            List<ICameraMovement> movements = CraneshotClient.CAMERA_CONTROLLER.getAvailableMovementsForSlot(slotIndex);
            int yOffset = CONTENT_START_Y + BUTTON_HEIGHT + 10;
            for (int i = 0; i < movements.size(); i++) {
                int index = i;
                ICameraMovement movement = movements.get(i);
                int rowY = centerY + yOffset - scrollOffset;
                if (rowY >= visibleStartY - BUTTON_HEIGHT && rowY <= visibleEndY) {
                    // Control buttons on the left
                    int controlX = centerX + 10;
                    // Up arrow (if not first)
                    if (i > 0) {
                        this.addDrawableChild(ButtonWidget.builder(Text.literal("↑"),
                                        button -> moveMovement(slotIndex, index, index - 1))
                                .dimensions(controlX, rowY, 20, BUTTON_HEIGHT)
                                .build());
                    }
                    controlX += 25;
                    // Down arrow (if not last)
                    if (i < movements.size() - 1) {
                        this.addDrawableChild(ButtonWidget.builder(Text.literal("↓"),
                                        button -> moveMovement(slotIndex, index, index + 1))
                                .dimensions(controlX, rowY, 20, BUTTON_HEIGHT)
                                .build());
                    }
                    controlX += 25;
                    // Delete button (if more than one movement)
                    if (movements.size() > 1) {
                        this.addDrawableChild(ButtonWidget.builder(Text.literal("×"),
                                        button -> deleteMovement(slotIndex, index))
                                .dimensions(controlX, rowY, 20, BUTTON_HEIGHT)
                                .build());
                    }
                    controlX += 25;
                    // Movement name button with expand/collapse indicator
                    int movementButtonWidth = Math.min(200, guiWidth / 3);
                    this.addDrawableChild(ButtonWidget.builder(
                                    Text.literal((isMovementExpanded(slotIndex, index) ? "▼ " : "▶ ") + movement.getName()),
                                    button -> {
                                        toggleMovementExpanded(slotIndex, index);
                                        reinitialize();
                                    })
                            .dimensions(controlX, rowY, movementButtonWidth, BUTTON_HEIGHT)
                            .build());
                }
                yOffset += MOVEMENT_ROW_HEIGHT;
                // Settings section (when expanded)
                if (movement instanceof AbstractMovementSettings settings && isMovementExpanded(slotIndex, index)) {
                    List<Field> settingFields = new ArrayList<>();
                    for (Field field : settings.getClass().getDeclaredFields()) {
                        if (field.isAnnotationPresent(MovementSetting.class)) {
                            settingFields.add(field);
                        }
                    }
                    // Calculate layout for settings
                    int totalWidth = guiWidth - 40;
                    int labelWidth = Math.min(150, totalWidth / 4);
                    int controlWidth = Math.min(200, totalWidth / 2);
                    int settingWidth = labelWidth + controlWidth + 10;
                    int columnsCount = Math.max(1, Math.min(3, (totalWidth + 20) / (settingWidth + 20)));
                    int settingsPerColumn = (int) Math.ceil(settingFields.size() / (double) columnsCount);
                    for (int fieldIndex = 0; fieldIndex < settingFields.size(); fieldIndex++) {
                        Field field = settingFields.get(fieldIndex);
                        MovementSetting annotation = field.getAnnotation(MovementSetting.class);
                        field.setAccessible(true);
                        try {
                            int column = fieldIndex / settingsPerColumn;
                            int row = fieldIndex % settingsPerColumn;
                            int settingX = centerX + 20 + column * (settingWidth + 20);
                            int settingY = centerY + yOffset + (row * SETTING_HEIGHT) - scrollOffset;
                            if (settingY >= visibleStartY - BUTTON_HEIGHT && settingY <= visibleEndY) {
                                // Label button for all setting types
                                ButtonWidget labelButton = ButtonWidget.builder(
                                                Text.literal(annotation.label()),
                                                button -> {}
                                        )
                                        .dimensions(settingX, settingY, labelWidth, BUTTON_HEIGHT)
                                        .build();
                                this.addDrawableChild(labelButton);
                                // Create control based on setting type
                                if (annotation.type() == MovementSettingType.ENUM) {
                                    ButtonWidget enumButton = SettingWidget.createEnumButton(
                                            settingX + labelWidth + 10,
                                            settingY,
                                            controlWidth,
                                            BUTTON_HEIGHT,
                                            field.getName(),
                                            settings,
                                            annotation
                                    );
                                    if (enumButton != null) {
                                        this.addDrawableChild(enumButton);
                                    }
                                } else {
                                    double value = ((Number) field.get(settings)).doubleValue();
                                    this.addDrawableChild(SettingWidget.createSlider(
                                            settingX + labelWidth + 10,
                                            settingY,
                                            controlWidth,
                                            BUTTON_HEIGHT,
                                            Text.literal(annotation.label()),
                                            annotation.min(),
                                            annotation.max(),
                                            value,
                                            field.getName(),
                                            settings
                                    ));
                                }
                            }
                        } catch (IllegalAccessException e) {
                            e.printStackTrace();
                        }
                    }
                    yOffset += (settingsPerColumn * SETTING_HEIGHT) + MOVEMENT_SPACING;
                } else {
                    yOffset += MOVEMENT_SPACING;
                }
            }
            int contentHeight = yOffset - (CONTENT_START_Y + BUTTON_HEIGHT + 10);
            int visibleHeight = guiHeight - CONTENT_START_Y - 10;
            maxScroll = Math.max(0, contentHeight - visibleHeight);
        } else if (selectedTab == 0) {
            addGeneralSettings();
        }
    }
    private void cycleMovementType() {
        List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
        if (!movements.isEmpty()) {
            selectedMovementTypeIndex = (selectedMovementTypeIndex + 1) % movements.size();
            reinitialize();
        }
    }
    private void addMovement(int slotIndex) {
        List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
        if (!movements.isEmpty()) {
            try {
                ICameraMovement newMovement = movements.get(selectedMovementTypeIndex)
                        .getMovementClass()
                        .getDeclaredConstructor()
                        .newInstance();
                CraneshotClient.CAMERA_CONTROLLER.addMovement(slotIndex, newMovement);
                reinitialize();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    // ... rest of the existing methods (deleteMovement, moveMovement, etc.) remain unchanged
    @Override
    public void resize(MinecraftClient client, int width, int height) {
        super.resize(client, width, height);
        this.scrollOffset = 0;
        this.reinitialize();
    }
    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        context.fill(0, 0, this.width, this.height, 0x80000000);
        context.fill(
                centerX,
                centerY + CONTENT_START_Y,
                centerX + guiWidth,
                centerY + guiHeight,
                0xC0000000
        );
        super.render(context, mouseX, mouseY, delta);
        if (maxScroll > 0) {
            if (scrollOffset > 0) {
                context.drawCenteredTextWithShadow(
                        this.textRenderer,
                        Text.literal("▲"),
                        centerX + guiWidth - 15,
                        centerY + CONTENT_START_Y,
                        0xFFFFFF
                );
            }
            if (scrollOffset < maxScroll) {
                context.drawCenteredTextWithShadow(
                        this.textRenderer,
                        Text.literal("▼"),
                        centerX + guiWidth - 15,
                        centerY + guiHeight - 15,
                        0xFFFFFF
                );
            }
        }
    }
    private void addGeneralSettings() {
        int yOffset = CONTENT_START_Y + 20;
        int buttonWidth = 200;
        int buttonX = centerX + (guiWidth - buttonWidth) / 2;
        // Add Transition Mode selection
        this.addDrawableChild(ButtonWidget.builder(
                        Text.literal("Transition Mode: " + TransitionModeManager.getCurrentMode().getDisplayName()),
                        button -> {
                            // Cycle through transition modes
                            TransitionMode[] modes = TransitionMode.values();
                            int currentIndex = Arrays.asList(modes).indexOf(TransitionModeManager.getCurrentMode());
                            int nextIndex = (currentIndex + 1) % modes.length;
                            TransitionModeManager.setCurrentMode(modes[nextIndex]);
                            button.setMessage(Text.literal("Transition Mode: " + modes[nextIndex].getDisplayName()));
                        })
                .dimensions(buttonX, centerY + yOffset, buttonWidth, 20)
                .build());
    }
    // Keep existing helper methods
    private boolean isMovementExpanded(int slotIndex, int movementIndex) {
        return expandedMovements.computeIfAbsent(slotIndex, k -> new HashSet<>()).contains(movementIndex);
    }
    private void toggleMovementExpanded(int slotIndex, int movementIndex) {
        Set<Integer> expanded = expandedMovements.computeIfAbsent(slotIndex, k -> new HashSet<>());
        if (!expanded.remove(movementIndex)) {
            expanded.add(movementIndex);
        }
    }
    private void deleteMovement(int slotIndex, int movementIndex) {
        CraneshotClient.CAMERA_CONTROLLER.removeMovement(slotIndex, movementIndex);
        reinitialize();
    }
    private void moveMovement(int slotIndex, int fromIndex, int toIndex) {
        CraneshotClient.CAMERA_CONTROLLER.swapMovements(slotIndex, fromIndex, toIndex);
        reinitialize();
    }
    private void reinitialize() {
        this.clearChildren();
        this.init();
    }
    @Override
    public boolean mouseScrolled(double mouseX, double mouseY, double horizontalAmount, double verticalAmount) {
        if (verticalAmount != 0) {
            scroll((int)(-verticalAmount * SCROLL_SPEED));
            return true;
        }
        return super.mouseScrolled(mouseX, mouseY, horizontalAmount, verticalAmount);
    }
    @Override
    public boolean keyPressed(int keyCode, int scanCode, int modifiers) {
        if (keyCode == CraneshotClient.toggleMenuKey.getDefaultKey().getCode()) toggleMenu();
        return true;
    }
    private void scroll(int amount) {
        if (maxScroll > 0) {
            scrollOffset = Math.max(0, Math.min(scrollOffset + amount, maxScroll));
            clearChildren();
            init();
        }
    }
    private void switchTab(int index) {
        selectedTab = index;
        scrollOffset = 0;
        clearChildren();
        init();
    }
    public static void toggleMenu() {
        MinecraftClient client = MinecraftClient.getInstance();
        if (isMenuOpen) {
            client.setScreen(null);
            isMenuOpen = false;
        } else {
            client.setScreen(new MenuOverlayScreen());
            isMenuOpen = true;
        }
    }
    @Override
    public boolean shouldPause() {
        return false;
    }
}
</file>

<file path="client/java/ninja/trek/config/MovementConfigManager.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import net.minecraft.client.MinecraftClient;
import ninja.trek.cameramovements.ICameraMovement;
import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.Map;
public class MovementConfigManager {
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_movements.json");
    private static Map<String, Map<String, Object>> movementSettings = new HashMap<>();
    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) return;
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            Type type = new TypeToken<Map<String, Map<String, Object>>>() {}.getType();
            movementSettings = GSON.fromJson(reader, type);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static void saveSettings() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(movementSettings, writer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static Map<String, Object> getSettingsForMovement(String movementName) {
        return movementSettings.getOrDefault(movementName, new HashMap<>());
    }
    public static void updateMovementSettings(String movementName, Map<String, Object> settings) {
        movementSettings.put(movementName, settings);
        saveSettings();
    }
}
</file>

<file path="client/java/ninja/trek/config/MovementSetting.java">
package ninja.trek.config;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface MovementSetting {
    String label();
    double min() default 0;
    double max() default 100;
    MovementSettingType type() default MovementSettingType.SLIDER;
}
</file>

<file path="client/java/ninja/trek/config/MovementSettingType.java">
package ninja.trek.config;
enum MovementSettingType {
    SLIDER,
    ENUM
}
</file>

<file path="client/java/ninja/trek/config/SettingSlider.java">
package ninja.trek.config;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.SliderWidget;
import net.minecraft.text.Text;
import ninja.trek.cameramovements.RaycastType;
class SettingSlider extends SliderWidget {
    private final double min;
    private final double max;
    private final String fieldName;
    private final AbstractMovementSettings settings;
    private final Text label;
    public SettingSlider(int x, int y, int width, int height, Text label,
                         double min, double max, double value, String fieldName, AbstractMovementSettings settings) {
        super(x, y, width, height, label, (value - min) / (max - min));
        this.min = min;
        this.max = max;
        this.fieldName = fieldName;
        this.settings = settings;
        this.label = label;
        updateMessage();
    }
    @Override
    protected void updateMessage() {
        setMessage(Text.literal(String.format("%.2f", getValue())));
    }
    @Override
    protected void applyValue() {
        double value = min + (max - min) * this.value;
        settings.updateSetting(fieldName, value);
    }
    public Text getLabel() {
        return label;
    }
    private double getValue() {
        return min + (max - min) * this.value;
    }
}
</file>

<file path="client/java/ninja/trek/config/SettingWidget.java">
package ninja.trek.config;
import net.minecraft.client.gui.widget.ButtonWidget;
import net.minecraft.client.gui.widget.SliderWidget;
import net.minecraft.text.Text;
public class SettingWidget {
    public static ButtonWidget createEnumButton(int x, int y, int width, int height,
                                                String fieldName, AbstractMovementSettings settings, MovementSetting annotation) {
        try {
            var field = settings.getClass().getDeclaredField(fieldName);
            field.setAccessible(true);
            if (!field.getType().isEnum()) {
                throw new IllegalStateException("Field is not an enum type: " + fieldName);
            }
            Object currentValue = field.get(settings);
            if (!(currentValue instanceof Enum<?>)) {
                throw new IllegalStateException("Field value is not an enum: " + fieldName);
            }
            return ButtonWidget.builder(
                    Text.literal(annotation.label() + ": " + currentValue.toString()),
                    button -> {
                        try {
                            Enum<?>[] values = ((Enum<?>) currentValue).getDeclaringClass().getEnumConstants();
                            int currentIndex = ((Enum<?>) currentValue).ordinal();
                            int nextIndex = (currentIndex + 1) % values.length;
                            field.set(settings, values[nextIndex]);
                            settings.updateSetting(fieldName, values[nextIndex].name());
                            button.setMessage(Text.literal(annotation.label() + ": " + values[nextIndex].toString()));
                        } catch (IllegalAccessException e) {
                            e.printStackTrace();
                        }
                    }
            ).dimensions(x, y, width, height).build();
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
    public static SliderWidget createSlider(int x, int y, int width, int height, Text label,
                                            double min, double max, double value, String fieldName, AbstractMovementSettings settings) {
        return new SettingSlider(x, y, width, height, label, min, max, value, fieldName, settings);
    }
}
</file>

<file path="client/java/ninja/trek/config/TransitionMode.java">
// TransitionMode.java
package ninja.trek.config;
import net.minecraft.client.MinecraftClient;
import java.io.FileReader;
import java.io.FileWriter;
public enum TransitionMode {
    IMMEDIATE("Immediate Switch"),
    INTERPOLATE("Interpolate"),
    QUEUE("Queue");
    private final String displayName;
    TransitionMode(String displayName) {
        this.displayName = displayName;
    }
    public String getDisplayName() {
        return displayName;
    }
}
</file>

<file path="client/java/ninja/trek/config/TransitionModeManager.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.client.MinecraftClient;
import java.io.*;
public class TransitionModeManager {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_transition.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static TransitionMode currentMode = TransitionMode.IMMEDIATE;
    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) return;
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            String modeName = GSON.fromJson(reader, String.class);
            currentMode = TransitionMode.valueOf(modeName);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static void saveSettings() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(currentMode.name(), writer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static TransitionMode getCurrentMode() {
        return currentMode;
    }
    public static void setCurrentMode(TransitionMode mode) {
        currentMode = mode;
        saveSettings();
    }
}
</file>

<file path="client/java/ninja/trek/config/WrapSettings.java">
package ninja.trek.config;
import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import net.minecraft.client.MinecraftClient;
import java.io.*;
import java.util.HashMap;
import java.util.Map;
public class WrapSettings {
    private static final File CONFIG_FILE = new File(MinecraftClient.getInstance().runDirectory, "config/craneshot_wrap.json");
    private static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
    private static Map<Integer, Boolean> wrapStates = new HashMap<>();
    public static void loadSettings() {
        if (!CONFIG_FILE.exists()) return;
        try (FileReader reader = new FileReader(CONFIG_FILE)) {
            wrapStates = GSON.fromJson(reader, Map.class);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static void saveSettings() {
        try (FileWriter writer = new FileWriter(CONFIG_FILE)) {
            GSON.toJson(wrapStates, writer);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    public static boolean getWrapState(int slotIndex) {
        return wrapStates.getOrDefault(slotIndex, false);
    }
    public static void setWrapState(int slotIndex, boolean state) {
        wrapStates.put(slotIndex, state);
        saveSettings();
    }
}
</file>

<file path="client/java/ninja/trek/CraneshotClient.java">
package ninja.trek;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.client.util.InputUtil;
import ninja.trek.config.MenuOverlayScreen;
import org.lwjgl.glfw.GLFW;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
public class CraneshotClient implements ClientModInitializer {
	public static KeyBinding[] cameraKeyBinds;
	public static KeyBinding selectMovementType;
	public static final CameraController CAMERA_CONTROLLER = new CameraController();
	public static KeyBinding toggleMenuKey;
	private static boolean isMenuOpen = false;
	@Override
	public void onInitializeClient() {
		toggleMenuKey = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.toggle_menu",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_Z,
				"category.craneshot.ui"
		));
		selectMovementType = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.select_movement",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_X,
				"category.craneshot.camera"
		));
		cameraKeyBinds = new KeyBinding[]{
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera1",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_C,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera2",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_V,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera3",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_B,
						"category.craneshot.camera"
				))
		};
		CameraMovementRegistry.initialize();
		CraneShotEventHandler.register();
	}
	public static void checkKeybinds() {
		if (toggleMenuKey.wasPressed()) {
			MenuOverlayScreen.toggleMenu();
		}
	}
}
</file>

<file path="client/java/ninja/trek/CraneshotDataGenerator.java">
package ninja.trek;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class CraneshotDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/java/ninja/trek/CraneShotEventHandler.java">
package ninja.trek;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;
import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.text.Text;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.mixin.client.MouseAccessor;
import java.util.HashMap;
import java.util.Map;
public class CraneShotEventHandler {
    private static final double SCROLL_COOLDOWN = 0.1;
    private static double lastScrollTime = 0;
    private static String currentMessage = "";
    private static long messageTimer = 0;
    private static final long MESSAGE_DURATION = 2000;
    private static final Map<Integer, Boolean> keyStates = new HashMap<>();
    public static void register() {
        // Register client tick event for input handling
        ClientTickEvents.END_CLIENT_TICK.register(client -> {
            handleScrollInput(client);
            updateMessageTimer();
            CraneshotClient.checkKeybinds();
        });
        // Register HUD rendering for messages
        HudRenderCallback.EVENT.register((context, tickDelta) -> {
            if (!currentMessage.isEmpty() && System.currentTimeMillis() < messageTimer) {
                MinecraftClient client = MinecraftClient.getInstance();
                if (client.player != null) {
                    int width = client.getWindow().getScaledWidth();
                    context.drawTextWithShadow(
                            client.textRenderer,
                            Text.literal(currentMessage),
                            width / 2 - client.textRenderer.getWidth(currentMessage) / 2,
                            60,
                            0xFFFFFF
                    );
                }
            }
        });
        // Register world render event for camera updates
        WorldRenderEvents.START.register(context -> {
            MinecraftClient client = MinecraftClient.getInstance();
            Camera camera = client.gameRenderer.getCamera();
            // Handle camera movement key states
            boolean anyPressed = false;
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                boolean currentlyPressed = CraneshotClient.cameraKeyBinds[i].isPressed();
                boolean wasPressed = keyStates.getOrDefault(i, false);
                if (currentlyPressed) {
                    if (!wasPressed) {
                        // Key just pressed - start movement
                        CraneshotClient.CAMERA_CONTROLLER.startTransition(client, camera, i);
                    }
                    anyPressed = true;
                }
                keyStates.put(i, currentlyPressed);
            }
            // If no keys are pressed, reset the camera
            if (!anyPressed) {
                CraneshotClient.CAMERA_CONTROLLER.queueFinish(client, camera);
            }
            // Update camera movements
            if (client.player != null) {
                CraneshotClient.CAMERA_CONTROLLER.tick(client, camera);
            }
        });
    }
    private static void handleScrollInput(MinecraftClient client) {
        double currentTime = System.currentTimeMillis() / 1000.0;
        if (currentTime - lastScrollTime < SCROLL_COOLDOWN) {
            return;
        }
        MouseAccessor mouseAccessor = (MouseAccessor)client.mouse;
        double scrollDelta = mouseAccessor.getEventDeltaVerticalWheel();
        if (scrollDelta == 0) {
            return;
        }
        boolean scrollUp = scrollDelta > 0;
        // Handle movement type cycling
        if (CraneshotClient.selectMovementType.isPressed()) {
            CraneshotClient.CAMERA_CONTROLLER.cycleMovementType(scrollUp);
            // Find the active movement to display its type
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    ICameraMovement movement = CraneshotClient.CAMERA_CONTROLLER.getMovementAt(i);
                    if (movement != null) {
                        showMovementTypeMessage(String.format(
                                "Camera %d: %s Movement",
                                i + 1,
                                movement.getName()
                        ));
                    }
                    break;
                }
            }
            lastScrollTime = currentTime;
            mouseAccessor.setEventDeltaVerticalWheel(0);
        }
        // Handle distance adjustment
        else {
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    CraneshotClient.CAMERA_CONTROLLER.adjustDistance(i, scrollUp);
                    lastScrollTime = currentTime;
                    mouseAccessor.setEventDeltaVerticalWheel(0);
                    break;
                }
            }
        }
    }
    private static void showMovementTypeMessage(String message) {
        currentMessage = message;
        messageTimer = System.currentTimeMillis() + MESSAGE_DURATION;
    }
    private static void updateMessageTimer() {
        if (System.currentTimeMillis() >= messageTimer) {
            currentMessage = "";
        }
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/CameraAccessor.java">
package ninja.trek.mixin.client;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import org.spongepowered.asm.mixin.gen.Invoker;
@Mixin(Camera.class)
public interface CameraAccessor {
    @Accessor("pos")
    void invokesetPos(Vec3d pos);
    @Accessor("pos")
    Vec3d getPos();
    @Invoker("setRotation")
    void invokeSetRotation(float yaw, float pitch);
}
</file>

<file path="client/java/ninja/trek/mixin/client/ExampleClientMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseAccessor.java">
package ninja.trek.mixin.client;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import net.minecraft.client.Mouse;
@Mixin(Mouse.class)
public interface MouseAccessor {
    @Accessor("eventDeltaVerticalWheel")
    double getEventDeltaVerticalWheel();
    @Accessor("eventDeltaVerticalWheel")
    void setEventDeltaVerticalWheel(double value);
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.Mouse;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
import ninja.trek.CraneshotClient;
@Mixin(Mouse.class)
public class MouseMixin {
    @Shadow private double eventDeltaVerticalWheel;
    @Inject(method = "onMouseScroll", at = @At("HEAD"), cancellable = true)
    private void onScroll(long window, double horizontal, double vertical, CallbackInfo ci) {
        if (CraneshotClient.selectMovementType.isPressed() ||
                CraneshotClient.cameraKeyBinds[0].isPressed() ||
                CraneshotClient.cameraKeyBinds[1].isPressed() ||
                CraneshotClient.cameraKeyBinds[2].isPressed()) {
            eventDeltaVerticalWheel = vertical;
            ci.cancel();
        }
    }
}
</file>

<file path="client/resources/craneshot.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"MouseMixin",
		"CameraAccessor",
		"MouseAccessor"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/Craneshot.java">
package ninja.trek;
import net.fabricmc.api.ModInitializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Craneshot implements ModInitializer {
	public static final String MOD_ID = "craneshot";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	@Override
	public void onInitialize() {
		LOGGER.info("CraneShot Camera Mod initialized!");
	}
}
</file>

<file path="main/java/ninja/trek/mixin/ExampleMixin.java">
package ninja.trek.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/resources/craneshot.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "craneshot",
	"version": "${version}",
	"name": "craneshot",
	"description": "Advanced camera controls mod for cinematics",
	"authors": ["Me!"],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/craneshot/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": ["ninja.trek.Craneshot"],
		"client": ["ninja.trek.CraneshotClient"],
		
		"fabric-datagen": ["ninja.trek.CraneshotDataGenerator"]
	},
	"mixins": [
		"craneshot.mixins.json",
		{
			"config": "craneshot.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*",
		"fabric-key-binding-api-v1": "*"
	}
}
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
