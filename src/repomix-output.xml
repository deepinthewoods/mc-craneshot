This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-07T20:33:32.568Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
client/java/ninja/trek/CameraController.java
client/java/ninja/trek/CameraMovementManager.java
client/java/ninja/trek/CameraMovementRegistry.java
client/java/ninja/trek/cameramovements/AbstractMovementSettings.java
client/java/ninja/trek/cameramovements/CameraMovementType.java
client/java/ninja/trek/cameramovements/CameraState.java
client/java/ninja/trek/cameramovements/CameraTarget.java
client/java/ninja/trek/cameramovements/ICameraMovement.java
client/java/ninja/trek/cameramovements/movements/BezierMovement.java
client/java/ninja/trek/cameramovements/movements/LinearMovement.java
client/java/ninja/trek/cameramovements/MovementState.java
client/java/ninja/trek/cameramovements/RaycastType.java
client/java/ninja/trek/cameramovements/RaycastUtil.java
client/java/ninja/trek/CraneshotClient.java
client/java/ninja/trek/CraneshotDataGenerator.java
client/java/ninja/trek/CraneShotEventHandler.java
client/java/ninja/trek/IMouseMixin.java
client/java/ninja/trek/mixin/client/CameraAccessor.java
client/java/ninja/trek/mixin/client/CameraMixin.java
client/java/ninja/trek/mixin/client/ExampleClientMixin.java
client/java/ninja/trek/mixin/client/KeyboardInputMixin.java
client/java/ninja/trek/mixin/client/MouseAccessor.java
client/java/ninja/trek/mixin/client/MouseMixin.java
client/java/ninja/trek/mixin/client/WorldRendererMixin.java
client/java/ninja/trek/MouseInterceptor.java
client/resources/craneshot.client.mixins.json
main/java/ninja/trek/Craneshot.java
main/java/ninja/trek/mixin/ExampleMixin.java
main/resources/craneshot.mixins.json
main/resources/fabric.mod.json
repomixx - ignore config.bat
repomixx - movements only.bat
repomixx.bat
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="client/java/ninja/trek/CameraController.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.option.Perspective;
import net.minecraft.client.option.SimpleOption;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.BlockView;
import ninja.trek.cameramovements.*;
import ninja.trek.config.FreeCamSettings;
import ninja.trek.config.SlotMenuSettings;
import ninja.trek.mixin.client.*;
import java.util.*;
public class CameraController {
    private List<List<ICameraMovement>> slots;
    private final ArrayList<Integer> currentTypes;
    private CameraMovementManager movementManager;
    private final Map<Integer, ICameraMovement> activeMovementSlots;
    private static final double FIRST_PERSON_THRESHOLD = 2.0;
    private String currentMessage = "";
    private long messageTimer = 0;
    private static final long MESSAGE_DURATION = 2000;
    private boolean mouseControlEnabled = false;
    private boolean moveControlEnabled = false;
    public static boolean inFreeControlMode = false;
    public static Vec3d freeCamPosition;
    private float freeCamYaw;
    private float freeCamPitch;
    public CameraController() {
        slots = new ArrayList<>();
        currentTypes = new ArrayList<>();
        movementManager = new CameraMovementManager();
        activeMovementSlots = new HashMap<>();
        for (int i = 0; i < 3; i++) {
            currentTypes.add(0);
        }
    }
    private void handleFreeControl(MinecraftClient client, Camera camera) {
        if (moveControlEnabled) {
            handleKeyboardMovement(client, camera);
        }
        if (mouseControlEnabled && client.mouse instanceof IMouseMixin) {
            Double mouseSensitivity = MinecraftClient.getInstance().options.getMouseSensitivity().getValue();
            double scaledSensitivity = 0.6 * mouseSensitivity * mouseSensitivity + 0.2;
            IMouseMixin mouseMixin = (IMouseMixin) client.mouse;
            double deltaX = mouseMixin.getCapturedDeltaX();
            double deltaY = -mouseMixin.getCapturedDeltaY();
            freeCamYaw += (float)(deltaX * scaledSensitivity);
            freeCamPitch = Math.max(-90, Math.min(90, freeCamPitch - (float)(deltaY * scaledSensitivity)));
            ((CameraAccessor)camera).invokeSetRotation(freeCamYaw, freeCamPitch);
        }
        // Force the camera to keep the freeCamPosition.
        ((CameraAccessor)camera).invokesetPos(freeCamPosition);
    }
    private void handleKeyboardMovement(MinecraftClient client, Camera camera) {
        float speed = FreeCamSettings.getMoveSpeed();
        Vec3d movement = Vec3d.ZERO;
        if (FreeCamSettings.getMovementMode() == FreeCamSettings.MovementMode.CAMERA) {
            // Full camera-relative movement including pitch
            float yaw = freeCamYaw;
            float pitch = freeCamPitch;
            Vec3d forward = new Vec3d(
                    -Math.sin(Math.toRadians(yaw)) * Math.cos(Math.toRadians(pitch)),
                    -Math.sin(Math.toRadians(pitch)),
                    Math.cos(Math.toRadians(yaw)) * Math.cos(Math.toRadians(pitch))
            );
            Vec3d right = new Vec3d(
                    Math.cos(Math.toRadians(yaw)),
                    0,
                    Math.sin(Math.toRadians(yaw))
            );
            if (client.options.forwardKey.isPressed()) movement = movement.add(forward);
            if (client.options.backKey.isPressed()) movement = movement.subtract(forward);
            if (client.options.leftKey.isPressed()) movement = movement.subtract(right);
            if (client.options.rightKey.isPressed()) movement = movement.add(right);
            if (client.options.jumpKey.isPressed()) movement = movement.add(0, 1, 0);
            if (client.options.sneakKey.isPressed()) movement = movement.add(0, -1, 0);
        } else {
            // Y-axis locked camera-relative movement
            float yaw = freeCamYaw;
            // Create horizontal-only forward and right vectors
            Vec3d forward = new Vec3d(
                    -Math.sin(Math.toRadians(yaw)),
                    0,
                    Math.cos(Math.toRadians(yaw))
            );
            Vec3d right = new Vec3d(
                    Math.cos(Math.toRadians(yaw)),
                    0,
                    Math.sin(Math.toRadians(yaw))
            );
            if (client.options.forwardKey.isPressed()) movement = movement.add(forward);
            if (client.options.backKey.isPressed()) movement = movement.subtract(forward);
            if (client.options.leftKey.isPressed()) movement = movement.subtract(right);
            if (client.options.rightKey.isPressed()) movement = movement.add(right);
            if (client.options.jumpKey.isPressed()) movement = movement.add(0, 1, 0);
            if (client.options.sneakKey.isPressed()) movement = movement.add(0, -1, 0);
        }
        if (movement.lengthSquared() > 0) {
            movement = movement.normalize().multiply(speed);
            Vec3d newPos = freeCamPosition.add(movement);
            ((CameraAccessor)camera).invokesetPos(newPos);
            freeCamPosition = newPos;
        }
    }
    public void queueFinish(MinecraftClient client, Camera camera) {
        if (inFreeControlMode) {
            // Disable mouse interception
            if (mouseControlEnabled) {
                MouseInterceptor.setIntercepting(false);
            }
            // Store final position
            freeCamPosition = camera.getPos();
            freeCamYaw = camera.getYaw();
            freeCamPitch = camera.getPitch();
        }
        inFreeControlMode = false;
        mouseControlEnabled = false;
        moveControlEnabled = false;
        for (ICameraMovement movement : activeMovementSlots.values()) {
            movement.queueReset(client, camera);
        }
    }
    public void tick(MinecraftClient client, Camera camera) {
        if (!inFreeControlMode) {
            // Run the movement tick first.
            movementManager.update(client, camera);
            // Only update perspective if we're still in normal (non‑free) mode.
            updatePerspective(client, camera);
            // Now check if any active movement has completed its out phase.
            // (This check also captures the camera state and sets free mode.)
            for (ICameraMovement movement : activeMovementSlots.values()) {
                if (movement instanceof AbstractMovementSettings && movement.hasCompletedOutPhase()) {
                    AbstractMovementSettings settings = (AbstractMovementSettings) movement;
                    if (settings.getPostMoveAction() != AbstractMovementSettings.POST_MOVE_ACTION.NONE) {
                        // First switch to free mode and set control flags
                        inFreeControlMode = true;
                        mouseControlEnabled = (settings.getPostMoveAction() == AbstractMovementSettings.POST_MOVE_ACTION.FREE_MOUSE ||
                                settings.getPostMoveAction() == AbstractMovementSettings.POST_MOVE_ACTION.FREE_MOVE);
                        moveControlEnabled = (settings.getPostMoveAction() == AbstractMovementSettings.POST_MOVE_ACTION.FREE_MOVE);
                        // Then capture the final movement position as our free camera start position
                        Vec3d finalPos = movement.calculateState(client, camera).getCameraTarget().getPosition();
                        freeCamPosition = finalPos;
                        freeCamYaw = camera.getYaw();
                        freeCamPitch = camera.getPitch();
                        // Immediately force the camera to this position to prevent any interpolation
                        ((CameraAccessor)camera).invokesetPos(freeCamPosition);
                        ((CameraAccessor)camera).invokeSetRotation(freeCamYaw, freeCamPitch);
                        // Optionally force the perspective to a mode that suits free control.
                        // For example, if free mode should work in first person:
                        client.options.setPerspective(Perspective.FIRST_PERSON);
                        if (mouseControlEnabled) {
                            MouseInterceptor.setIntercepting(true);
                        }
                        // Exit tick to avoid any further perspective updates this tick.
                        return;
                    }
                }
            }
        }
    }
    public void handleCameraUpdate(BlockView area, Entity focusedEntity, boolean thirdPerson, boolean inverseView, float tickDelta, Camera camera) {
        if (camera == null || focusedEntity == null) return;
        MinecraftClient client = MinecraftClient.getInstance();
        if (client == null || client.world == null) return;
        if (inFreeControlMode) {
            handleFreeControl(client, camera);
        } else {
            tick(client, camera);
        }
        clearCompletedMovements(client, camera);
        updateMessageTimer();
    }
    private void clearCompletedMovements(MinecraftClient client, Camera camera) {
        if (!inFreeControlMode) {
            Iterator<Map.Entry<Integer, ICameraMovement>> iterator = activeMovementSlots.entrySet().iterator();
            while (iterator.hasNext()) {
                Map.Entry<Integer, ICameraMovement> entry = iterator.next();
                if (entry.getValue().isComplete()) {
                    entry.getValue().queueReset(client, camera);
                    iterator.remove();
                }
            }
        }
    }
    public void startTransition(MinecraftClient client, Camera camera, int movementIndex) {
        Craneshot.LOGGER.info("startt");
        ICameraMovement movement = getMovementAt(movementIndex);
        if (movement == null) return;
        Craneshot.LOGGER.info("startt notnull");
        clearAllMovements(client, camera);
        activeMovementSlots.clear();
        activeMovementSlots.put(movementIndex, movement);
        movement.start(client, camera);
        movementManager.addMovement(movement, client, camera);
    }
    private void updatePerspective(MinecraftClient client, Camera camera) {
        //we do this just to switch the player model rendering on or off
        if (client.player == null) return;
        double distance = camera.getPos().distanceTo(client.player.getEyePos());
        if (distance > FIRST_PERSON_THRESHOLD &&
                client.options.getPerspective() == Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.THIRD_PERSON_BACK);
        } else if (distance < FIRST_PERSON_THRESHOLD &&
                client.options.getPerspective() != Perspective.FIRST_PERSON) {
            client.options.setPerspective(Perspective.FIRST_PERSON);
        }
    }
    // Message handling methods
    public void showMessage(String message) {
        currentMessage = message;
        messageTimer = System.currentTimeMillis() + MESSAGE_DURATION;
    }
    public String getCurrentMessage() {
        return currentMessage;
    }
    public boolean hasActiveMessage() {
        return System.currentTimeMillis() < messageTimer;
    }
    private void updateMessageTimer() {
        if (System.currentTimeMillis() >= messageTimer) {
            currentMessage = "";
        }
    }
    public void showMovementTypeMessage(int slotIndex) {
        ICameraMovement movement = getMovementAt(slotIndex);
        if (movement != null) {
            showMessage(String.format(
                    "Camera %d: %s Movement",
                    slotIndex + 1,
                    movement.getName()
            ));
        }
    }
    // Movement management methods
    public void cycleMovementType(boolean forward) {
        for (Map.Entry<Integer, ICameraMovement> entry : activeMovementSlots.entrySet()) {
            int slotIndex = entry.getKey();
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            int currentType = currentTypes.get(slotIndex);
            boolean wrap = SlotMenuSettings.getWrapState(slotIndex);
            if (forward) {
                if (currentType < slotMovements.size() - 1 || wrap) {
                    currentTypes.set(slotIndex, wrap ?
                            (currentType + 1) % slotMovements.size() :
                            Math.min(currentType + 1, slotMovements.size() - 1));
                }
            } else {
                if (currentType > 0 || wrap) {
                    currentTypes.set(slotIndex, wrap ?
                            (currentType - 1 + slotMovements.size()) % slotMovements.size() :
                            Math.max(currentType - 1, 0));
                }
            }
        }
    }
    public void adjustDistance(int index, boolean increase) {
        ICameraMovement movement = getMovementAt(index);
        if (movement != null) {
            movement.adjustDistance(increase);
        }
    }
    // Slot management methods
    public void addMovement(int slotIndex, ICameraMovement movement) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            slots.get(slotIndex).add(movement);
        }
    }
    public void removeMovement(int slotIndex, int movementIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (movementIndex >= 0 && movementIndex < slotMovements.size() && slotMovements.size() > 1) {
                slotMovements.remove(movementIndex);
                if (currentTypes.get(slotIndex) >= slotMovements.size()) {
                    currentTypes.set(slotIndex, slotMovements.size() - 1);
                }
            }
        }
    }
    // Getter methods
    public int getMovementCount() {
        return slots.size();
    }
    public ICameraMovement getMovementAt(int index) {
        if (index >= 0 && index < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(index);
            int currentType = currentTypes.get(index);
            if (!slotMovements.isEmpty() && currentType < slotMovements.size()) {
                return slotMovements.get(currentType);
            }
        }
        return null;
    }
    public List<ICameraMovement> getAvailableMovementsForSlot(int slotIndex) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            return new ArrayList<>(slots.get(slotIndex));
        }
        return new ArrayList<>();
    }
    public void swapMovements(int slotIndex, int index1, int index2) {
        if (slotIndex >= 0 && slotIndex < slots.size()) {
            List<ICameraMovement> slotMovements = slots.get(slotIndex);
            if (index1 >= 0 && index1 < slotMovements.size() &&
                    index2 >= 0 && index2 < slotMovements.size()) {
                Collections.swap(slotMovements, index1, index2);
            }
        }
    }
    public void setAllSlots(List<List<ICameraMovement>> savedSlots) {
        this.slots = savedSlots;
    }
    private void clearAllMovements(MinecraftClient client, Camera camera) {
        for (ICameraMovement movement : activeMovementSlots.values()) {
            movement.queueReset(client, camera);
        }
        movementManager = new CameraMovementManager();
        activeMovementSlots.clear();
    }
    public CameraMovementManager getMovementManager() {
        return movementManager;
    }
}
</file>

<file path="client/java/ninja/trek/CameraMovementManager.java">
package ninja.trek;
import net.minecraft.client.MinecraftClient;
import net.minecraft.util.math.Vec3d;
import net.minecraft.client.render.Camera;
import ninja.trek.cameramovements.*;
import ninja.trek.mixin.client.CameraAccessor;
import java.util.*;
public class CameraMovementManager {
    private final List<ICameraMovement> activeMovements = new ArrayList<>();
    private Map<ICameraMovement, CameraTarget> originalTargets = new HashMap<>();
    private Map<ICameraMovement, CameraTarget> freeMovementTargets = new HashMap<>();
    public void addMovement(ICameraMovement movement, MinecraftClient client, Camera camera) {
        movement.start(client, camera);
        activeMovements.add(movement);
        originalTargets.put(movement, CameraTarget.fromCamera(camera));
    }
    public void update(MinecraftClient client, Camera camera) {
        if (activeMovements.isEmpty() || client.player == null) return;
        float totalWeight = 0;
        List<WeightedState> states = new ArrayList<>();
        Iterator<ICameraMovement> iterator = activeMovements.iterator();
        while (iterator.hasNext()) {
            ICameraMovement movement = iterator.next();
            MovementState state = movement.calculateState(client, camera);
            if (state.isComplete()) {
                iterator.remove();
                originalTargets.remove(movement);
                freeMovementTargets.remove(movement);
            } else {
                float weight = movement.getWeight();
                CameraTarget targetToUse;
                if (movement instanceof AbstractMovementSettings &&
                        ((ICameraMovement)movement).hasCompletedOutPhase() &&
                        ((AbstractMovementSettings)movement).getPostMoveAction() != AbstractMovementSettings.POST_MOVE_ACTION.NONE) {
                    // Use stored free movement target if it exists, otherwise create one
                    targetToUse = freeMovementTargets.computeIfAbsent(movement,
                            k -> CameraTarget.fromCamera(camera));
                } else {
                    targetToUse = state.getCameraTarget()
                            .withAdjustedPosition(client.player, movement.getRaycastType());
                }
                states.add(new WeightedState(targetToUse, weight));
                totalWeight += weight;
            }
        }
        if (!states.isEmpty()) {
            CameraTarget blendedTarget = blendStates(states, totalWeight);
            CameraTarget finalTarget = blendedTarget
                    .withAdjustedPosition(client.player, RaycastType.NONE);
            applyCameraTarget(finalTarget, camera);
            // Store current position for active free movement cameras
            for (ICameraMovement movement : activeMovements) {
                if (movement instanceof AbstractMovementSettings &&
                        ((ICameraMovement)movement).hasCompletedOutPhase() &&
                        ((AbstractMovementSettings)movement).getPostMoveAction() != AbstractMovementSettings.POST_MOVE_ACTION.NONE) {
                    freeMovementTargets.put(movement, CameraTarget.fromCamera(camera));
                }
            }
        }
    }
    public void resetMovement(ICameraMovement movement) {
        // When resetting, restore the original target
        CameraTarget originalTarget = originalTargets.get(movement);
        if (originalTarget != null) {
            freeMovementTargets.put(movement, originalTarget);
        }
    }
    private CameraTarget blendStates(List<WeightedState> states, float totalWeight) {
        if (states.size() == 1) {
            return states.get(0).target;
        }
        Vec3d blendedPos = Vec3d.ZERO;
        float blendedYaw = 0;
        float blendedPitch = 0;
        for (WeightedState weighted : states) {
            float normalizedWeight = weighted.weight / totalWeight;
            CameraTarget target = weighted.target;
            blendedPos = blendedPos.add(
                    target.getPosition().multiply(normalizedWeight)
            );
            blendedYaw += target.getYaw() * normalizedWeight;
            blendedPitch += target.getPitch() * normalizedWeight;
        }
        // Use the raycast type from the highest weight movement
        WeightedState highestWeightState = states.stream()
                .max(Comparator.comparing(ws -> ws.weight))
                .orElse(states.get(0));
        return new CameraTarget(blendedPos, blendedYaw, blendedPitch);
    }
    private void applyCameraTarget(CameraTarget target, Camera camera) {
        CameraAccessor accessor = (CameraAccessor) camera;
        accessor.invokesetPos(target.getPosition());
        accessor.invokeSetRotation(target.getYaw(), target.getPitch());
    }
    private static class WeightedState {
        final CameraTarget target;
        final float weight;
        WeightedState(CameraTarget target, float weight) {
            this.target = target;
            this.weight = weight;
        }
    }
}
</file>

<file path="client/java/ninja/trek/CameraMovementRegistry.java">
package ninja.trek;
import ninja.trek.cameramovements.CameraMovementType;
import ninja.trek.cameramovements.ICameraMovement;
import net.fabricmc.loader.api.FabricLoader;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.net.URL;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
public class CameraMovementRegistry {
    private static final List<Class<? extends ICameraMovement>> movementTypes = new ArrayList<>();
    private static int currentTypeIndex = 0;
    private static final String BASE_PACKAGE = "ninja.trek.cameramovements";
    public static void initialize() {
        try {
            scanPackage(BASE_PACKAGE);
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to scan for camera movements", e);
        }
    }
    private static void scanPackage(String packageName) {
        try {
            String path = packageName.replace('.', '/');
            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
            Enumeration<URL> resources = classLoader.getResources(path);
            while (resources.hasMoreElements()) {
                URL resource = resources.nextElement();
                String protocol = resource.getProtocol();
                if (protocol.equals("file")) {
                    scanDirectory(new File(resource.getFile()), packageName);
                } else if (protocol.equals("jar")) {
                    scanJar(resource, path);
                }
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Error scanning package: " + packageName, e);
        }
    }
    private static void scanDirectory(File directory, String packageName) {
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    scanDirectory(file, packageName + "." + file.getName());
                } else if (file.getName().endsWith(".class")) {
                    String className = packageName + "." + file.getName().substring(0, file.getName().length() - 6);
                    processClass(className);
                }
            }
        }
    }
    private static void scanJar(URL resourceUrl, String path) {
        String jarPath = resourceUrl.getPath().substring(5, resourceUrl.getPath().indexOf("!"));
        try (JarFile jarFile = new JarFile(jarPath)) {
            Enumeration<JarEntry> entries = jarFile.entries();
            while (entries.hasMoreElements()) {
                JarEntry entry = entries.nextElement();
                String entryName = entry.getName();
                if (entryName.startsWith(path) && entryName.endsWith(".class")) {
                    String className = entryName.substring(0, entryName.length() - 6).replace('/', '.');
                    processClass(className);
                }
            }
        } catch (IOException e) {
            Craneshot.LOGGER.error("Error scanning JAR file: " + jarPath, e);
        }
    }
    private static void processClass(String className) {
        try {
            Class<?> cls = Class.forName(className);
            if (ICameraMovement.class.isAssignableFrom(cls) &&
                    cls.isAnnotationPresent(CameraMovementType.class)) {
                CameraMovementType annotation = cls.getAnnotation(CameraMovementType.class);
                if (annotation.enabled()) {
                    @SuppressWarnings("unchecked")
                    Class<? extends ICameraMovement> movementClass = (Class<? extends ICameraMovement>) cls;
                    registerMovement(movementClass);
                }
            }
        } catch (ClassNotFoundException e) {
            Craneshot.LOGGER.error("Error loading class: " + className, e);
        }
    }
    public static void registerMovement(Class<? extends ICameraMovement> movementClass) {
        if (!movementTypes.contains(movementClass)) {
            movementTypes.add(movementClass);
        }
    }
    public static ICameraMovement createCurrentMovement() {
        try {
            Constructor<? extends ICameraMovement> constructor = movementTypes.get(currentTypeIndex).getDeclaredConstructor();
            return constructor.newInstance();
        } catch (Exception e) {
            Craneshot.LOGGER.error("Failed to create movement instance", e);
            return null;
        }
    }
    public static List<MovementInfo> getAllMovements() {
        List<MovementInfo> movements = new ArrayList<>();
        for (Class<? extends ICameraMovement> cls : movementTypes) {
            CameraMovementType annotation = cls.getAnnotation(CameraMovementType.class);
            if (annotation != null) {
                movements.add(new MovementInfo(
                        annotation.name().isEmpty() ? cls.getSimpleName() : annotation.name(),
                        annotation.description(),
                        cls
                ));
            }
        }
        return movements;
    }
    public static void cycleNextMovement() {
        currentTypeIndex = (currentTypeIndex + 1) % movementTypes.size();
    }
    public static String getCurrentMovementName() {
        Class<? extends ICameraMovement> currentClass = movementTypes.get(currentTypeIndex);
        CameraMovementType annotation = currentClass.getAnnotation(CameraMovementType.class);
        return annotation != null && !annotation.name().isEmpty() ?
                annotation.name() : currentClass.getSimpleName();
    }
    public static int getMovementCount() {
        return movementTypes.size();
    }
    // Helper class to hold movement type information
    public static class MovementInfo {
        private final String name;
        private final String description;
        private final Class<? extends ICameraMovement> movementClass;
        public MovementInfo(String name, String description, Class<? extends ICameraMovement> movementClass) {
            this.name = name;
            this.description = description;
            this.movementClass = movementClass;
        }
        public String getName() { return name; }
        public String getDescription() { return description; }
        public Class<? extends ICameraMovement> getMovementClass() { return movementClass; }
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/AbstractMovementSettings.java">
package ninja.trek.cameramovements;
import net.minecraft.entity.player.PlayerEntity;
import ninja.trek.Craneshot;
import ninja.trek.config.MovementSetting;
import ninja.trek.config.MovementSettingType;
import java.lang.reflect.Field;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.stream.Stream;
public abstract class AbstractMovementSettings {
    private String customName = null;
    @MovementSetting(
            label = "Raycast Type",
            type = MovementSettingType.ENUM,
            description = "Controls how the camera handles collision with blocks"
    )
    private RaycastType raycastType = RaycastType.NEAR;
    public double alpha;
    public enum START_TARGET {PLAYER};
    public enum END_TARGET {BACK, FRONT}
    public enum POST_MOVE_ACTION {
        NONE,       // Default behavior
        FREE_MOUSE, // Allow free mouse control after movement
        FREE_MOVE   // Allow WASD movement after movement
    }
    @MovementSetting(
            label = "Post-Movement Action",
            type = MovementSettingType.ENUM,
            description = "Controls camera behavior after movement completes"
    )
    protected POST_MOVE_ACTION postMoveAction = POST_MOVE_ACTION.NONE;
    public POST_MOVE_ACTION getPostMoveAction() {
        return postMoveAction;
    }
    @MovementSetting(
            label = "Camera Position",
            type = MovementSettingType.ENUM,
            description = "Determines if camera follows in front or behind the player"
    )
    protected END_TARGET endTarget = END_TARGET.BACK;
    protected CameraTarget getEndTarget(PlayerEntity player, double targetDistance) {
        switch (endTarget){
            default:
            case BACK: return CameraTarget.fromDistanceBack(player, targetDistance);
            case FRONT: return CameraTarget.fromDistanceFront(player, targetDistance);
        }
    }
    public RaycastType getRaycastType() {
        return raycastType != null ? raycastType : RaycastType.NONE;
    }
    public void setRaycastType(RaycastType type) {
        this.raycastType = type;
    }
    public String getDisplayName() {
        return customName != null ? customName : getClass().getSimpleName();
    }
    public void setCustomName(String name) {
        this.customName = name;
    }
    public Map<String, Object> getSettings() {
        Map<String, Object> settings = new HashMap<>();
        Stream.concat(
                        Arrays.stream(this.getClass().getDeclaredFields()),
                        Arrays.stream(AbstractMovementSettings.class.getDeclaredFields())
                )
                .filter(field -> field.isAnnotationPresent(MovementSetting.class) || field.getName().equals("customName"))
                .forEach(field -> {
                    field.setAccessible(true);
                    try {
                        Object value = field.get(this);
                        if (value instanceof Enum<?>) {
                            settings.put(field.getName(), ((Enum<?>) value).name());
                        } else {
                            settings.put(field.getName(), value);
                        }
                    } catch (IllegalAccessException e) {
                        Craneshot.LOGGER.error("Error accessing field: " + field.getName(), e);
                    }
                });
        return settings;
    }
    public void updateSetting(String key, Object value) {
        try {
            if (key.equals("customName")) {
                setCustomName((String)value);
                return;
            }
            Field field = findField(key);
            if (field != null && field.isAnnotationPresent(MovementSetting.class)) {
                field.setAccessible(true);
                // Handle different field types
                if (field.getType().isEnum()) {
                    if (value instanceof String) {
                        @SuppressWarnings("unchecked")
                        Enum<?> enumValue = Enum.valueOf(field.getType().asSubclass(Enum.class), (String) value);
                        field.set(this, enumValue);
                        if (key.equals("raycastType")) {
                            setRaycastType((RaycastType)enumValue);
                        }
                    }
                } else if (field.getType() == double.class || field.getType() == Double.class) {
                    double doubleValue;
                    if (value instanceof Number) {
                        doubleValue = ((Number)value).doubleValue();
                    } else if (value instanceof String) {
                        doubleValue = Double.parseDouble((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to double");
                    }
                    field.setDouble(this, doubleValue);
                } else if (field.getType() == float.class || field.getType() == Float.class) {
                    float floatValue;
                    if (value instanceof Number) {
                        floatValue = ((Number)value).floatValue();
                    } else if (value instanceof String) {
                        floatValue = Float.parseFloat((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to float");
                    }
                    field.setFloat(this, floatValue);
                } else if (field.getType() == int.class || field.getType() == Integer.class) {
                    int intValue;
                    if (value instanceof Number) {
                        intValue = ((Number)value).intValue();
                    } else if (value instanceof String) {
                        intValue = Integer.parseInt((String)value);
                    } else {
                        throw new IllegalArgumentException("Cannot convert " + value + " to integer");
                    }
                    field.setInt(this, intValue);
                } else {
                    // Default fallback for other types
                    field.set(this, value);
                }
            }
        } catch (Exception e) {
            Craneshot.LOGGER.error("Error updating setting {} with value {}: {}", key, value, e.getMessage());
        }
    }
    private Field findField(String key) {
        try {
            return this.getClass().getDeclaredField(key);
        } catch (NoSuchFieldException e) {
            try {
                return AbstractMovementSettings.class.getDeclaredField(key);
            } catch (NoSuchFieldException ex) {
                Craneshot.LOGGER.error("Field not found: {}", key);
                return null;
            }
        }
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraMovementType.java">
package ninja.trek.cameramovements;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface CameraMovementType {
    String name() default "";
    String description() default "";
    boolean enabled() default true;
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraState.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.input.Input;
import net.minecraft.client.render.Camera;
import net.minecraft.util.math.Vec3d;
public class CameraState {
    private Vec3d position;
    private float yaw;
    private float pitch;
    public CameraState(Vec3d position, float yaw, float pitch) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public static CameraState fromCamera(Camera camera) {
        return new CameraState(camera.getPos(), camera.getYaw(), camera.getPitch());
    }
    public Vec3d getPosition() { return position; }
    public float getYaw() { return yaw; }
    public float getPitch() { return pitch; }
    public CameraState lerp(CameraState other, double t) {
        Vec3d lerpedPos = this.position.lerp(other.position, t);
        float lerpedYaw = lerpAngle(this.yaw, other.yaw, (float)t);
        float lerpedPitch = lerpAngle(this.pitch, other.pitch, (float)t);
        return new CameraState(lerpedPos, lerpedYaw, lerpedPitch);
    }
    private float lerpAngle(float start, float end, float t) {
        float diff = end - start;
        while (diff > 180) diff -= 360;
        while (diff < -180) diff += 360;
        return start + diff * t;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/CameraTarget.java">
package ninja.trek.cameramovements;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.Craneshot;
public class CameraTarget {
    private Vec3d position;
    private float yaw;
    private float pitch;
    public CameraTarget(Vec3d position, float yaw, float pitch) {
        this.position = position;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public CameraTarget() {
        position = new Vec3d(0,0,0);
    }
    public static CameraTarget fromCamera(Camera camera) {
        return new CameraTarget(camera.getPos(), camera.getYaw(), camera.getPitch());
    }
    public static CameraTarget fromDistanceBack(PlayerEntity player, double distance) {
        double yaw = Math.toRadians(player.getYaw());// + Math.toRadians((180));
        double pitch = Math.toRadians(player.getPitch());
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * distance;
        double yOffset = Math.sin(pitch) * distance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * distance;
        Vec3d targetPos = player.getEyePos().add(xOffset, yOffset, zOffset);
        return new CameraTarget(targetPos, player.getYaw(), player.getPitch());
    }
    public static CameraTarget fromDistanceFront(PlayerEntity player, double distance) {
        double yaw = Math.toRadians(player.getYaw() + 180); // Add 180 degrees to face front
        double pitch = Math.toRadians(-player.getPitch()); // Invert the pitch angle
        double xOffset = Math.sin(yaw) * Math.cos(pitch) * distance;
        double yOffset = Math.sin(pitch) * distance;
        double zOffset = -Math.cos(yaw) * Math.cos(pitch) * distance;
        Vec3d targetPos = player.getEyePos().add(xOffset, yOffset, zOffset);
        return new CameraTarget(targetPos, player.getYaw() + 180, -player.getPitch());
    }
    public Vec3d getPosition() {
        return position;
    }
    public float getYaw() {
        return yaw;
    }
    public float getPitch() {
        return pitch;
    }
    public CameraTarget withAdjustedPosition(PlayerEntity player, RaycastType raycastType) {
//        Craneshot.LOGGER.info("withAdjustedPosition called with raycastType: {}", this.raycastType);
        Vec3d adjustedPos = RaycastUtil.adjustForCollision(player.getEyePos(), this.position, raycastType);
        return new CameraTarget(adjustedPos, this.yaw, this.pitch);
    }
    public void set(Vec3d v, float yaw, float pitch) {
        position = v;
        this.yaw = yaw;
        this.pitch = pitch;
    }
    public void set(CameraTarget t) {
        position = t.position;
        this.pitch = t.pitch;
        this.yaw = t.yaw;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/ICameraMovement.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
public interface ICameraMovement {
    void start(MinecraftClient client, Camera camera);
    MovementState calculateState(MinecraftClient client, Camera camera);
    void queueReset(MinecraftClient client, Camera camera);
    void adjustDistance(boolean increase);
    String getName();
    float getWeight(); // For blending calculations
    boolean isComplete(); // To determine if movement should be removed
    RaycastType getRaycastType();
    default boolean hasCompletedOutPhase() { return false; }
}
</file>

<file path="client/java/ninja/trek/cameramovements/movements/BezierMovement.java">
package ninja.trek.cameramovements.movements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.Craneshot;
import ninja.trek.CraneshotClient;
import ninja.trek.cameramovements.CameraMovementType;
import ninja.trek.cameramovements.CameraTarget;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.MovementState;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.config.MovementSetting;
/**
 * Moves the camera along a quadratic Bézier curve (in canonical space) and then transforms
 * to world space using the player's head rotation.
 *
 * Modified so that:
 * - While “moving out” (Bézier phase), adjustDistance() does not change the current path.
 * - Once the “out” phase completes, the movement switches to linear mode so that any subsequent
 *   distance (or rotation) changes immediately recalc the canonical endpoints.
 * - When resetting, we exit linear mode and return along a Bézier curve that goes back to the
 *   original absolute camera position.
 *
 * To achieve that, we now store the player's original eye position and head rotation (as well as
 * the original canonical start) and use these for converting canonical coordinates back to world space
 * during the reset.
 */
@CameraMovementType(
        name = "Bezier Movement (Canonical Relative)",
        description = "Moves the camera along a quadratic Bézier curve in canonical space then converts to world space using the player's head rotation. (Modified to fix the return path.)"
)
public class BezierMovement extends AbstractMovementSettings implements ICameraMovement {
    // --- Settings ---
    @MovementSetting(label = "Position Easing", min = 0.01, max = 1.0)
    private double positionEasing = 0.1;
    @MovementSetting(label = "Position Speed Limit", min = 0.1, max = 100.0)
    private double positionSpeedLimit = 10;
    @MovementSetting(label = "Rotation Easing", min = 0.01, max = 1.0)
    private double rotationEasing = 0.1;
    @MovementSetting(label = "Rotation Speed Limit", min = 0.1, max = 1000)
    private double rotationSpeedLimit = 500;
    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10.0;
    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0;
    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0;
    @MovementSetting(label = "Control Point Displacement", min = 0.0, max = 30)
    private double controlPointDisplacement = 5;
    @MovementSetting(label = "Displacement Angle", min = -180.0, max = 180.0)
    private double displacementAngle = 0.0;
    @MovementSetting(label = "Displacement Angle Variance", min = 0.0, max = 180.0)
    private double displacementAngleVariance = 0.0;
    // --- Internal fields for the canonical Bézier path ---
    // These vectors are expressed in canonical (local) space.
    private Vec3d canonicalStart;
    private Vec3d canonicalEnd;
    private Vec3d canonicalControl;
    // Store the original canonical start (i.e. the original camera offset relative to the player)
    private Vec3d originalCanonicalStart;
    // --- Store the player's original eye position and orientation ---
    private Vec3d originalPlayerEye;
    private float originalPlayerYaw;
    private float originalPlayerPitch;
    private double progress;
    private boolean resetting = false;
    private boolean linearMode = false;
    private boolean distanceChanged = false;
    private float weight = 1.0f;
    private CameraTarget current;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return;
        // Capture the player's eye position and rotation at the start.
        Vec3d playerEye = player.getEyePos();
        float playerYaw = player.getYaw();
        float playerPitch = player.getPitch();
        // Save these original parameters.
        originalPlayerEye = playerEye;
        originalPlayerYaw = playerYaw;
        originalPlayerPitch = playerPitch;
        // Get the camera's current (absolute) position.
        Vec3d absStart = CameraTarget.fromCamera(camera).getPosition();
        // Determine the desired end target.
        CameraTarget camEndTarget = getEndTarget(player, targetDistance);
        Vec3d absEnd = camEndTarget.getPosition();
        // Convert the offsets (relative to the eye) into canonical space.
        canonicalStart = unrotateVectorByYawPitch(absStart.subtract(playerEye), playerYaw, playerPitch);
        canonicalEnd   = unrotateVectorByYawPitch(absEnd.subtract(playerEye), playerYaw, playerPitch);
        // Save the original canonical start for use in the reset.
        originalCanonicalStart = canonicalStart;
        // Compute the control point for the Bézier curve.
        canonicalControl = generateControlPoint(canonicalStart, canonicalEnd);
        progress = 0.0;
        resetting = false;
        linearMode = false;
        distanceChanged = false;
        // Set the initial camera target.
        Vec3d desiredPos = playerEye.add(rotateVectorByYawPitch(canonicalStart, playerYaw, playerPitch));
        current = new CameraTarget(desiredPos, playerYaw, playerPitch);
        weight = 1.0f;
    }
    /**
     * Computes the quadratic Bézier control point between the given canonical start and end.
     */
    private Vec3d generateControlPoint(Vec3d start, Vec3d end) {
        Vec3d mid = start.add(end).multiply(0.5);
        Vec3d diff = end.subtract(start);
        if (diff.lengthSquared() < 1e-6) {
            return mid.add(new Vec3d(0, controlPointDisplacement, 0));
        } else {
            Vec3d tangent = diff.normalize();
            Vec3d worldUp = new Vec3d(0, 1, 0);
            Vec3d projectedUp = worldUp.subtract(tangent.multiply(worldUp.dotProduct(tangent)));
            if (projectedUp.lengthSquared() < 1e-6) {
                Vec3d arbitrary = new Vec3d(1, 0, 0);
                projectedUp = arbitrary.subtract(tangent.multiply(arbitrary.dotProduct(tangent)));
            }
            projectedUp = projectedUp.normalize();
            if (projectedUp.y > 0) {
                projectedUp = projectedUp.multiply(-1);
            }
            double randomOffset = (Math.random() * 2 - 1) * displacementAngleVariance;
            double angleDegrees = displacementAngle + randomOffset;
            double angleRadians = Math.toRadians(angleDegrees);
            Vec3d rotatedUp = projectedUp.multiply(Math.cos(angleRadians))
                    .add(tangent.crossProduct(projectedUp).multiply(Math.sin(angleRadians)));
            Vec3d offset = rotatedUp.multiply(controlPointDisplacement);
            return mid.add(offset);
        }
    }
    /**
     * Returns the point on a quadratic Bézier curve defined by p0, p1, p2 at parameter t.
     */
    private Vec3d quadraticBezier(Vec3d p0, Vec3d p1, Vec3d p2, double t) {
        double oneMinusT = 1.0 - t;
        return p0.multiply(oneMinusT * oneMinusT)
                .add(p1.multiply(2 * oneMinusT * t))
                .add(p2.multiply(t * t));
    }
    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        if (linearMode) Craneshot.LOGGER.info("linear");
        PlayerEntity player = client.player;
        if (player == null) return new MovementState(current, true);
        // Determine canonical endpoints.
        Vec3d startCanon, endCanon;
        if (!resetting) {
            startCanon = canonicalStart;
            endCanon = canonicalEnd;
        } else {
            // For reset, go from canonicalEnd back to the ORIGINAL canonicalStart.
            startCanon = canonicalEnd;
            endCanon = originalCanonicalStart;
        }
        // Compute the total distance between the endpoints (used later for alpha).
        double totalDistance = startCanon.distanceTo(endCanon);
        Vec3d desiredCanonical;
        if (!linearMode) {
            // --- Bezier movement mode ---
            // Advance the progress along the curve using positionEasing and limiting the delta so that
            // the movement does not exceed positionSpeedLimit per tick.
            double potentialDelta = (1.0 - progress) * positionEasing;
            double maxMove = positionSpeedLimit * (1.0 / 20.0); // maximum allowed movement per tick
            double allowedDelta = totalDistance > 0 ? maxMove / totalDistance : potentialDelta;
            double progressDelta = Math.min(potentialDelta, allowedDelta);
            progress = Math.min(1.0, progress + progressDelta);
            // Get the canonical position along the quadratic Bézier curve.
            desiredCanonical = quadraticBezier(startCanon, canonicalControl, endCanon, progress);
        } else {
            // --- Linear movement mode ---
            // Instead of moving along the Bézier, convert the current camera position into canonical space,
            // then move it directly toward the target endpoint.
            Vec3d playerEye = player.getEyePos();
            float playerYaw = player.getYaw();
            float playerPitch = player.getPitch();
            // Convert current absolute camera position to canonical coordinates.
            Vec3d currentCanon = unrotateVectorByYawPitch(current.getPosition().subtract(playerEye), playerYaw, playerPitch);
            // Compute the difference from the current position to the target.
            Vec3d delta = endCanon.subtract(currentCanon);
            double deltaLength = delta.length();
            double maxMove = positionSpeedLimit * (1.0 / 20.0); // maximum movement per tick
            // Calculate the movement step: scale the delta by positionEasing, but clamp its length to maxMove.
            Vec3d move;
            if (deltaLength > 0) {
                move = delta.multiply(positionEasing);
                if (move.length() > maxMove) {
                    move = move.normalize().multiply(maxMove);
                }
            } else {
                move = Vec3d.ZERO;
            }
            // The new canonical target is the current position plus the clamped move vector.
            desiredCanonical = currentCanon.add(move);
        }
        // Convert the desired canonical position back to absolute world space using the player's current eye position and rotation.
        Vec3d conversionEye = player.getEyePos();
        float conversionYaw = player.getYaw();
        float conversionPitch = player.getPitch();
        Vec3d desiredAbs = conversionEye.add(rotateVectorByYawPitch(desiredCanonical, conversionYaw, conversionPitch));
        // --- Rotation easing (remains the same) ---
        float targetYaw, targetPitch;
        if (!resetting && this.endTarget == END_TARGET.FRONT) {
            targetYaw = conversionYaw + 180f;
            targetPitch = -conversionPitch;
        } else {
            targetYaw = conversionYaw;
            targetPitch = conversionPitch;
        }
        float yawError = targetYaw - current.getYaw();
        float pitchError = targetPitch - current.getPitch();
        while (yawError > 180) yawError -= 360;
        while (yawError < -180) yawError += 360;
        float desiredYawSpeed = (float)(yawError * rotationEasing);
        float desiredPitchSpeed = (float)(pitchError * rotationEasing);
        float maxRotation = (float)(rotationSpeedLimit * (1.0 / 20.0));
        if (Math.abs(desiredYawSpeed) > maxRotation) {
            desiredYawSpeed = Math.signum(desiredYawSpeed) * maxRotation;
        }
        if (Math.abs(desiredPitchSpeed) > maxRotation) {
            desiredPitchSpeed = Math.signum(desiredPitchSpeed) * maxRotation;
        }
        float newYaw = current.getYaw() + desiredYawSpeed;
        float newPitch = current.getPitch() + desiredPitchSpeed;
        current = new CameraTarget(desiredAbs, newYaw, newPitch);
        // Compute a normalized "alpha" value (fraction remaining) for use by other systems if needed.
        double remaining = desiredCanonical.distanceTo(endCanon);
        alpha = totalDistance != 0 ? remaining / totalDistance : 0.0;
        // Once the out phase completes, switch to linear mode and recalc canonical endpoints.
        if (!resetting && progress >= 0.999) {
            linearMode = true;
            Vec3d curEye = player.getEyePos();
            float curYaw = player.getYaw();
            float curPitch = player.getPitch();
            canonicalStart = unrotateVectorByYawPitch(current.getPosition().subtract(curEye), curYaw, curPitch);
            canonicalEnd = unrotateVectorByYawPitch(getEndTarget(player, targetDistance)
                    .getPosition().subtract(curEye), curYaw, curPitch);
        }
        boolean complete = resetting && progress >= 0.999;
        return new MovementState(current, complete);
    }
    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        if (client.player == null) return;
        if (!resetting) {
            resetting = true;
            linearMode = false;
            progress = 1.0 - progress;
            canonicalControl = generateControlPoint(canonicalEnd, originalCanonicalStart);
            if (CraneshotClient.CAMERA_CONTROLLER.getMovementManager() != null) {
                CraneshotClient.CAMERA_CONTROLLER.getMovementManager().resetMovement(this);
            }
        }
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? 1.1 : 0.9;
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
        if (linearMode) {
            distanceChanged = true;
        }
    }
    @Override
    public String getName() {
        return "Bezier (Canonical Relative)";
    }
    @Override
    public float getWeight() {
        return weight;
    }
    @Override
    public boolean isComplete() {
        return resetting && progress >= 0.999;
    }
    /**
     * Converts a canonical (local) vector into world space using the given yaw and pitch.
     * (In canonical space a level, south–facing view has forward = (0,0,1).)
     */
    private Vec3d rotateVectorByYawPitch(Vec3d canonical, float playerYaw, float playerPitch) {
        double yawRad   = Math.toRadians(playerYaw);
        double pitchRad = Math.toRadians(playerPitch);
        // Compute forward vector.
        Vec3d forward = new Vec3d(
                -Math.sin(yawRad) * Math.cos(pitchRad),
                -Math.sin(pitchRad),
                Math.cos(yawRad) * Math.cos(pitchRad)
        );
        // Right vector is independent of pitch.
        Vec3d right = new Vec3d(
                Math.cos(yawRad),
                0,
                Math.sin(yawRad)
        );
        // Up vector computed via cross product.
        Vec3d up = right.crossProduct(forward);
        return right.multiply(canonical.x)
                .add(up.multiply(canonical.y))
                .add(forward.multiply(canonical.z));
    }
    /**
     * Converts a world–space offset (typically relative to the player's eye) into canonical space.
     * This is the inverse of rotateVectorByYawPitch().
     */
    private Vec3d unrotateVectorByYawPitch(Vec3d worldVec, float playerYaw, float playerPitch) {
        double yawRad   = Math.toRadians(playerYaw);
        double pitchRad = Math.toRadians(playerPitch);
        Vec3d forward = new Vec3d(
                -Math.sin(yawRad) * Math.cos(pitchRad),
                -Math.sin(pitchRad),
                Math.cos(yawRad) * Math.cos(pitchRad)
        );
        Vec3d right = new Vec3d(
                Math.cos(yawRad),
                0,
                Math.sin(yawRad)
        );
        Vec3d up = right.crossProduct(forward);
        double xCanonical = worldVec.dotProduct(right);
        double yCanonical = worldVec.dotProduct(up);
        double zCanonical = worldVec.dotProduct(forward);
        return new Vec3d(xCanonical, yCanonical, zCanonical);
    }
    @Override
    public boolean hasCompletedOutPhase() {
        return !resetting && progress >= 0.999;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/movements/LinearMovement.java">
package ninja.trek.cameramovements.movements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.util.math.Vec3d;
import ninja.trek.CraneshotClient;
import ninja.trek.cameramovements.CameraMovementType;
import ninja.trek.cameramovements.CameraTarget;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.cameramovements.MovementState;
import ninja.trek.cameramovements.AbstractMovementSettings;
import ninja.trek.config.MovementSetting;
@CameraMovementType(
        name = "Linear Movement",
        description = "Moves the camera with linear interpolation and position controls"
)
public class LinearMovement extends AbstractMovementSettings implements ICameraMovement {
    @MovementSetting(label = "Position Easing", min = 0.01, max = 1.0)
    private double positionEasing = 0.1;
    @MovementSetting(label = "Position Speed Limit", min = 0.1, max = 100.0)
    private double positionSpeedLimit = 2.0;
    @MovementSetting(label = "Rotation Easing", min = 0.01, max = 1.0)
    private double rotationEasing = 0.1;
    @MovementSetting(label = "Rotation Speed Limit", min = 0.1, max = 3600.0)
    private double rotationSpeedLimit = 45.0;
    @MovementSetting(label = "Target Distance", min = 1.0, max = 50.0)
    private double targetDistance = 10.0;
    @MovementSetting(label = "Min Distance", min = 1.0, max = 10.0)
    private double minDistance = 2.0;
    @MovementSetting(label = "Max Distance", min = 10.0, max = 50.0)
    private double maxDistance = 20.0;
    public CameraTarget start = new CameraTarget(), end = new CameraTarget(), current = new CameraTarget();
    private boolean resetting = false;
    private float weight = 1.0f;
    @Override
    public void start(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return;
        start = CameraTarget.fromCamera(camera);
        current = CameraTarget.fromCamera(camera);
        end = getEndTarget(player, targetDistance);
        resetting = false;
        weight = 1.0f;
    }
    @Override
    public MovementState calculateState(MinecraftClient client, Camera camera) {
        PlayerEntity player = client.player;
        if (player == null) return new MovementState(current, true);
        start.set(player.getEyePos(),
                player.getYaw(),
                player.getPitch());
        end.set(getEndTarget(player, targetDistance));
        CameraTarget a, b;
        if (!resetting) {
            a = start;
            b = end;
        } else {
            a = end;
            b = start;
        }
        // Position interpolation with speed limit
        Vec3d desired = current.getPosition().lerp(b.getPosition(), positionEasing);
        Vec3d moveVector = desired.subtract(current.getPosition());
        double moveDistance = moveVector.length();
        if (moveDistance > 0.01) {
            double maxMove = positionSpeedLimit * (1.0/20.0); // Convert blocks/second to blocks/tick
            if (moveDistance > maxMove) {
                Vec3d limitedMove = moveVector.normalize().multiply(maxMove);
                desired = current.getPosition().add(limitedMove);
            }
        }
        // Rotation interpolation with speed limit
        float targetYaw = b.getYaw();
        float targetPitch = b.getPitch();
        // Calculate rotation with easing first
        float yawDiff = targetYaw - current.getYaw();
        float pitchDiff = targetPitch - current.getPitch();
// Normalize angles to [-180, 180]
        while (yawDiff > 180) yawDiff -= 360;
        while (yawDiff < -180) yawDiff += 360;
// Apply easing to get desired rotation speed
        float desiredYawSpeed = (float)(yawDiff * rotationEasing);
        float desiredPitchSpeed = (float)(pitchDiff * rotationEasing);
// Apply rotation speed limit
        float maxRotation = (float)(rotationSpeedLimit * (1.0/20.0)); // Convert degrees/second to degrees/tick
        if (Math.abs(desiredYawSpeed) > maxRotation) {
            desiredYawSpeed = Math.signum(desiredYawSpeed) * maxRotation;
        }
        if (Math.abs(desiredPitchSpeed) > maxRotation) {
            desiredPitchSpeed = Math.signum(desiredPitchSpeed) * maxRotation;
        }
        // Apply the final rotation
        float newYaw = current.getYaw() + desiredYawSpeed;
        float newPitch = current.getPitch() + desiredPitchSpeed;
        current = new CameraTarget(
                desired,
                newYaw,
                newPitch
        );
        alpha = current.getPosition().distanceTo(b.getPosition()) / a.getPosition().distanceTo(b.getPosition());
        boolean complete = resetting && moveDistance < 0.01;
        return new MovementState(current, complete);
    }
    @Override
    public void queueReset(MinecraftClient client, Camera camera) {
        if (client.player == null) return;
        resetting = true;
        if (CraneshotClient.CAMERA_CONTROLLER.getMovementManager() != null) {
            CraneshotClient.CAMERA_CONTROLLER.getMovementManager().resetMovement(this);
        }
    }
    @Override
    public void adjustDistance(boolean increase) {
        double multiplier = increase ? 1.1 : 0.9;
        targetDistance = Math.max(minDistance, Math.min(maxDistance, targetDistance * multiplier));
    }
    @Override
    public String getName() {
        return "Linear";
    }
    @Override
    public float getWeight() {
        return weight;
    }
    @Override
    public boolean isComplete() {
        return resetting && current.getPosition().distanceTo(start.getPosition()) < 0.01;
    }
    @Override
    public boolean hasCompletedOutPhase() {
        return !resetting && current.getPosition().distanceTo(end.getPosition()) < 0.01;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/MovementState.java">
package ninja.trek.cameramovements;
public class MovementState {
    private final CameraTarget target;
    private final boolean isComplete;
    public MovementState(CameraTarget target, boolean isComplete) {
        this.target = target;
        this.isComplete = isComplete;
    }
    public CameraTarget getCameraTarget() {
        return target;
    }
    public boolean isComplete() {
        return isComplete;
    }
}
</file>

<file path="client/java/ninja/trek/cameramovements/RaycastType.java">
package ninja.trek.cameramovements;
/**
 * Enum defining different raycast behaviors for camera collision handling
 */
public enum RaycastType {
    /**
     * No raycast collision checking - camera can clip through blocks
     */
    NONE,
    /**
     * Raycasts from player to desired camera position.
     * If collision detected, moves camera closer to player.
     * Behaves like default Minecraft third person camera.
     */
    NEAR,
    /**
     * Raycasts from desired camera position towards player.
     * If camera would be inside block, moves it to first non-solid position.
     * Provides more stable distant shots by preferring to keep camera far out.
     */
    FAR
}
</file>

<file path="client/java/ninja/trek/cameramovements/RaycastUtil.java">
package ninja.trek.cameramovements;
import net.minecraft.client.MinecraftClient;
import net.minecraft.util.hit.BlockHitResult;
import net.minecraft.util.hit.HitResult;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.RaycastContext;
public class RaycastUtil {
    private static final double CAMERA_OFFSET = 0.5;
    private static final double STEP_SIZE = 0.5;
    private static final double FINE_STEP_SIZE = 0.1;
    public static Vec3d adjustForCollision(Vec3d playerPos, Vec3d targetPos, RaycastType raycastType) {
        MinecraftClient client = MinecraftClient.getInstance();
        if (client.world == null || raycastType == RaycastType.NONE) {
            return targetPos;
        }
        switch (raycastType) {
            case NEAR:
                return handleNearRaycast(client, playerPos, targetPos);
            case FAR:
                return handleFarRaycast(client, playerPos, targetPos);
            default:
                return targetPos;
        }
    }
    private static Vec3d handleNearRaycast(MinecraftClient client, Vec3d playerPos, Vec3d targetPos) {
        BlockHitResult hit = client.world.raycast(new RaycastContext(
                playerPos,
                targetPos,
                RaycastContext.ShapeType.VISUAL,
                RaycastContext.FluidHandling.NONE,
                client.player
        ));
        if (hit.getType() == HitResult.Type.BLOCK) {
            Vec3d hitPos = hit.getPos();
            Vec3d directionVector = hitPos.subtract(playerPos).normalize();
            return hitPos.subtract(directionVector.multiply(CAMERA_OFFSET));
        }
        return targetPos;
    }
    private static Vec3d handleFarRaycast(MinecraftClient client, Vec3d playerPos, Vec3d targetPos) {
        Vec3d direction = targetPos.subtract(playerPos).normalize();
        double totalDistance = targetPos.distanceTo(playerPos);
        // Start from target position
        Vec3d currentPos = targetPos;
        if (isPositionInAir(client, currentPos)) {
            return refinePosition(client, currentPos, direction);
        }
        // Coarse search
        for (double distance = STEP_SIZE; distance < totalDistance; distance += STEP_SIZE) {
            Vec3d checkPos = targetPos.subtract(direction.multiply(distance));
            if (isPositionInAir(client, checkPos)) {
                return refinePosition(client, checkPos, direction.multiply(-1));
            }
        }
        return playerPos;
    }
    private static Vec3d refinePosition(MinecraftClient client, Vec3d startPos, Vec3d direction) {
        // Raycast forward until we hit something
        BlockHitResult hit = client.world.raycast(new RaycastContext(
                startPos,
                startPos.add(direction.multiply(2.0)), // Look 2 blocks ahead
                RaycastContext.ShapeType.VISUAL,
                RaycastContext.FluidHandling.NONE,
                client.player
        ));
        if (hit.getType() == HitResult.Type.BLOCK) {
            Vec3d hitPos = hit.getPos();
            return hitPos.subtract(direction.multiply(CAMERA_OFFSET));
        }
        return startPos;
    }
    private static boolean isPositionInAir(MinecraftClient client, Vec3d pos) {
        BlockPos blockPos = BlockPos.ofFloored(pos);
        return client.world.getBlockState(blockPos).isAir();
    }
}
</file>

<file path="client/java/ninja/trek/CraneshotClient.java">
package ninja.trek;
import net.fabricmc.api.ClientModInitializer;
import net.fabricmc.fabric.api.client.keybinding.v1.KeyBindingHelper;
import net.minecraft.client.option.KeyBinding;
import net.minecraft.client.util.InputUtil;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.config.GeneralSettingsIO;
import ninja.trek.config.MenuOverlayScreen;
import ninja.trek.config.SlotSettingsIO;
import org.lwjgl.glfw.GLFW;
import java.util.List;
public class CraneshotClient implements ClientModInitializer {
	public static KeyBinding[] cameraKeyBinds;
	public static KeyBinding selectMovementType;
	public static final CameraController CAMERA_CONTROLLER = new CameraController();
	public static KeyBinding toggleMenuKey;
	private static boolean isMenuOpen = false;
	public static MenuOverlayScreen MENU = new MenuOverlayScreen();
	@Override
	public void onInitializeClient() {
		toggleMenuKey = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.toggle_menu",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_Z,
				"category.craneshot.ui"
		));
		selectMovementType = KeyBindingHelper.registerKeyBinding(new KeyBinding(
				"key.craneshot.select_movement",
				InputUtil.Type.KEYSYM,
				GLFW.GLFW_KEY_X,
				"category.craneshot.camera"
		));
		cameraKeyBinds = new KeyBinding[]{
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera1",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_C,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera2",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_V,
						"category.craneshot.camera"
				)),
				KeyBindingHelper.registerKeyBinding(new KeyBinding(
						"key.craneshot.camera3",
						InputUtil.Type.KEYSYM,
						GLFW.GLFW_KEY_B,
						"category.craneshot.camera"
				))
		};
		CameraMovementRegistry.initialize();
		GeneralSettingsIO.loadSettings();
		List<List<ICameraMovement>> savedSlots = SlotSettingsIO.loadSlots();
		CAMERA_CONTROLLER.setAllSlots(savedSlots);
		CraneShotEventHandler.register();
	}
	public static void checkKeybinds() {
		if (toggleMenuKey.wasPressed()) {
			MENU.toggleMenu();
		}
	}
}
</file>

<file path="client/java/ninja/trek/CraneshotDataGenerator.java">
package ninja.trek;
import net.fabricmc.fabric.api.datagen.v1.DataGeneratorEntrypoint;
import net.fabricmc.fabric.api.datagen.v1.FabricDataGenerator;
public class CraneshotDataGenerator implements DataGeneratorEntrypoint {
	@Override
	public void onInitializeDataGenerator(FabricDataGenerator fabricDataGenerator) {
	}
}
</file>

<file path="client/java/ninja/trek/CraneShotEventHandler.java">
package ninja.trek;
import net.fabricmc.fabric.api.client.event.lifecycle.v1.ClientTickEvents;
import net.fabricmc.fabric.api.client.rendering.v1.WorldRenderEvents;
import net.fabricmc.fabric.api.client.rendering.v1.HudRenderCallback;
import net.minecraft.client.MinecraftClient;
import net.minecraft.client.render.Camera;
import net.minecraft.text.Text;
import ninja.trek.cameramovements.ICameraMovement;
import ninja.trek.config.SlotMenuSettings;
import ninja.trek.mixin.client.MouseAccessor;
import java.util.HashMap;
import java.util.Map;
public class CraneShotEventHandler {
    private static final double SCROLL_COOLDOWN = 0.1;
    private static double lastScrollTime = 0;
    private static final Map<Integer, Boolean> keyStates = new HashMap<>();
    private static final Map<Integer, Boolean> toggledStates = new HashMap<>();
    public static void register() {
        // Register client tick event for input handling
        ClientTickEvents.END_CLIENT_TICK.register(client -> {
            handleScrollInput(client);
            CraneshotClient.checkKeybinds();
        });
        // Register HUD rendering for messages
        HudRenderCallback.EVENT.register((context, tickDelta) -> {
            MinecraftClient client = MinecraftClient.getInstance();
            if (client.player != null && CraneshotClient.CAMERA_CONTROLLER.hasActiveMessage()) {
                String message = CraneshotClient.CAMERA_CONTROLLER.getCurrentMessage();
                int width = client.getWindow().getScaledWidth();
                context.drawTextWithShadow(
                        client.textRenderer,
                        Text.literal(message),
                        width / 2 - client.textRenderer.getWidth(message) / 2,
                        60,
                        0xFFFFFF
                );
            }
        });
        // Register world render event for camera updates
        WorldRenderEvents.START.register(context -> {
            MinecraftClient client = MinecraftClient.getInstance();
            Camera camera = client.gameRenderer.getCamera();
            // Handle camera movement key states
            boolean anyPressed = false;
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                boolean currentlyPressed = CraneshotClient.cameraKeyBinds[i].isPressed();
                boolean wasPressed = keyStates.getOrDefault(i, false);
                boolean isToggled = toggledStates.getOrDefault(i, false);
                boolean isToggleMode = SlotMenuSettings.getToggleState(i);
                if (isToggleMode) {
                    // Handle toggle mode
                    if (currentlyPressed && !wasPressed) {
                        // Key just pressed - toggle the state
                        isToggled = !isToggled;
                        toggledStates.put(i, isToggled);
                        if (isToggled) {
                            CraneshotClient.CAMERA_CONTROLLER.startTransition(client, camera, i);
                        }
                    }
                    if (isToggled) {
                        anyPressed = true;
                    }
                } else {
                    // Handle momentary mode (original behavior)
                    if (currentlyPressed) {
                        if (!wasPressed) {
                            // Key just pressed - start movement
                            CraneshotClient.CAMERA_CONTROLLER.startTransition(client, camera, i);
                        }
                        anyPressed = true;
                    }
                }
                keyStates.put(i, currentlyPressed);
            }
            // If no keys are pressed or toggled, reset the camera
            if (!anyPressed) {
                CraneshotClient.CAMERA_CONTROLLER.queueFinish(client, camera);
                // Clear toggle states when resetting
                toggledStates.clear();
            }
        });
    }
    private static void handleScrollInput(MinecraftClient client) {
        double currentTime = System.currentTimeMillis() / 1000.0;
        if (currentTime - lastScrollTime < SCROLL_COOLDOWN) {
            return;
        }
        MouseAccessor mouseAccessor = (MouseAccessor)client.mouse;
        double scrollDelta = mouseAccessor.getEventDeltaVerticalWheel();
        if (scrollDelta == 0) {
            return;
        }
        boolean scrollUp = scrollDelta > 0;
        // Handle movement type cycling
        if (CraneshotClient.selectMovementType.isPressed()) {
            CraneshotClient.CAMERA_CONTROLLER.cycleMovementType(scrollUp);
            // Find the active movement to display its type
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    CraneshotClient.CAMERA_CONTROLLER.showMovementTypeMessage(i);
                    break;
                }
            }
            lastScrollTime = currentTime;
            mouseAccessor.setEventDeltaVerticalWheel(0);
        }
        // Handle distance adjustment
        else {
            for (int i = 0; i < CraneshotClient.cameraKeyBinds.length; i++) {
                if (CraneshotClient.cameraKeyBinds[i].isPressed()) {
                    CraneshotClient.CAMERA_CONTROLLER.adjustDistance(i, !scrollUp);
                    lastScrollTime = currentTime;
                    mouseAccessor.setEventDeltaVerticalWheel(0);
                    break;
                }
            }
        }
    }
}
</file>

<file path="client/java/ninja/trek/IMouseMixin.java">
package ninja.trek;
public interface IMouseMixin {
    double getCapturedDeltaX();
    double getCapturedDeltaY();
}
</file>

<file path="client/java/ninja/trek/mixin/client/CameraAccessor.java">
package ninja.trek.mixin.client;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.Entity;
import net.minecraft.util.math.Vec3d;
import net.minecraft.world.BlockView;
import ninja.trek.CraneshotClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import org.spongepowered.asm.mixin.gen.Invoker;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
// CameraAccessor.java
@Mixin(Camera.class)
public interface CameraAccessor {
    @Accessor("pos")
    void invokesetPos(Vec3d pos);
    @Accessor("pos")
    Vec3d getPos();
    @Invoker("setRotation")
    void invokeSetRotation(float yaw, float pitch);
}
</file>

<file path="client/java/ninja/trek/mixin/client/CameraMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.render.Camera;
import net.minecraft.entity.Entity;
import net.minecraft.world.BlockView;
import ninja.trek.CraneshotClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
// CameraMixin.java
@Mixin(Camera.class)
public class CameraMixin {
    @Inject(method = "update", at = @At("TAIL"))
    private void onCameraUpdate(BlockView area, Entity focusedEntity, boolean thirdPerson,
                                boolean inverseView, float tickDelta, CallbackInfo ci) {
        CraneshotClient.CAMERA_CONTROLLER.handleCameraUpdate(area, focusedEntity, thirdPerson, inverseView, tickDelta, (Camera)(Object)this);
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/ExampleClientMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.MinecraftClient;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftClient.class)
public class ExampleClientMixin {
	@Inject(at = @At("HEAD"), method = "run")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftClient.run()V
	}
}
</file>

<file path="client/java/ninja/trek/mixin/client/KeyboardInputMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.input.Input;
import net.minecraft.client.input.KeyboardInput;
import net.minecraft.client.option.GameOptions;
import org.spongepowered.asm.mixin.Final;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(KeyboardInput.class)
public abstract class KeyboardInputMixin extends Input {
    @Shadow @Final private GameOptions settings;
    private boolean disabled = true;
    private float savedForward, savedSideways;
    private boolean savedJumping, savedSneaking;
    @Inject(method = "tick", at = @At("HEAD"), cancellable = true)
    private void onTick(boolean slowDown, float slowDownFactor, CallbackInfo ci) {
        if (disabled) {
            this.movementForward = 0;
            this.movementSideways = 0;
            this.jumping = false;
            this.sneaking = false;
            ci.cancel();
        } else {
            this.movementForward = savedForward;
            this.movementSideways = savedSideways;
            this.jumping = savedJumping;
            this.sneaking = savedSneaking;
        }
    }
    public void setDisabled(boolean disabled) {
        if (this.disabled != disabled) {
            this.disabled = disabled;
            if (!disabled) {
                // Store current state when enabling
                this.savedForward = this.movementForward;
                this.savedSideways = this.movementSideways;
                this.savedJumping = this.jumping;
                this.savedSneaking = this.sneaking;
            }
        }
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseAccessor.java">
package ninja.trek.mixin.client;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.gen.Accessor;
import net.minecraft.client.Mouse;
@Mixin(Mouse.class)
public interface MouseAccessor {
    @Accessor("cursorDeltaX")
    double getCursorDeltaX();
    @Accessor("cursorDeltaY")
    double getCursorDeltaY();
    @Accessor("cursorDeltaX")
    void setCursorDeltaX(double value);
    @Accessor("cursorDeltaY")
    void setCursorDeltaY(double value);
    @Accessor("eventDeltaVerticalWheel")
    double getEventDeltaVerticalWheel();
    @Accessor("eventDeltaVerticalWheel")
    void setEventDeltaVerticalWheel(double value);
}
</file>

<file path="client/java/ninja/trek/mixin/client/MouseMixin.java">
// File: client/java/ninja/trek/mixin/client/MouseMixin.java
package ninja.trek.mixin.client;
import net.minecraft.client.Mouse;
import ninja.trek.IMouseMixin;
import ninja.trek.MouseInterceptor;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.Shadow;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(Mouse.class)
public class MouseMixin implements IMouseMixin {
    @Shadow private double cursorDeltaX;
    @Shadow private double cursorDeltaY;
    // Remove the static field and methods from here.
    // Instance fields for captured values.
    private double capturedDeltaX;
    private double capturedDeltaY;
    @Inject(method = "updateMouse", at = @At("HEAD"), cancellable = true)
    private void onUpdateMouse(CallbackInfo ci) {
        if (MouseInterceptor.isIntercepting()) { // use the helper class instead
            // Capture the deltas before they're cleared
            capturedDeltaX = cursorDeltaX;
            capturedDeltaY = cursorDeltaY;
            // Clear the actual deltas to prevent normal camera movement
            cursorDeltaX = 0;
            cursorDeltaY = 0;
            ci.cancel();
        }
    }
    @Inject(method = "onMouseButton", at = @At("HEAD"), cancellable = true)
    private void onMouseButton(long window, int button, int action, int mods, CallbackInfo ci) {
        if (MouseInterceptor.isIntercepting()) { // use the helper class
            ci.cancel();
        }
    }
    @Override
    public double getCapturedDeltaX() {
        return capturedDeltaX;
    }
    @Override
    public double getCapturedDeltaY() {
        return capturedDeltaY;
    }
}
</file>

<file path="client/java/ninja/trek/mixin/client/WorldRendererMixin.java">
package ninja.trek.mixin.client;
import net.minecraft.client.render.WorldRenderer;
import net.minecraft.client.render.Camera;
import net.minecraft.client.render.Frustum;
import net.minecraft.util.math.ChunkSectionPos;
import net.minecraft.util.math.Vec3d;
import ninja.trek.CameraController;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.ModifyVariable;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(WorldRenderer.class)
public class WorldRendererMixin {
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 0
    )
    private double modifyPlayerX(double d) {
        if (CameraController.inFreeControlMode) {
            return CameraController.freeCamPosition.x;
        }
        return d;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 1
    )
    private double modifyPlayerY(double e) {
        if (CameraController.inFreeControlMode) {
            return CameraController.freeCamPosition.y;
        }
        return e;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 2
    )
    private double modifyPlayerZ(double f) {
        if (CameraController.inFreeControlMode) {
            return CameraController.freeCamPosition.z;
        }
        return f;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 3
    )
    private double modifyCameraX(double g) {
        if (CameraController.inFreeControlMode) {
            return Math.floor(CameraController.freeCamPosition.x / 8.0);
        }
        return g;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 4
    )
    private double modifyCameraY(double h) {
        if (CameraController.inFreeControlMode) {
            return Math.floor(CameraController.freeCamPosition.y / 8.0);
        }
        return h;
    }
    @ModifyVariable(
            method = "setupTerrain",
            at = @At(value = "STORE"),
            ordinal = 5
    )
    private double modifyCameraZ(double l) {
        if (CameraController.inFreeControlMode) {
            return Math.floor(CameraController.freeCamPosition.z / 8.0);
        }
        return l;
    }
    @Inject(
            method = "setupTerrain",
            at = @At(
                    value = "FIELD",
                    target = "Lnet/minecraft/client/render/WorldRenderer;lastCameraZ:D",
                    ordinal = 0,
                    shift = At.Shift.AFTER
            )
    )
    private void modifyChunkBuilderPosition(Camera camera, Frustum frustum, boolean hasForcedFrustum, boolean spectator, CallbackInfo ci) {
        if (CameraController.inFreeControlMode) {
            WorldRenderer worldRenderer = (WorldRenderer)(Object)this;
            worldRenderer.getChunkBuilder().setCameraPosition(CameraController.freeCamPosition);
        }
    }
}
</file>

<file path="client/java/ninja/trek/MouseInterceptor.java">
package ninja.trek;
public class MouseInterceptor {
    private static boolean intercepting = false;
    public static void setIntercepting(boolean intercept) {
        intercepting = intercept;
    }
    public static boolean isIntercepting() {
        return intercepting;
    }
}
</file>

<file path="client/resources/craneshot.client.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin.client",
	"compatibilityLevel": "JAVA_21",
	"client": [
		"MouseMixin",
		"CameraAccessor",
		"CameraMixin",
		"MouseAccessor",
		"KeyboardInputMixin",
		"WorldRendererMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/java/ninja/trek/Craneshot.java">
package ninja.trek;
import net.fabricmc.api.ModInitializer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
public class Craneshot implements ModInitializer {
	public static final String MOD_ID = "craneshot";
	public static final Logger LOGGER = LoggerFactory.getLogger(MOD_ID);
	@Override
	public void onInitialize() {
		LOGGER.info("CraneShot Camera Mod initialized!");
	}
}
</file>

<file path="main/java/ninja/trek/mixin/ExampleMixin.java">
package ninja.trek.mixin;
import net.minecraft.server.MinecraftServer;
import org.spongepowered.asm.mixin.Mixin;
import org.spongepowered.asm.mixin.injection.At;
import org.spongepowered.asm.mixin.injection.Inject;
import org.spongepowered.asm.mixin.injection.callback.CallbackInfo;
@Mixin(MinecraftServer.class)
public class ExampleMixin {
	@Inject(at = @At("HEAD"), method = "loadWorld")
	private void init(CallbackInfo info) {
		// This code is injected into the start of MinecraftServer.loadWorld()V
	}
}
</file>

<file path="main/resources/craneshot.mixins.json">
{
	"required": true,
	"package": "ninja.trek.mixin",
	"compatibilityLevel": "JAVA_21",
	"mixins": [
		"ExampleMixin"
	],
	"injectors": {
		"defaultRequire": 1
	}
}
</file>

<file path="main/resources/fabric.mod.json">
{
	"schemaVersion": 1,
	"id": "craneshot",
	"version": "${version}",
	"name": "craneshot",
	"description": "Advanced camera controls mod for cinematics",
	"authors": ["Me!"],
	"contact": {
		"homepage": "https://fabricmc.net/",
		"sources": "https://github.com/FabricMC/fabric-example-mod"
	},
	"license": "CC0-1.0",
	"icon": "assets/craneshot/icon.png",
	"environment": "*",
	"entrypoints": {
		"main": ["ninja.trek.Craneshot"],
		"client": ["ninja.trek.CraneshotClient"],
		
		"fabric-datagen": ["ninja.trek.CraneshotDataGenerator"]
	},
	"mixins": [
		"craneshot.mixins.json",
		{
			"config": "craneshot.client.mixins.json",
			"environment": "client"
		}
	],
	"depends": {
		"fabricloader": ">=0.16.10",
		"minecraft": "~1.21",
		"java": ">=21",
		"fabric-api": "*",
		"fabric-key-binding-api-v1": "*"
	}
}
</file>

<file path="repomixx - ignore config.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**" --ignore **/config/**
</file>

<file path="repomixx - movements only.bat">
repomix client/java/ninja/trek/cameraMovements/movements --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

<file path="repomixx.bat">
repomix --style xml --remove-empty-lines --copy --ignore "**/generated/**"
</file>

</files>
