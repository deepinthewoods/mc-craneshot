            
            boolean isOutPosition = (currentEndTarget == AbstractMovementSettings.END_TARGET.HEAD_BACK ||
                                    currentEndTarget == AbstractMovementSettings.END_TARGET.FIXED_BACK ||
                                    currentEndTarget == AbstractMovementSettings.END_TARGET.VELOCITY_BACK);
            
            // Capture existing camera position before activating any new camera mode
            Vec3d existingCameraPos = camera.getPos();
            float existingYaw = camera.getYaw();
            float existingPitch = camera.getPitch();
            
            // Activate the appropriate camera mode
            CameraSystem cameraSystem = CameraSystem.getInstance();
            if (isFreeCamMode) {
                // Set the position first, so it's available during activation
                cameraSystem.setCameraPosition(freeCamPosition);
                cameraSystem.setCameraRotation(freeCamYaw, freeCamPitch);
                
                // Then activate the camera
                cameraSystem.activateCamera(CameraSystem.CameraMode.FREE_CAMERA);
                
                // Update the camera immediately to apply our position
                cameraSystem.updateCamera(camera);
                
                // Add debug logging
                ninja.trek.Craneshot.LOGGER.info("Activating free camera at position: {} {} {}", 
                    freeCamPosition.getX(), freeCamPosition.getY(), freeCamPosition.getZ());
            } else if (isOutPosition) {
                cameraSystem.activateCamera(CameraSystem.CameraMode.THIRD_PERSON);
            }
        }
    }

    private void handleKeyboardMovement(MinecraftClient client, Camera camera) {
        if (client.player == null) return;

        // Let the camera system handle movement
        CameraSystem cameraSystem = CameraSystem.getInstance();
        if (cameraSystem.isCameraActive()) {
            FreeCamSettings settings = GeneralMenuSettings.getFreeCamSettings();
            boolean moved = cameraSystem.handleMovementInput(
                settings.getMoveSpeed(),
                settings.getAcceleration(),
                settings.getDeceleration()
            );
            
            // Track if camera moved when using the camera system
            if (moved) {
                hasMovedWithKeyboard = true;
            }
            return;
        }

        // Legacy movement code
        // Base movement speed in blocks per tick
        float baseSpeed = GeneralMenuSettings.getFreeCamSettings().getMoveSpeed();

        // Sprint multiplier
        if (client.options.sprintKey.isPressed()) {
            baseSpeed *= 3.0f;
        }

        Vec3d targetVelocity = Vec3d.ZERO;
        
        // Calculate movement direction
        if (currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            // Free camera movement in all directions
            double x = 0, y = 0, z = 0;
            
            if (client.options.forwardKey.isPressed()) {
                z += 1.0;
            }
            if (client.options.backKey.isPressed()) {
                z -= 1.0;
            }
            if (client.options.leftKey.isPressed()) {
                x += 1.0;
            }
            if (client.options.rightKey.isPressed()) {
                x -= 1.0;
            }
            if (client.options.jumpKey.isPressed()) {
                y += 1.0;
            }
            if (client.options.sneakKey.isPressed()) {
                y -= 1.0;
            }
            
            // Normalize if moving in multiple directions simultaneously
            if ((x != 0 && z != 0) || (x != 0 && y != 0) || (z != 0 && y != 0)) {
                double length = Math.sqrt(x * x + y * y + z * z);
                x /= length;
                y /= length;
                z /= length;
            }
            
            // Convert to camera-relative movement
            float yaw = freeCamYaw;
            float pitch = freeCamPitch;
            double xFactor = Math.sin(yaw * Math.PI / 180.0);
            double zFactor = Math.cos(yaw * Math.PI / 180.0);
            
            targetVelocity = new Vec3d(
                (x * zFactor - z * xFactor), 
                y, 
                (z * zFactor + x * xFactor)
            );
            
        } else if (currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FLAT) {
            // Y-axis locked camera movement
            double x = 0, z = 0;
            
            if (client.options.forwardKey.isPressed()) {
                z += 1.0;
            }
            if (client.options.backKey.isPressed()) {
                z -= 1.0;
            }
            if (client.options.leftKey.isPressed()) {
                x += 1.0;
            }
            if (client.options.rightKey.isPressed()) {
                x -= 1.0;
            }
            
            // Y movement from jump/sneak
            double y = 0;
            if (client.options.jumpKey.isPressed()) {
                y += 1.0;
            }
            if (client.options.sneakKey.isPressed()) {
                y -= 1.0;
            }
            
            // Normalize XZ movement
            if (x != 0 && z != 0) {
                double length = Math.sqrt(x * x + z * z);
                x /= length;
                z /= length;
            }
            
            // Convert to camera-relative XZ movement with free Y
            float yaw = freeCamYaw;
            double xFactor = Math.sin(yaw * Math.PI / 180.0);
            double zFactor = Math.cos(yaw * Math.PI / 180.0);
            
            targetVelocity = new Vec3d(
                (x * zFactor - z * xFactor), 
                y, 
                (z * zFactor + x * xFactor)
            );
        }

        // Normalize and apply speed to target velocity if there's any movement
        if (targetVelocity.lengthSquared() > 0.0001) {
            targetVelocity = targetVelocity.normalize().multiply(baseSpeed);
        }

        // Apply acceleration or deceleration
        float acceleration = GeneralMenuSettings.getFreeCamSettings().getAcceleration();
        float deceleration = GeneralMenuSettings.getFreeCamSettings().getDeceleration();

        if (targetVelocity.lengthSquared() > 0.0001) {
            // Accelerating
            currentVelocity = currentVelocity.add(
                    targetVelocity.subtract(currentVelocity).multiply(acceleration)
            );
            
            // Mark as moved with keyboard if acceleration is happening
            if (!hasMovedWithKeyboard) {
                hasMovedWithKeyboard = true;
                ninja.trek.Craneshot.LOGGER.info("Camera movement detected - enabling smooth return");
            }
        } else {
            // Decelerating
            currentVelocity = currentVelocity.multiply(1.0 - deceleration);
            // Zero out very small velocities to prevent perpetual drift
            if (currentVelocity.lengthSquared() < 0.0001) {
                currentVelocity = Vec3d.ZERO;
            }
        }

        // Apply movement
        freeCamPosition = freeCamPosition.add(currentVelocity);
        ((CameraAccessor) camera).invokesetPos(freeCamPosition);
    }

    public void updateCamera(MinecraftClient client, Camera camera, float delta) {
        updateControlStick(client);

        // Get the base camera state from movement manager - always update to track state
        CameraTarget baseTarget = CraneshotClient.MOVEMENT_MANAGER.update(client, camera);

        // Check if we have an active camera system
        CameraSystem cameraSystem = CameraSystem.getInstance();
        boolean cameraSystemActive = cameraSystem.isCameraActive();

        if (baseTarget != null) {
            // Update FOV in game renderer
            if (client.gameRenderer instanceof FovAccessor) {
                float fovMultiplier = (float) baseTarget.getFovMultiplier();
