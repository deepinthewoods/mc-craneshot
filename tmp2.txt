    // Belt/world blur guard: override to prevent any blur application
    @Override
    protected void applyBlur(DrawContext context) {
        // no-op
    }

    @Override
    public boolean keyPressed(KeyInput input) {
        // Close and start return on ESC
        if (input.getKeycode() == GLFW.GLFW_KEY_ESCAPE) {
            closeAndStartReturn();
            return true;
        }

        // If user hits the active slot hotkey again while editing, close and start return
        if (this.client != null) {
            Integer activeSlot = ninja.trek.CraneshotClient.MOVEMENT_MANAGER.getActiveMovementSlot();
            if (activeSlot != null && activeSlot >= 0 && activeSlot < ninja.trek.CraneshotClient.cameraKeyBinds.length) {
                net.minecraft.client.option.KeyBinding kb = ninja.trek.CraneshotClient.cameraKeyBinds[activeSlot];
                if (kb != null && kb.matchesKey(input)) {
                    closeAndStartReturn();
                    return true;
                }
            }
        }

        // For movement keys (WASD, jump, sneak, sprint) don't consume; camera controller polls states
        // Let super handle other UI keys
        return super.keyPressed(input);
    }

    private void closeAndStartReturn() {
        // Mark node editing off and start camera return
        ninja.trek.nodes.NodeManager.get().setEditing(false);
        if (this.client != null) {
            ninja.trek.CraneshotClient.MOVEMENT_MANAGER.finishTransition(this.client, this.client.gameRenderer.getCamera());
            this.client.setScreen(null);
        }
    }

    @Override
    public boolean mouseClicked(Click click, boolean fromInside) {
        if (click != null) {
            dragging = true;
            try {
                Camera cam = MinecraftClient.getInstance().gameRenderer.getCamera();
                if (cam != null) {
                    NodeManager.get().selectNearestToScreen(click.x(), click.y(), this.width, this.height, cam);
                    this.init(client, this.width, this.height);
                }
            } catch (Throwable t) {
                // Fallback: select center
                Camera cam = MinecraftClient.getInstance().gameRenderer.getCamera();
                if (cam != null) {
                    NodeManager.get().selectNearestToScreen(this.width/2.0, this.height/2.0, this.width, this.height, cam);
                    this.init(client, this.width, this.height);
                }
            }
        }
        return super.mouseClicked(click, fromInside);
    }

    @Override
    public boolean mouseReleased(Click click) {
        dragging = false;
        return super.mouseReleased(click);
    }

    @Override
    public boolean mouseDragged(Click click, double deltaX, double deltaY) {
        if (dragging) {
            double sens = MinecraftClient.getInstance().options.getMouseSensitivity().getValue();
            double calc = 0.6 * sens * sens * sens + 0.2;
            // Apply Node Editor sensitivity multiplier (default 6x) and invert X direction
            double mult = ninja.trek.config.GeneralMenuSettings.getNodeEditSensitivityMultiplier();
            double scaleEntity = calc * mult;
            double scaleSystem = calc * 0.55D * mult;
            // Rotate using regular freecam pipeline: entity if present, otherwise CameraSystem
            ninja.trek.util.CameraEntity camEnt = ninja.trek.util.CameraEntity.getCamera();
            if (camEnt != null) {
                camEnt.updateCameraRotations((float)(-deltaX * scaleEntity), (float)(-deltaY * scaleEntity));
            } else {
                ninja.trek.camera.CameraSystem.getInstance().updateRotation(-deltaX * scaleSystem, -deltaY * scaleSystem, 1.0);
            }
        }
        return super.mouseDragged(click, deltaX, deltaY);
    }
}

