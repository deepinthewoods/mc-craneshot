                .checked(GeneralMenuSettings.isAutoAdvance())
                .callback((checkbox, checked) -> GeneralMenuSettings.setAutoAdvance(checked))
                .build());

        yOffset += spacing;
        
        // Add collapsible Free Camera section header
        String freeCamKey = "freeCamSection";
        boolean freeCamExpanded = isSettingsExpanded(freeCamKey);
        this.addDrawableChild(ButtonWidget.builder(
                Text.literal((freeCamExpanded ? "▼ " : "▶ ") + "Free Camera Settings").formatted(Formatting.YELLOW),
                button -> {
                    toggleSettingsExpanded(freeCamKey);
                    reinitialize();
                })
                .dimensions(buttonX, centerY + yOffset, buttonWidth, BUTTON_HEIGHT)
                .build());
        yOffset += spacing;
        
        if (freeCamExpanded) {
            // Move Speed Slider
            float currentSpeed = GeneralMenuSettings.getFreeCamSettings().getMoveSpeed();
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Free Camera Speed"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Free Camera Speed"),
                    0.1f,
                    2.0f,
                    currentSpeed,
                    "moveSpeed",
                    new AbstractMovementSettings() {
                        @Override
                        public void updateSetting(String key, Object value) {
                            if (key.equals("moveSpeed") && value instanceof Number) {
                                GeneralMenuSettings.getFreeCamSettings().setMoveSpeed(((Number)value).floatValue());
                            }
                        }
                    }
            ));

            yOffset += spacing;

            // Acceleration Slider
            float currentAcceleration = GeneralMenuSettings.getFreeCamSettings().getAcceleration();
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Acceleration"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Acceleration"),
                    0.01f,
                    0.5f,
                    currentAcceleration,
                    "acceleration",
                    new AbstractMovementSettings() {
                        @Override
                        public void updateSetting(String key, Object value) {
                            if (key.equals("acceleration") && value instanceof Number) {
                                GeneralMenuSettings.getFreeCamSettings().setAcceleration(((Number)value).floatValue());
                            }
                        }
                    }
            ));

            yOffset += spacing;

            // Deceleration Slider
            float currentDeceleration = GeneralMenuSettings.getFreeCamSettings().getDeceleration();
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Deceleration"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Deceleration"),
                    0.01f,
                    0.5f,
                    currentDeceleration,
                    "deceleration",
                    new AbstractMovementSettings() {
                        @Override
                        public void updateSetting(String key, Object value) {
                            if (key.equals("deceleration") && value instanceof Number) {
                                GeneralMenuSettings.getFreeCamSettings().setDeceleration(((Number)value).floatValue());
                            }
                        }
                    }
            ));

            yOffset += spacing;

            // Movement Mode Button
            FreeCamSettings.MovementMode currentMode = GeneralMenuSettings.getFreeCamSettings().getMovementMode();
            this.addDrawableChild(ButtonWidget.builder(
                            Text.literal("Movement Mode: " + currentMode.name()),
                            button -> {
                                FreeCamSettings.MovementMode[] modes =
                                        FreeCamSettings.MovementMode.values();
                                int nextOrdinal = (currentMode.ordinal() + 1) % modes.length;
                                GeneralMenuSettings.getFreeCamSettings().setMovementMode(modes[nextOrdinal]);
                                button.setMessage(Text.literal("Movement Mode: " + modes[nextOrdinal].name()));
                            })
                    .dimensions(buttonX, centerY + yOffset, buttonWidth, 20)
                    .build()
            );
        }
        
        // Add collapsible Free Camera Return section header
        yOffset += spacing;
        String freeCamReturnKey = "freeCamReturnSection";
        boolean freeCamReturnExpanded = isSettingsExpanded(freeCamReturnKey);
        this.addDrawableChild(ButtonWidget.builder(
                Text.literal((freeCamReturnExpanded ? "▼ " : "▶ ") + "Free Camera Return Settings").formatted(Formatting.YELLOW),
                button -> {
                    toggleSettingsExpanded(freeCamReturnKey);
                    reinitialize();
                })
                .dimensions(buttonX, centerY + yOffset, buttonWidth, BUTTON_HEIGHT)
                .build());
                
        if (freeCamReturnExpanded) {
            // Add settings for FreeCamReturnMovement
            yOffset += spacing;
            ninja.trek.cameramovements.movements.FreeCamReturnMovement freeCamReturn = GeneralMenuSettings.getFreeCamReturnMovement();
            
            // Position Easing slider
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Position Easing"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
                    
            // Use reflection to get the current value
            double positionEasing = 0.2; // Default value
            try {
                java.lang.reflect.Field field = freeCamReturn.getClass().getDeclaredField("positionEasing");
                field.setAccessible(true);
                positionEasing = (double)field.get(freeCamReturn);
            } catch (Exception e) {
                Craneshot.LOGGER.error("Failed to get positionEasing", e);
            }
            
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Position Easing"),
                    0.01f,
                    1.0f,
                    positionEasing,
                    "positionEasing",
                    (AbstractMovementSettings)freeCamReturn
            ));
            
            // Position Speed Limit slider
            yOffset += spacing;
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Position Speed Limit"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
                    
            // Use reflection to get the current value
            double positionSpeedLimit = 5.0; // Default value
            try {
                java.lang.reflect.Field field = freeCamReturn.getClass().getDeclaredField("positionSpeedLimit");
                field.setAccessible(true);
                positionSpeedLimit = (double)field.get(freeCamReturn);
            } catch (Exception e) {
                Craneshot.LOGGER.error("Failed to get positionSpeedLimit", e);
            }
            
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Position Speed Limit"),
                    0.1f,
                    20.0f,
                    positionSpeedLimit,
                    "positionSpeedLimit",
                    (AbstractMovementSettings)freeCamReturn
            ));
            
            // Rotation Easing slider
            yOffset += spacing;
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Rotation Easing"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
                    
            // Use reflection to get the current value
            double rotationEasing = 0.2; // Default value
            try {
                java.lang.reflect.Field field = freeCamReturn.getClass().getDeclaredField("rotationEasing");
                field.setAccessible(true);
                rotationEasing = (double)field.get(freeCamReturn);
            } catch (Exception e) {
                Craneshot.LOGGER.error("Failed to get rotationEasing", e);
            }
            
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Rotation Easing"),
                    0.01f,
                    1.0f,
                    rotationEasing,
                    "rotationEasing",
                    (AbstractMovementSettings)freeCamReturn
            ));
            
            // Rotation Speed Limit slider
            yOffset += spacing;
            this.addDrawableChild(ButtonWidget.builder(Text.literal("Rotation Speed Limit"), button -> {})
                    .dimensions(buttonX, centerY + yOffset, labelWidth, BUTTON_HEIGHT)
                    .build());
                    
            // Use reflection to get the current value
            double rotationSpeedLimit = 90.0; // Default value
            try {
                java.lang.reflect.Field field = freeCamReturn.getClass().getDeclaredField("rotationSpeedLimit");
                field.setAccessible(true);
                rotationSpeedLimit = (double)field.get(freeCamReturn);
            } catch (Exception e) {
                Craneshot.LOGGER.error("Failed to get rotationSpeedLimit", e);
            }
            
            this.addDrawableChild(SettingWidget.createSlider(
                    buttonX + labelWidth + 10,
                    centerY + yOffset,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal("Rotation Speed Limit"),
                    0.1f,
                    360.0f,
                    rotationSpeedLimit,
                    "rotationSpeedLimit",
                    (AbstractMovementSettings)freeCamReturn
            ));
        }
        
        // Update max scroll to handle the expanded/collapsed sections
        updateScrollBounds(yOffset + spacing);
    }
    private void createMovementList(int slotIndex, int visibleStartY, int visibleEndY,
                                    int BUTTON_HEIGHT, int MOVEMENT_ROW_HEIGHT, int MOVEMENT_SPACING, int SETTING_HEIGHT) {
        List<ICameraMovement> movements = CraneshotClient.MOVEMENT_MANAGER.getAvailableMovementsForSlot(slotIndex);
        int yOffset = CONTENT_START_Y + BUTTON_HEIGHT + 10;

        for (int i = 0; i < movements.size(); i++) {
            int index = i;
            ICameraMovement movement = movements.get(i);
            int rowY = centerY + yOffset - scrollOffset;

            if (rowY >= visibleStartY - BUTTON_HEIGHT && rowY <= visibleEndY) {
                createMovementControls(slotIndex, index, movement, rowY, BUTTON_HEIGHT);
            }

            yOffset += MOVEMENT_ROW_HEIGHT;

            if (movement instanceof AbstractMovementSettings settings && isMovementExpanded(slotIndex, index)) {
                yOffset = createSettingsSection(settings, rowY, yOffset, visibleStartY, visibleEndY,
                        BUTTON_HEIGHT, SETTING_HEIGHT, MOVEMENT_SPACING);
            } else {
                yOffset += MOVEMENT_SPACING;
            }
        }

        updateScrollBounds(yOffset);
    }

    private int createSettingsSection(AbstractMovementSettings settings, int rowY, int yOffset,
                                      int visibleStartY, int visibleEndY, int BUTTON_HEIGHT, int SETTING_HEIGHT, int MOVEMENT_SPACING) {
        List<Field> settingFields = new ArrayList<>();
        collectSettingFields(settings, settingFields);

        int totalWidth = guiWidth - 40;
        int labelWidth = Math.min(200, totalWidth / 3);  // Increased from 150 to 200
        int controlWidth = Math.min(200, totalWidth / 2);
        int settingWidth = labelWidth + controlWidth + 10;
        int columnsCount = Math.max(1, Math.min(3, (totalWidth + 20) / (settingWidth + 20)));
        int settingsPerColumn = (int) Math.ceil(settingFields.size() / (double) columnsCount);

        for (int fieldIndex = 0; fieldIndex < settingFields.size(); fieldIndex++) {
            Field field = settingFields.get(fieldIndex);
            MovementSetting annotation = field.getAnnotation(MovementSetting.class);
            field.setAccessible(true);
            try {
                int column = fieldIndex / settingsPerColumn;
                int row = fieldIndex % settingsPerColumn;
                int settingX = centerX + 20 + column * (settingWidth + 20);
                int settingY = centerY + yOffset + (row * SETTING_HEIGHT) - scrollOffset;

                if (settingY >= visibleStartY - BUTTON_HEIGHT && settingY <= visibleEndY) {
                    createSettingControl(settings, field, annotation, settingX, settingY,
                            labelWidth, controlWidth, BUTTON_HEIGHT);
                }
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        return yOffset + (settingsPerColumn * SETTING_HEIGHT) + MOVEMENT_SPACING;
    }

    private void createSettingControl(AbstractMovementSettings settings, Field field,
                                      MovementSetting annotation, int settingX, int settingY,
                                      int labelWidth, int controlWidth, int BUTTON_HEIGHT)
            throws IllegalAccessException {
        if (annotation.type() == MovementSettingType.ENUM) {
            // For enums, create the button
            ButtonWidget enumButton = SettingWidget.createEnumButton(
                    settingX,
                    settingY,
                    labelWidth + controlWidth + 10,
                    BUTTON_HEIGHT,
                    field.getName(),
                    settings,
                    annotation
            );
            addDrawableChild(enumButton);

            // Add warning if needed for postMoveMouse field
            if (field.getName().equals("postMoveMouse")) {
                AbstractMovementSettings.POST_MOVE_MOUSE mouseMode =
                        (AbstractMovementSettings.POST_MOVE_MOUSE) field.get(settings);

                // Get the postMoveKeys field
                try {
                    Field keysField = AbstractMovementSettings.class.getDeclaredField("postMoveKeys");
                    keysField.setAccessible(true);
                    AbstractMovementSettings.POST_MOVE_KEYS keysMode =
                            (AbstractMovementSettings.POST_MOVE_KEYS) keysField.get(settings);

                    // Check warning conditions - only show warning for camera movement modes
                    if (mouseMode == AbstractMovementSettings.POST_MOVE_MOUSE.NONE &&
                            (keysMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
                                    keysMode == AbstractMovementSettings.POST_MOVE_KEYS.MOVE_CAMERA_FREE) &&
                            keysMode != AbstractMovementSettings.POST_MOVE_KEYS.MOVE8 &&
                            keysMode != AbstractMovementSettings.POST_MOVE_KEYS.NONE) {

                        // Create warning button
                        ButtonWidget warningButton = ButtonWidget.builder(
                                        Text.literal("!").formatted(Formatting.GOLD),
                                        button -> {}
                                )
                                .dimensions(settingX + labelWidth + controlWidth + 15, settingY, 20, BUTTON_HEIGHT)
                                .tooltip(Tooltip.of(Text.literal(
                                        "Warning: Camera rotation will be locked, Rotate Camera recommended")))
                                .build();

                        addDrawableChild(warningButton);
                    }
                } catch (Exception e) {
                    Craneshot.LOGGER.error("Error checking warning conditions", e);
                }
            }
        } else {
            // For non-enum settings, keep the original label + control layout
            addDrawableChild(ButtonWidget.builder(Text.literal(annotation.label()), button -> {})
                    .dimensions(settingX, settingY, labelWidth, BUTTON_HEIGHT)
                    .build());
            addDrawableChild(SettingWidget.createSlider(
                    settingX + labelWidth + 10,
                    settingY,
                    controlWidth,
                    BUTTON_HEIGHT,
                    Text.literal(annotation.label()),
                    annotation.min(),
                    annotation.max(),
                    ((Number) field.get(settings)).doubleValue(),
                    field.getName(),
                    settings
            ));
        }
    }

    private void collectSettingFields(AbstractMovementSettings settings, List<Field> settingFields) {
        // Get fields from the concrete class
        for (Field field : settings.getClass().getDeclaredFields()) {
            if (field.isAnnotationPresent(MovementSetting.class)) {
                settingFields.add(field);
            }
        }
        // Get fields from AbstractMovementSettings
        for (Field field : AbstractMovementSettings.class.getDeclaredFields()) {
            if (field.isAnnotationPresent(MovementSetting.class)) {
                settingFields.add(field);
            }
        }
    }

    private void updateScrollBounds(int yOffset) {
        int contentHeight = yOffset - (CONTENT_START_Y + 20);
        int visibleHeight = guiHeight - CONTENT_START_Y - 30; // Additional padding
        maxScroll = Math.max(0, contentHeight - visibleHeight);
    }



    // In MenuOverlayScreen.java
    private void cycleMovementType() {
        List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
        if (!movements.isEmpty()) {
            selectedMovementTypeIndex = (selectedMovementTypeIndex + 1) % movements.size();

            // Update the button text immediately
            for (Element child : this.children()) {
                if (child instanceof ButtonWidget button) {
                    String buttonText = button.getMessage().getString();
                    if (buttonText.startsWith("Type: ")) {
                        String currentTypeName = movements.get(selectedMovementTypeIndex).getName();
                        button.setMessage(Text.literal("Type: " + currentTypeName));
                        break;
                    }
                }
            }
        }
    }

    private void addMovement(int slotIndex) {
        List<CameraMovementRegistry.MovementInfo> movements = CameraMovementRegistry.getAllMovements();
        if (!movements.isEmpty()) {
            try {
                ICameraMovement newMovement = movements.get(selectedMovementTypeIndex)
                        .getMovementClass()
                        .getDeclaredConstructor()
                        .newInstance();
                CraneshotClient.MOVEMENT_MANAGER.addMovement(slotIndex, newMovement);
                reinitialize();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public void resize(MinecraftClient client, int width, int height) {
        super.resize(client, width, height);
        this.scrollOffset = 0;
        this.reinitialize();
    }

    @Override
    public void render(DrawContext context, int mouseX, int mouseY, float delta) {
        context.fill(0, 0, this.width, this.height, 0x80000000);
        context.fill(
                centerX,
                centerY + CONTENT_START_Y,
                centerX + guiWidth,
                centerY + guiHeight,
                0xC0000000
        );
        super.render(context, mouseX, mouseY, delta);
        if (maxScroll > 0) {
            if (scrollOffset > 0) {
                context.drawCenteredTextWithShadow(
                        this.textRenderer,
                        Text.literal("▲"),
                        centerX + guiWidth - 15,
                        centerY + CONTENT_START_Y,
                        0xFFFFFF
                );
            }
            if (scrollOffset < maxScroll) {
                context.drawCenteredTextWithShadow(
                        this.textRenderer,
                        Text.literal("▼"),
                        centerX + guiWidth - 15,
                        centerY + guiHeight - 15,
                        0xFFFFFF
                );
            }
        }
    }

    // Keep existing helper methods
    private boolean isMovementExpanded(int slotIndex, int movementIndex) {
        return expandedMovements.computeIfAbsent(slotIndex, k -> new HashSet<>()).contains(movementIndex);
    }

    private void toggleMovementExpanded(int slotIndex, int movementIndex) {
        Set<Integer> expanded = expandedMovements.computeIfAbsent(slotIndex, k -> new HashSet<>());
        if (!expanded.remove(movementIndex)) {
            expanded.add(movementIndex);
        }
    }
    
    // New methods for managing collapsible settings
    private boolean isSettingsExpanded(String settingsKey) {
        return expandedSettings.contains(settingsKey);
    }

    private void toggleSettingsExpanded(String settingsKey) {
        if (!expandedSettings.remove(settingsKey)) {
            expandedSettings.add(settingsKey);
        }
    }



    private void deleteMovement(int slotIndex, int movementIndex) {
        CraneshotClient.MOVEMENT_MANAGER.removeMovement(slotIndex, movementIndex);
        reinitialize();
    }

    private void moveMovement(int slotIndex, int fromIndex, int toIndex) {
        CraneshotClient.MOVEMENT_MANAGER.swapMovements(slotIndex, fromIndex, toIndex);
        reinitialize();
    }

    void reinitialize() {
        this.clearChildren();
        this.init();
    }

    @Override
    public boolean mouseScrolled(double mouseX, double mouseY, double horizontalAmount, double verticalAmount) {
        if (verticalAmount != 0) {
            scroll((int)(-verticalAmount * SCROLL_SPEED));
            return true;
        }
        return super.mouseScrolled(mouseX, mouseY, horizontalAmount, verticalAmount);
    }

    @Override
    public boolean keyPressed(net.minecraft.client.input.KeyInput input) {
        // ESC
        if (input.getKeycode() == org.lwjgl.glfw.GLFW.GLFW_KEY_ESCAPE) {
            close();
            return true;
        }

        // Inventory key
        if (this.client != null && this.client.options.inventoryKey.matchesKey(input)) {
            close();
            return true;
        }

        return super.keyPressed(input);
    }

    private void scroll(int amount) {
        if (maxScroll > 0) {
            scrollOffset = Math.max(0, Math.min(scrollOffset + amount, maxScroll));
            clearChildren();
            init();
        }
    }

    private void switchTab(int index) {
        selectedTab = index;
        scrollOffset = 0;
        clearChildren();
        init();
    }

    public void toggleMenu() {
        MinecraftClient client = MinecraftClient.getInstance();
        if (isMenuOpen) {
            close();
        } else {
            client.setScreen(this);
            isMenuOpen = true;
        }
    }

    @Override
    public void close() {
        // Save the current slots configuration before closing
        List<List<ICameraMovement>> slots = new ArrayList<>();
        for (int i = 0; i < CraneshotClient.MOVEMENT_MANAGER.getMovementCount(); i++) {
            slots.add(CraneshotClient.MOVEMENT_MANAGER.getAvailableMovementsForSlot(i));
        }
        SlotSettingsIO.saveSlots(slots);
        GeneralSettingsIO.saveSettings();

        if (this.client != null) {
            this.client.setScreen(null);
        }
        isMenuOpen = false;
    }

    private void copyMovement(ICameraMovement movement) {
        SlotSettingsIO.copyMovementToClipboard(movement);
    }

    private void pasteMovement(int slotIndex) {
        try {
            ICameraMovement newMovement = SlotSettingsIO.createMovementFromClipboard();
            if (newMovement != null) {
