                ((FovAccessor) client.gameRenderer).setFovModifier(fovMultiplier);
                // Only log significant FOV changes to reduce console spam
                if (Math.abs(fovMultiplier - 1.0) > 0.001) {
                    Craneshot.LOGGER.debug("set fov {}", fovMultiplier);
                }
            }
            
            if (cameraSystemActive) {
                // Let the camera system update its state
                if (currentMouseMoveMode == POST_MOVE_MOUSE.ROTATE_CAMERA && client.mouse instanceof IMouseMixin) {
                    IMouseMixin mouseMixin = (IMouseMixin) client.mouse;
                    double deltaX = mouseMixin.getCapturedDeltaX();
                    double deltaY = -mouseMixin.getCapturedDeltaY();
                    
                    if (deltaX != 0 || deltaY != 0) {
                        double mouseSensitivity = client.options.getMouseSensitivity().getValue();
                        double calculatedSensitivity = 0.6 * mouseSensitivity * mouseSensitivity * mouseSensitivity + 0.2;
                        cameraSystem.updateRotation(
                            deltaX * calculatedSensitivity * 0.55D,
                            deltaY * calculatedSensitivity * 0.55D,
                            1.0
                        );
                    }
                } else {
                    // Use the movement manager's position/rotation if not freely rotating
                    cameraSystem.setCameraPosition(baseTarget.getPosition());
                    cameraSystem.setCameraRotation(baseTarget.getYaw(), baseTarget.getPitch());
                }
                
                // Update our tracking variables for legacy code support
                freeCamPosition = cameraSystem.getCameraPosition();
                freeCamYaw = cameraSystem.getCameraYaw();
                freeCamPitch = cameraSystem.getCameraPitch();
                
                // Let the camera system update the camera
                cameraSystem.updateCamera(camera);
            } else {
                // Legacy camera handling
                // Only update freeCamPosition from movement if we're not in free movement mode
                if (currentKeyMoveMode != POST_MOVE_KEYS.MOVE_CAMERA_FLAT &&
                        currentKeyMoveMode != POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
                    freeCamPosition = baseTarget.getPosition();
                }

                // Handle rotation based on movement mode
                if (currentMouseMoveMode == POST_MOVE_MOUSE.ROTATE_CAMERA && client.mouse instanceof IMouseMixin) {
                    IMouseMixin mouseMixin = (IMouseMixin) client.mouse;
                    double deltaX = mouseMixin.getCapturedDeltaX();
                    double deltaY = -mouseMixin.getCapturedDeltaY();
                    double mouseSensitivity = client.options.getMouseSensitivity().getValue();
                    double calculatedSensitivity = 0.6 * mouseSensitivity * mouseSensitivity * mouseSensitivity + 0.2;
                    deltaX *= calculatedSensitivity * 0.55D;
                    deltaY *= calculatedSensitivity * 0.55D;
                    if (deltaX != 0 || deltaY != 0) {
                        freeCamYaw += deltaX;
                        freeCamPitch = (float) Math.max(-90.0F, Math.min(90.0F, freeCamPitch - deltaY));
                    }
                } else {
                    freeCamYaw = baseTarget.getYaw();
                    freeCamPitch = baseTarget.getPitch();
                }
                
                // Apply the camera position and rotation
                ((CameraAccessor) camera).invokesetPos(freeCamPosition);
                ((CameraAccessor) camera).invokeSetRotation(freeCamYaw, freeCamPitch);
            }
        } else if (cameraSystemActive) {
            // If we have no target but the camera system is active, let it update
            cameraSystem.updateCamera(camera);
            
            // Update tracking variables
            freeCamPosition = cameraSystem.getCameraPosition();
            freeCamYaw = cameraSystem.getCameraYaw();
            freeCamPitch = cameraSystem.getCameraPitch();
        }

        // Handle keyboard movement for camera modes
        if (currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
                currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FREE) {
            handleKeyboardMovement(client, camera);
        }

        updateMessageTimer();
    }



    //=== Message Handling ========================================================

    public void showMessage(String message) {
        currentMessage = message;
        messageTimer = System.currentTimeMillis() + MESSAGE_DURATION;
    }

    public String getCurrentMessage() {
        return currentMessage;
    }

    public boolean hasActiveMessage() {
        return System.currentTimeMillis() < messageTimer;
    }

    private void updateMessageTimer() {
        if (System.currentTimeMillis() >= messageTimer) {
            currentMessage = "";
        }
    }

    /**
     * Updates the camera each frame. This method (which used to be called handleCameraUpdate)
     * is responsible for applying the computed camera state (from the movement manager) as well as
     * processing any free keyboard/mouse input. It should be placed in CameraController.
     */
    public void handleCameraUpdate(BlockView area, Entity focusedEntity, boolean thirdPerson,
                                   boolean inverseView, float tickDelta, Camera camera) {
        // Verify that both the camera and the focused entity exist.
        if (camera == null || focusedEntity == null) return;

        MinecraftClient client = MinecraftClient.getInstance();
        if (client == null || client.world == null) return;

        // Update the camera based on movement-manager and free control states.
        updateCamera(client, camera, tickDelta);

        // Optionally update keyboard input (e.g. disable it when free control is active)
        updateKeyboardInput(client);
    }

    private void updateKeyboardInput(MinecraftClient client) {
        if (client.player != null && client.player.input instanceof IKeyboardInputMixin) {
            // Only disable player movement when our post-move mode requires camera keyboard control.
            // Do NOT blanket-disable just because the camera system is active; Bezier out-phase needs player input.
            boolean shouldDisable = currentKeyMoveMode == POST_MOVE_KEYS.MOVE8 ||
                                   currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FLAT ||
                                   currentKeyMoveMode == POST_MOVE_KEYS.MOVE_CAMERA_FREE;
            ((IKeyboardInputMixin) client.player.input).setDisabled(shouldDisable);
        }
    }

    public void onComplete() {
        // Reset all movement modes completely
        currentMouseMoveMode = POST_MOVE_MOUSE.NONE;
        currentKeyMoveMode = POST_MOVE_KEYS.NONE;
        
        // Reset the keyboard movement tracking flag
        hasMovedWithKeyboard = false;
        
        // Ensure keyboard input is enabled for the player
        MinecraftClient client = MinecraftClient.getInstance();
        if (client != null && client.player != null && client.player.input instanceof IKeyboardInputMixin) {
            ((IKeyboardInputMixin) client.player.input).setDisabled(false);
        }
        
        // Disable mouse interception
        MouseInterceptor.setIntercepting(false);
        
        // Make sure to restore default camera behavior by deactivating the camera system
        CameraSystem cameraSystem = CameraSystem.getInstance();
        if (cameraSystem.isCameraActive()) {
            cameraSystem.deactivateCamera();
            ninja.trek.Craneshot.LOGGER.info("Deactivated camera system during onComplete");
        }
        
        // Reset the camera position to follow the player
        if (client != null && client.player != null) {
            freeCamPosition = client.player.getEyePos();
            freeCamYaw = client.player.getYaw();
            freeCamPitch = client.player.getPitch();
            ninja.trek.Craneshot.LOGGER.info("Reset camera position to player position");
        }
        
        // Reset FOV to default
        if (client != null && client.gameRenderer instanceof FovAccessor) {
            ((FovAccessor) client.gameRenderer).setFovModifier(1.0f);
        }
    }
}
